<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Vue Router原理及简单实现</title>
      <link href="2021/05/12/Vue-router%20-mini/"/>
      <url>2021/05/12/Vue-router%20-mini/</url>
      
        <content type="html"><![CDATA[<h1 id="Vue-Router"><a href="#Vue-Router" class="headerlink" title="Vue Router"></a>Vue Router</h1><p>Vue Router 是 Vue.js 官⽅的路由管理器</p><p><a href="%5Bhttps://wuyangqin.github.io/2020/09/27/Vue-router/">Vue Router知识点回顾</a></p><p>核⼼步骤：</p><ul><li><p>步骤⼀：使⽤vue-router插件，router.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Router <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line">Vue.use(Router)</span><br></pre></td></tr></table></figure></li><li><p>步骤⼆：创建Router实例，router.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Router(&#123;...&#125;)</span><br></pre></td></tr></table></figure></li><li><p>步骤三：在根组件上添加该实例，main.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">&#x27;./router&#x27;</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line"> router,</span><br><span class="line">&#125;).$mount(<span class="string">&quot;#app&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p>步骤四：添加路由视图，App.vue</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>导航</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/&quot;</span>&gt;</span>Home<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/about&quot;</span>&gt;</span>About<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.$router.push(<span class="string">&#x27;/&#x27;</span>)</span><br><span class="line"><span class="built_in">this</span>.$router.push(<span class="string">&#x27;/about&#x27;</span>)</span><br></pre></td></tr></table></figure></li></ul><h1 id="Vue-Router源码实现"><a href="#Vue-Router源码实现" class="headerlink" title="Vue Router源码实现"></a>Vue Router源码实现</h1><p>根据以上的核心步骤，尝试简单实现一个自己的Vue Router</p><p><a href="https://github.com/wuyangqin/y-vue-study/tree/vue-router">源码链接</a></p><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><p>首先基于以上步骤，对需要实现的功能进行解构：</p><ul><li>Vue Router是以Vue插件形式存在；</li><li>url变化页面不刷新，内容变化；</li><li>实现两个全局组件router-link 和router-view；</li><li>数据响应式，url变化内容重新渲染，不需要额外dom操作；</li><li>路由嵌套；</li></ul><p>然后将需求拆解为具体的任务：</p><ul><li>实现⼀个插件<ul><li>实现VueRouter类<ul><li>处理路由选项</li><li>监控url变化，hashchange</li><li>响应这个变化</li></ul></li><li>实现install⽅法<ul><li>$router注册</li><li>两个全局组件</li><li>嵌套路由</li></ul></li></ul></li></ul><h2 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h2><h3 id="实现插件：创建VueRouter类和install方法"><a href="#实现插件：创建VueRouter类和install方法" class="headerlink" title="实现插件：创建VueRouter类和install方法"></a>实现插件：创建VueRouter类和install方法</h3><p>根据Vue官方文档，Vue.js的插件应该暴露一个 <code>install</code> 方法。这个方法的第一个参数是 <code>Vue</code> 构造器，第二个参数是一个可选的选项对象。</p><p>因此，只需暴露一个具有<code>install</code>方法的<code>VueRouter类</code>即可。</p><p>创建yvue-router.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> Vue; <span class="comment">// 引⽤构造函数，VueRouter中要使⽤</span></span><br><span class="line"><span class="comment">// 保存选项</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VueRouter</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">options</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.options = options;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插件：实现install⽅法，注册$router</span></span><br><span class="line">VueRouter.install = <span class="function"><span class="keyword">function</span> (<span class="params">_Vue</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 引⽤构造函数，VueRouter中要使⽤</span></span><br><span class="line">  Vue = _Vue;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 任务1：挂载$router</span></span><br><span class="line">  Vue.mixin(&#123;</span><br><span class="line">    <span class="function"><span class="title">beforeCreate</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="comment">// 只有根组件拥有router选项</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.$options.router) &#123;</span><br><span class="line">        <span class="comment">// vm.$router</span></span><br><span class="line">        Vue.prototype.$router = <span class="built_in">this</span>.$options.router;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 任务2：实现两个全局组件router-link和router-view</span></span><br><span class="line">  Vue.component(<span class="string">&#x27;router-link&#x27;</span>, Link)</span><br><span class="line">  Vue.component(<span class="string">&#x27;router-view&#x27;</span>, View)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> VueRouter;</span><br></pre></td></tr></table></figure><p>yvue-router/index.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> VueRouter <span class="keyword">from</span> <span class="string">&#x27;./yvue-router&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// use方法内部会调用install(Vue)</span></span><br><span class="line">Vue.use(VueRouter)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">    name: <span class="string">&#x27;Home&#x27;</span>,</span><br><span class="line">    component: Home</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">&#x27;/about&#x27;</span>,</span><br><span class="line">    name: <span class="string">&#x27;About&#x27;</span>,</span><br><span class="line">    component: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="comment">/* webpackChunkName: &quot;about&quot; */</span> <span class="string">&#x27;../views/About.vue&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(</span><br><span class="line">  &#123;</span><br><span class="line">    routes</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>main.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">&#x27;./yvue-router&#x27;</span></span><br><span class="line"></span><br><span class="line">Vue.config.productionTip = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  router,</span><br><span class="line">  render: <span class="function"><span class="params">h</span> =&gt;</span> h(App)</span><br><span class="line">&#125;).$mount(<span class="string">&#x27;#app&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p><strong>为什么要单独保存install函数中传递的Vue构造函数</strong>：</p><p>相当于引用，将来打包时不会将vue打包</p></li><li><p><strong>为什么要使用mixin</strong>：</p><p>因为use在前，Router实例创建在后，⽽install逻辑⼜需要⽤到该实例。</p><p>因此将创建的Router实例在new Vue时传入，这样就能在mixin中利用生命周期钩子，在组件创建前将实例注册到全局($router)</p></li></ul><h3 id="创建router-view和router-link"><a href="#创建router-view和router-link" class="headerlink" title="创建router-view和router-link"></a>创建<strong>router-view</strong>和<strong>router-link</strong></h3><p>components/link.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    to: <span class="built_in">String</span>,</span><br><span class="line">    required: <span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params">h</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// return &lt;a href=&#123;&#x27;#&#x27;+this.to&#125;&gt;&#123;this.$slots.default&#125;&lt;/a&gt;;</span></span><br><span class="line">    <span class="keyword">return</span> h(<span class="string">&#x27;a&#x27;</span>, &#123;</span><br><span class="line">      attrs: &#123;</span><br><span class="line">        href: <span class="string">&#x27;#&#x27;</span> + <span class="built_in">this</span>.to</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, [</span><br><span class="line">      <span class="built_in">this</span>.$slots.default</span><br><span class="line">    ])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>components/view.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line"> <span class="function"><span class="title">render</span>(<span class="params">h</span>)</span> &#123;</span><br><span class="line"> <span class="comment">// 暂时先不渲染任何内容</span></span><br><span class="line"> <span class="keyword">return</span> h(<span class="literal">null</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>为什么不能用template</strong>：VueCli的环境下的vue版本是runtimeonly,没有编译器</li><li><strong>为什么不用jsx</strong>：兼容性不太好</li></ul><h3 id="监控url变化"><a href="#监控url变化" class="headerlink" title="监控url变化"></a>监控url变化</h3><p>定义响应式的current属性，监听hashchange事件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VueRouter</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">options</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 定义响应式的属性current</span></span><br><span class="line">    <span class="keyword">const</span> initial = <span class="built_in">window</span>.location.hash.slice(<span class="number">1</span>) || <span class="string">&#x27;/&#x27;</span></span><br><span class="line">    Vue.util.defineReactive(<span class="built_in">this</span>, <span class="string">&#x27;current&#x27;</span>, initial)</span><br><span class="line">    <span class="comment">// 监听hashchange事件</span></span><br><span class="line">    <span class="built_in">window</span>.addEventListener(<span class="string">&#x27;hashchange&#x27;</span>, <span class="built_in">this</span>.onHashChange.bind(<span class="built_in">this</span>))</span><br><span class="line">    <span class="built_in">window</span>.addEventListener(<span class="string">&#x27;load&#x27;</span>, <span class="built_in">this</span>.onHashChange.bind(<span class="built_in">this</span>))</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="title">onHashChange</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.current = <span class="built_in">window</span>.location.hash.slice(<span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>动态获取对应组件, view.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params">h</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 动态获取对应组件</span></span><br><span class="line">    <span class="keyword">let</span> component = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">const</span> route = <span class="built_in">this</span>.$router.$options.routes.find(<span class="function"><span class="params">route</span> =&gt;</span> route.path ===</span><br><span class="line">      <span class="built_in">this</span>.$router.current)</span><br><span class="line">    <span class="keyword">if</span>(route) component = route.component</span><br><span class="line">    <span class="keyword">return</span> h(component);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>如何实现url的响应式</strong>？<ul><li>方式1：借鸡生蛋   new Vue({data})</li><li>方式2： Vue.util.defineReactive(obj,’current’)，这是Vue构造函数中提供的一个方法</li></ul></li></ul><h3 id="实现嵌套路由"><a href="#实现嵌套路由" class="headerlink" title="实现嵌套路由"></a>实现嵌套路由</h3><p>在实现了简单的路由切换后，尝试实现嵌套路由。</p><p>首先在创建路由实例时加入了如下配置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  path: <span class="string">&#x27;/about&#x27;</span>,</span><br><span class="line">  name: <span class="string">&#x27;About&#x27;</span>,</span><br><span class="line">  component: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="comment">/* webpackChunkName: &quot;about&quot; */</span> <span class="string">&#x27;../views/About.vue&#x27;</span>),</span><br><span class="line">  children: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">&#x27;/about/child1&#x27;</span>,</span><br><span class="line">      name: <span class="string">&#x27;child1&#x27;</span>,</span><br><span class="line">      component: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="comment">/* webpackChunkName: &quot;about&quot; */</span> <span class="string">&#x27;../components/Child1.vue&#x27;</span>),</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">&#x27;/about/child2&#x27;</span>,</span><br><span class="line">      name: <span class="string">&#x27;child2&#x27;</span>,</span><br><span class="line">      component: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="comment">/* webpackChunkName: &quot;about&quot; */</span> <span class="string">&#x27;../components/Child2.vue&#x27;</span>),</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在About组件中，也加入了相应的<code>router-link</code>及<code>router-view</code>。运行时却发现陷入了死循环：</p><p><img src="/images/vue/error-max.png"></p><p>原因在于：<code>router-view</code>渲染了About组件后，发现About组件里也有router-view组件，因此就不断地渲染About组件，陷入死循环。</p><p>那么该如何解决这个问题？</p><p>查看VueRouter源码后发现，<code>router-view</code>在渲染前进行了如下操作：</p><ul><li>标记当前<code>router-view</code>的深度</li><li>递归遍历routes选项，将匹配的route存入一个数组中，再通过当前的深度获取对应的component</li></ul><p>参考这个思路，简单实现了路由的嵌套：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VueRouter</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">options</span>)</span> &#123;</span><br><span class="line">    Vue.util.defineReactive(<span class="built_in">this</span>,<span class="string">&#x27;current&#x27;</span>,<span class="built_in">this</span>.getHash());</span><br><span class="line">    Vue.util.defineReactive(<span class="built_in">this</span>, <span class="string">&#x27;matched&#x27;</span>, [])</span><br><span class="line">    <span class="built_in">this</span>.match()</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="title">getHash</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">window</span>.location.hash.slice(<span class="number">1</span>) || <span class="string">&quot;/&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="title">onHashchange</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.current = <span class="built_in">this</span>.getHash()</span><br><span class="line">    <span class="built_in">this</span>.matched = []</span><br><span class="line">    <span class="built_in">this</span>.match()</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="title">match</span>(<span class="params">routes</span>)</span> &#123;</span><br><span class="line">    routes = routes || <span class="built_in">this</span>.options.routes</span><br><span class="line">    <span class="comment">// 递归遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> route <span class="keyword">of</span> routes) &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123;path&#125; = route</span><br><span class="line">      <span class="keyword">const</span> &#123;current&#125; = <span class="built_in">this</span></span><br><span class="line">      <span class="keyword">if</span> (path === <span class="string">&#x27;/&#x27;</span> &amp;&amp; current === <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.matched.push(route)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (path !== <span class="string">&#x27;/&#x27;</span> &amp;&amp; current.indexOf(path) &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.matched.push(route)</span><br><span class="line">        <span class="keyword">if</span> (route.children &amp;&amp; route.children.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="built_in">this</span>.match(route.children)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>view.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params">h</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 标记该组件有routerView</span></span><br><span class="line">    <span class="built_in">this</span>.$vnode.data.routerView = <span class="literal">true</span></span><br><span class="line">    <span class="comment">// 标记当前router-view深度</span></span><br><span class="line">    <span class="keyword">let</span> depth = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> parent = <span class="built_in">this</span>.$parent</span><br><span class="line">    <span class="keyword">while</span> (parent) &#123; <span class="comment">// 向上层层寻找父组件，有n个父组件中有routerView，则深度为n</span></span><br><span class="line">      <span class="keyword">const</span> vnodeData = parent.$vnode &amp;&amp; parent.$vnode.data</span><br><span class="line">      <span class="keyword">if</span> (vnodeData &amp;&amp; vnodeData.routerView) &#123;</span><br><span class="line">        depth++;</span><br><span class="line">      &#125;</span><br><span class="line">      parent = parent.$parent</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取matched对应的component</span></span><br><span class="line">    <span class="keyword">let</span> component = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">const</span> route = <span class="built_in">this</span>.$router.matched[depth]</span><br><span class="line">    <span class="keyword">if</span> (route) &#123;</span><br><span class="line">      component = route.component</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> h(component)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
          <category> Vue2 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> Vue2 </tag>
            
            <tag> Vue Router </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue两个版本：runtime-compiler和 runtime-only 的区别</title>
      <link href="2021/05/09/Vue-runtime-only/"/>
      <url>2021/05/09/Vue-runtime-only/</url>
      
        <content type="html"><![CDATA[<blockquote><p>参考vue文档链接： <a href="https://cn.vuejs.org/v2/guide/installation.html#%E5%BC%80%E5%8F%91%E7%89%88%E6%9C%AC">https://cn.vuejs.org/v2/guide/installation.html#%E5%BC%80%E5%8F%91%E7%89%88%E6%9C%AC</a></p></blockquote><h2 id="runtime-Compiler-和-runtime-only在main-js文件的区别"><a href="#runtime-Compiler-和-runtime-only在main-js文件的区别" class="headerlink" title="runtime-Compiler 和 runtime-only在main.js文件的区别"></a>runtime-Compiler 和 runtime-only在main.js文件的区别</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//（1） Runtime-Compiler</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  components: &#123; App &#125;,</span><br><span class="line">  template: <span class="string">&#x27;&lt;App/&gt;&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"> </span><br><span class="line"><span class="comment">// （2）Runtime-only</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  render: <span class="function"><span class="params">h</span> =&gt;</span> h(App)</span><br><span class="line">&#125;)Copy</span><br></pre></td></tr></table></figure><p>在上述代码块中可以看出最大的区别在于 ：</p><p><strong>runtime-Compiler 中的参数是 components 和 template</strong> 。而<strong>runtime-only版本中的参数是 render 函数</strong>。</p><h2 id="runtime-only-版本-不能有-template"><a href="#runtime-only-版本-不能有-template" class="headerlink" title="runtime-only 版本 不能有 template"></a>runtime-only 版本 不能有 template</h2><p>在这个vue不完整版，需要借助webpack的 <strong>vue-loader</strong>加载器 <strong>把vue文件编译成js</strong>。</p><p>webpack使用vue-loader将vuew文件编译js的过程中会<strong>将组件的template模板编译位render函数</strong>，所以我们得到的是render函数就如上图所示。</p><p>所以，该版本只会包含运行时的vue代码，对于template这种需要编译，只交给webpack即可。</p><p>这会使得该版本代码的体积小。</p><h2 id="runtime-complier版本-可以有template"><a href="#runtime-complier版本-可以有template" class="headerlink" title="runtime-complier版本 可以有template"></a>runtime-complier版本 可以有template</h2><p>如果写了template，那么就会在运行时直接编译成render函数， 而不是依靠webpack来帮助编译，这不仅仅使得该版本体积变大，而且在编译过程也会对性能有一定的损耗。</p><h2 id="runtime-complier-解析过程："><a href="#runtime-complier-解析过程：" class="headerlink" title="runtime-complier 解析过程："></a>runtime-complier 解析过程：</h2><ul><li>第一步：将template模板转换成抽象语法树（ast）;</li><li>第二步：通过render函数将抽象语法树转换成虚拟DOM（vdom）;</li><li>第三步：将虚拟DOM转换成真正的DOM；</li></ul><p><strong>template =&gt; 抽象语法树(ast) =&gt; render() =&gt; 虚拟DOM(vdom) =&gt; 页面</strong></p><h2 id="runtime-only-解析过程："><a href="#runtime-only-解析过程：" class="headerlink" title="runtime-only 解析过程："></a>runtime-only 解析过程：</h2><ul><li>第一步：vue-template-compiler插件直接将组件转换成 render函数；</li><li>第二步：将render函数返回的虚拟DOM转换成页面；</li></ul><p><strong>render() =&gt; 虚拟DOM(vdom) =&gt; 页面；</strong></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><table><thead><tr><th></th><th>vue完整版（runtime-compiler）</th><th>vue非完整版（runtime-only）</th><th>评价</th></tr></thead><tbody><tr><td>特点</td><td>有compiler</td><td>没有compiler</td><td>compiler 占40%体积</td></tr><tr><td>视图</td><td>写在HTML里或者写在template选项</td><td>写在render函数里用h来创建标签</td><td></td></tr><tr><td>cdn引入</td><td>vue.js</td><td>vue.runtime.js</td><td>文件名不同</td></tr><tr><td>webpack引入</td><td>需要额外配置alias</td><td>默认使用此版本</td><td></td></tr><tr><td>@vue/cli 引入</td><td>需要额外配置</td><td>默认使用此版本</td><td></td></tr></tbody></table><p>因此推荐使用 vue非完整版（<strong>runtime-only</strong>）。</p><p><strong>优点:</strong></p><ul><li>保证用户体验，用户下载的JS文件体积更小，但支持h函数（render函数中的h）。</li><li>保证开发体验，开发者可以直接在vue文件里写html标签，而不写h函数</li><li>累活都让loader做，vue-loader把vue文件里的html转为h函数。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大屏可视化项目实践</title>
      <link href="2021/05/08/Vue-visual-data/"/>
      <url>2021/05/08/Vue-visual-data/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>大数据时代，大屏数据展示的需求日益增加，很多政府单位或企业会使用数据大屏进行报表展示、业务监控等。因此，出于学习和实践的目的，完成了一个简单的大屏可视化项目。</p><h2 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h2><p><a href="https://wuyangqin.github.io/visual-data-dist/#/">线上地址</a></p><p><a href="https://github.com/wuyangqin/visual-data">源码链接</a></p><p><img src="/images/react/finish.png"></p><h2 id="技术栈"><a href="#技术栈" class="headerlink" title="技术栈"></a>技术栈</h2><p>React、ReactRouter、Echarts</p><h2 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h2><p>该项目的实现主要是解决了以下问题：</p><h3 id="如何进行屏幕适配"><a href="#如何进行屏幕适配" class="headerlink" title="如何进行屏幕适配"></a>如何进行屏幕适配</h3><h4 id="大屏适配公式"><a href="#大屏适配公式" class="headerlink" title="大屏适配公式"></a>大屏适配公式</h4><p>首先要考虑的问题是，数据展示区域的宽高如何计算，如何使画面在不同设备下都能居中？</p><p>假设设计稿的比例为16:9，那么页面在设备中的布局应该有如下两种情况：</p><p><img src="/images/react/daping1.png" alt="页面在设备中布局示意图"></p><p>根据示意图可得，如果设备宽高比&lt;=16:9，那么页面宽度应该就是设备宽度；如果宽高比 &gt;16:9，那么页面宽度应为设备高度 * 16/9，页面高度根据页面宽度换算，具体计算公式如下：</p><p><img src="/images/react/daping.png" alt="大屏适配公式"></p><ul><li>Wp 为页面有效宽度，Hp 为页面有效高度</li><li>页面左右居中，上下居中，四周留白</li></ul><p>代码如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;zh&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">content</span>=<span class="string">&quot;width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no,viewport-fit=cover&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>大屏可视化项目<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> clientWidth = <span class="built_in">document</span>.documentElement.clientWidth;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> clientHeight = <span class="built_in">document</span>.documentElement.clientHeight;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> screenScale = clientWidth / clientHeight</span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> scale = <span class="number">16</span> / <span class="number">9</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.pageWidth = screenScale &gt; scale ? clientHeight * scale : clientWidth;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> pageHeight = pageWidth / scale</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;root&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  root.style.width = pageWidth + <span class="string">&#x27;px&#x27;</span></span></span><br><span class="line"><span class="javascript">  root.style.height = pageHeight + <span class="string">&#x27;px&#x27;</span></span></span><br><span class="line"><span class="javascript">  root.style.marginTop =( clientHeight - pageHeight)/<span class="number">2</span> + <span class="string">&#x27;px&#x27;</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span> <span class="attr">src</span>=<span class="string">&quot;/src/main.tsx&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#root</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: auto;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">flex-direction</span>: column;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="rem计算公式"><a href="#rem计算公式" class="headerlink" title="rem计算公式"></a>rem计算公式</h4><p>解决完页面与屏幕的适配问题，接下来需要解决的就是如何适配一个div，即设计稿上一个div的尺寸如何换算成页面上的尺寸？</p><p>常见的方法就是使用<code>rem适配</code> —&gt; 根据页面宽度规定1rem的大小，然后根据设计稿尺寸和页面尺寸进行换算。</p><p>因此，首先在<code>head</code>里，设置<code>1rem = Wp / 100</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> string = <span class="string">`&lt;style&gt;html &#123;</span></span><br><span class="line"><span class="string">font-size: <span class="subst">$&#123;pageWidth / <span class="number">100</span>&#125;</span>px</span></span><br><span class="line"><span class="string">&#125;&lt;/style&gt;`</span></span><br><span class="line"><span class="built_in">document</span>.write(string)</span><br></pre></td></tr></table></figure><p>然后得到计算公式如下：</p><p><img src="/images/react/rem.png" alt="rem计算公式"></p><p>根据该计算公式可封装将px换算为rem的函数：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@function</span> px(<span class="variable">$n</span>)&#123;</span><br><span class="line">  <span class="keyword">@return</span> <span class="variable">$n</span> / <span class="number">2420</span> * <span class="number">100rem</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 使用时只需将设计稿上的像素尺寸传入即可</span><br><span class="line">  header &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">    <span class="attribute">width</span>: px(<span class="number">2420</span>);</span><br><span class="line">    <span class="attribute">height</span>: px(<span class="number">102</span>);</span><br><span class="line">    <span class="attribute">background-size</span>: cover;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="如何进行页面布局"><a href="#如何进行页面布局" class="headerlink" title="如何进行页面布局"></a>如何进行页面布局</h3><p>解决了适配的问题，接下来就是页面布局啦。</p><p>因为设计稿的布局比较规整，所以先用<code>grid</code>布局将其初步分成了五个部分：</p><p><img src="/images/react/visual-grid.png"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// home.tsx</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> headerBg <span class="keyword">from</span> <span class="string">&#x27;../static/images/header.png&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> Home = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;div className=<span class="string">&quot;home&quot;</span>&gt;</span><br><span class="line">            &lt;header style=&#123;&#123;<span class="attr">backgroundImage</span>: <span class="string">`url(<span class="subst">$&#123;headerBg&#125;</span>)`</span>&#125;&#125;&gt;&lt;/header&gt;</span><br><span class="line">            &lt;main&gt;</span><br><span class="line">                &lt;section className=<span class="string">&quot;section1&quot;</span>&gt;&lt;/section&gt;</span><br><span class="line">                &lt;section className=<span class="string">&quot;section2&quot;</span>&gt;&lt;/section&gt;</span><br><span class="line">                &lt;section className=<span class="string">&quot;section3&quot;</span>&gt;&lt;/section&gt;</span><br><span class="line">                &lt;section className=<span class="string">&quot;section4&quot;</span>&gt;&lt;/section&gt;</span><br><span class="line">                &lt;section className=<span class="string">&quot;section5&quot;</span>&gt;&lt;/section&gt;</span><br><span class="line">            &lt;/main&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// home.scss</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@import</span> <span class="string">&quot;../shared/helper&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.home</span> &#123;</span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">1</span>;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">flex-direction</span>: column;</span><br><span class="line">  &gt; <span class="selector-tag">header</span> &#123;</span><br><span class="line">    <span class="attribute">height</span>: px(<span class="number">102</span>);</span><br><span class="line">    <span class="attribute">background-size</span>: cover;</span><br><span class="line">  &#125;</span><br><span class="line">  &gt; <span class="selector-tag">main</span> &#123;</span><br><span class="line">    <span class="attribute">flex</span>: <span class="number">1</span>;</span><br><span class="line">    <span class="attribute">display</span>: grid;</span><br><span class="line">    grid-template:</span><br><span class="line">      <span class="string">&quot;box1 box2 box4 box5&quot;</span> <span class="number">755</span>fr</span><br><span class="line">      <span class="string">&quot;box3 box3 box4 box5&quot;</span> <span class="number">363</span>fr / <span class="number">366</span>fr <span class="number">361</span>fr <span class="number">811</span>fr <span class="number">747</span>fr;</span><br><span class="line">    &gt; <span class="selector-class">.section1</span> &#123;</span><br><span class="line">      grid-area: box1;</span><br><span class="line">      <span class="attribute">background</span>: lightpink;</span><br><span class="line">    &#125;</span><br><span class="line">    &gt; <span class="selector-class">.section2</span> &#123;</span><br><span class="line">      grid-area: box2;</span><br><span class="line">      <span class="attribute">background</span>: whitesmoke;</span><br><span class="line">    &#125;</span><br><span class="line">    &gt; <span class="selector-class">.section3</span> &#123;</span><br><span class="line">      grid-area: box3;</span><br><span class="line">      <span class="attribute">background</span>: lightblue;</span><br><span class="line">    &#125;</span><br><span class="line">    &gt; <span class="selector-class">.section4</span> &#123;</span><br><span class="line">      grid-area: box4;</span><br><span class="line">      <span class="attribute">background</span>: lightcyan;</span><br><span class="line">    &#125;</span><br><span class="line">    &gt; <span class="selector-class">.section5</span> &#123;</span><br><span class="line">      grid-area: box5;</span><br><span class="line">      <span class="attribute">background</span>: lightyellow;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完成了基础的布局，才能继续进行背景和边框等细节优化，以及图表的填充。</p><h3 id="Echarts的使用"><a href="#Echarts的使用" class="headerlink" title="Echarts的使用"></a>Echarts的使用</h3><h4 id="引入Echarts"><a href="#引入Echarts" class="headerlink" title="引入Echarts"></a>引入Echarts</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add echarts --save</span><br></pre></td></tr></table></figure><h4 id="添加第一个柱状图"><a href="#添加第一个柱状图" class="headerlink" title="添加第一个柱状图"></a>添加第一个柱状图</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123;useEffect, useRef&#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./home.scss&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> headerBg <span class="keyword">from</span> <span class="string">&#x27;../static/images/header.png&#x27;</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> echarts <span class="keyword">from</span> <span class="string">&#x27;echarts&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> px = <span class="function">(<span class="params">n</span>) =&gt;</span> n / <span class="number">2420</span> * (<span class="built_in">window</span> <span class="keyword">as</span> <span class="built_in">any</span>).pageWidth; <span class="comment">// 尺寸换算</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> Home = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> divRef = useRef(<span class="literal">null</span>)</span><br><span class="line">    useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> myChart = echarts.init(divRef.current);</span><br><span class="line">        myChart.setOption(&#123;</span><br><span class="line">            textStyle: &#123;</span><br><span class="line">                fontSize: px(<span class="number">12</span>),</span><br><span class="line">                color: <span class="string">&#x27;#79839E&#x27;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            title: &#123;<span class="attr">show</span>: <span class="literal">false</span>&#125;,</span><br><span class="line">            legend: &#123;<span class="attr">show</span>: <span class="literal">false</span>&#125;,</span><br><span class="line">            xAxis: &#123;</span><br><span class="line">                data: [<span class="string">&#x27;芙蓉新区&#x27;</span>, <span class="string">&#x27;芙蓉新区&#x27;</span>, <span class="string">&#x27;芙蓉新区&#x27;</span>, <span class="string">&#x27;芙蓉新区&#x27;</span>, <span class="string">&#x27;芙蓉新区&#x27;</span>, <span class="string">&#x27;芙蓉新区&#x27;</span>, <span class="string">&#x27;芙蓉新区&#x27;</span>, <span class="string">&#x27;芙蓉新区&#x27;</span>, <span class="string">&#x27;芙蓉新区&#x27;</span>],</span><br><span class="line">                axisTick: &#123;<span class="attr">show</span>: <span class="literal">false</span>&#125;,</span><br><span class="line">                axisLine: &#123;</span><br><span class="line">                    lineStyle: &#123;<span class="attr">color</span>: <span class="string">&#x27;#083B70&#x27;</span>&#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                axisLabel: &#123;</span><br><span class="line">                    fontSize: px(<span class="number">12</span>),</span><br><span class="line">                    <span class="function"><span class="title">formatter</span>(<span class="params">val</span>)</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (val.length &gt; <span class="number">2</span>) &#123;</span><br><span class="line">                            <span class="keyword">const</span> array = val.split(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">                            array.splice(<span class="number">2</span>, <span class="number">0</span>, <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">                            <span class="keyword">return</span> array.join(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">return</span> val;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">            &#125;,</span><br><span class="line">            grid: &#123;</span><br><span class="line">                x: px(<span class="number">40</span>),</span><br><span class="line">                y: px(<span class="number">40</span>),</span><br><span class="line">                x2: px(<span class="number">40</span>),</span><br><span class="line">                y2: px(<span class="number">40</span>),</span><br><span class="line">            &#125;,</span><br><span class="line">            yAxis: &#123;</span><br><span class="line">                splitLine: &#123;<span class="attr">show</span>: <span class="literal">false</span>&#125;,</span><br><span class="line">                axisLine: &#123;</span><br><span class="line">                    show: <span class="literal">true</span>,</span><br><span class="line">                    lineStyle: &#123;<span class="attr">color</span>: <span class="string">&#x27;#083B70&#x27;</span>&#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                axisLabel: &#123;</span><br><span class="line">                    fontSize: px(<span class="number">12</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            series: [&#123;</span><br><span class="line">                <span class="keyword">type</span>: <span class="string">&#x27;bar&#x27;</span>,</span><br><span class="line">                data: [<span class="number">10</span>, <span class="number">20</span>, <span class="number">36</span>, <span class="number">41</span>, <span class="number">15</span>, <span class="number">26</span>, <span class="number">37</span>, <span class="number">18</span>, <span class="number">29</span>]</span><br><span class="line">            &#125;]</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;, []);</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;div className=<span class="string">&quot;home&quot;</span>&gt;</span><br><span class="line">            &lt;header style=&#123;&#123;<span class="attr">backgroundImage</span>: <span class="string">`url(<span class="subst">$&#123;headerBg&#125;</span>)`</span>&#125;&#125;&gt;&lt;/header&gt;</span><br><span class="line">            &lt;main&gt;</span><br><span class="line">                &lt;section className=<span class="string">&quot;section1&quot;</span>&gt;</span><br><span class="line">                    &lt;div className=<span class="string">&quot;bordered 管辖统计&quot;</span>&gt;</span><br><span class="line">                        &lt;h2&gt;案发派出所管辖统计&lt;/h2&gt;</span><br><span class="line">                        &lt;div ref=&#123;divRef&#125; className=<span class="string">&quot;chart&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">                        &lt;/div&gt;</span><br><span class="line">                    &lt;/div&gt;</span><br><span class="line">                &lt;/section&gt;</span><br><span class="line">                &lt;section className=<span class="string">&quot;section2 bordered&quot;</span>&gt;&lt;/section&gt;</span><br><span class="line">                &lt;section className=<span class="string">&quot;section3 bordered&quot;</span>&gt;&lt;/section&gt;</span><br><span class="line">                &lt;section className=<span class="string">&quot;section4 bordered&quot;</span>&gt;&lt;/section&gt;</span><br><span class="line">                &lt;section className=<span class="string">&quot;section5 bordered&quot;</span>&gt;&lt;/section&gt;</span><br><span class="line">            &lt;/main&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    );</span><br></pre></td></tr></table></figure><h4 id="重构和封装"><a href="#重构和封装" class="headerlink" title="重构和封装"></a>重构和封装</h4><p>因图表的文字样式、x轴、y轴等配置需要统一，所以将Echarts的配置进行了一次封装，同时还封装了尺寸换算的函数</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// px.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> px = <span class="function">(<span class="params">n</span>) =&gt;</span> n / <span class="number">2420</span> * (<span class="built_in">window</span> <span class="keyword">as</span> <span class="built_in">any</span>).pageWidth;</span><br></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// base-echart-options.ts</span></span><br><span class="line"><span class="comment">// 基础的Echart配置，包括文字样式，间隔，不显示标题等</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123;px&#125; <span class="keyword">from</span> <span class="string">&#x27;./px&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> baseEchartOptions = &#123;</span><br><span class="line"></span><br><span class="line">    textStyle: &#123;</span><br><span class="line">        fontSize: px(<span class="number">12</span>),</span><br><span class="line">        color: <span class="string">&#x27;#79839E&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    title: &#123;<span class="attr">show</span>: <span class="literal">false</span>&#125;,</span><br><span class="line">    legend: &#123;<span class="attr">show</span>: <span class="literal">false</span>&#125;,</span><br><span class="line">    grid: &#123;</span><br><span class="line">        x: px(<span class="number">20</span>),</span><br><span class="line">        y: px(<span class="number">20</span>),</span><br><span class="line">        x2: px(<span class="number">20</span>),</span><br><span class="line">        y2: px(<span class="number">20</span>),</span><br><span class="line">        containLabel: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// create-echarts-options.ts</span></span><br><span class="line"><span class="comment">// 初始化Echart的函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123;baseEchartOptions&#125; <span class="keyword">from</span> <span class="string">&#x27;./base-echart-options&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;px&#125; <span class="keyword">from</span> <span class="string">&#x27;./px&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> createEchartsOptions = <span class="function">(<span class="params">options</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> result = &#123;</span><br><span class="line">        ...baseEchartOptions,</span><br><span class="line">        ...options,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 如果有x轴或y轴，则统一设置x轴y轴的字体大小</span></span><br><span class="line">    <span class="keyword">if</span> (!(options?.xAxis?.axisLabel?.fontSize)) &#123;</span><br><span class="line">        result.xAxis = result.xAxis || &#123;&#125;;</span><br><span class="line">        result.xAxis.axisLabel = result.xAxis.axisLabel || &#123;&#125;;</span><br><span class="line">        result.xAxis.axisLabel.fontSize = px(<span class="number">12</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!(options?.yAxis?.axisLabel?.fontSize)) &#123;</span><br><span class="line">        result.yAxis = result.yAxis || &#123;&#125;;</span><br><span class="line">        result.yAxis.axisLabel = result.yAxis.axisLabel || &#123;&#125;;</span><br><span class="line">        result.yAxis.axisLabel.fontSize = px(<span class="number">12</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>重构后的chart1</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123;useEffect, useRef&#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> echarts <span class="keyword">from</span> <span class="string">&#x27;echarts&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;px&#125; <span class="keyword">from</span> <span class="string">&#x27;../shared/px&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;baseEchartOptions&#125; <span class="keyword">from</span> <span class="string">&#x27;../shared/base-echart-options&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;createEchartsOptions&#125; <span class="keyword">from</span> <span class="string">&#x27;../shared/create-echarts-options&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> Chart1 = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> divRef = useRef(<span class="literal">null</span>);</span><br><span class="line">    useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> myChart = echarts.init(divRef.current);</span><br><span class="line">        myChart.setOption(createEchartsOptions(&#123;</span><br><span class="line">            xAxis: &#123;</span><br><span class="line">                data: [<span class="string">&#x27;芙蓉新区&#x27;</span>, <span class="string">&#x27;芙蓉新区&#x27;</span>, <span class="string">&#x27;芙蓉新区&#x27;</span>, <span class="string">&#x27;芙蓉新区&#x27;</span>, <span class="string">&#x27;芙蓉新区&#x27;</span>, <span class="string">&#x27;芙蓉新区&#x27;</span>, <span class="string">&#x27;芙蓉新区&#x27;</span>, <span class="string">&#x27;芙蓉新区&#x27;</span>, <span class="string">&#x27;芙蓉新区&#x27;</span>],</span><br><span class="line">                axisTick: &#123;<span class="attr">show</span>: <span class="literal">false</span>&#125;,</span><br><span class="line">                axisLine: &#123;</span><br><span class="line">                    lineStyle: &#123;<span class="attr">color</span>: <span class="string">&#x27;#083B70&#x27;</span>&#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                axisLabel: &#123;</span><br><span class="line">                    <span class="function"><span class="title">formatter</span>(<span class="params">val</span>)</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (val.length &gt; <span class="number">2</span>) &#123;</span><br><span class="line">                            <span class="keyword">const</span> array = val.split(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">                            array.splice(<span class="number">2</span>, <span class="number">0</span>, <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">                            <span class="keyword">return</span> array.join(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">return</span> val;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">            &#125;,</span><br><span class="line">            yAxis: &#123;</span><br><span class="line">                splitLine: &#123;<span class="attr">show</span>: <span class="literal">false</span>&#125;,</span><br><span class="line">                axisLine: &#123;</span><br><span class="line">                    show: <span class="literal">true</span>,</span><br><span class="line">                    lineStyle: &#123;<span class="attr">color</span>: <span class="string">&#x27;#083B70&#x27;</span>&#125;</span><br><span class="line">                &#125;,</span><br><span class="line">            &#125;,</span><br><span class="line">            series: [&#123;</span><br><span class="line">                <span class="keyword">type</span>: <span class="string">&#x27;bar&#x27;</span>,</span><br><span class="line">                data: [<span class="number">10</span>, <span class="number">20</span>, <span class="number">36</span>, <span class="number">41</span>, <span class="number">15</span>, <span class="number">26</span>, <span class="number">37</span>, <span class="number">18</span>, <span class="number">29</span>]</span><br><span class="line">            &#125;]</span><br><span class="line">        &#125;));</span><br><span class="line">    &#125;, []);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;div className=<span class="string">&quot;bordered 管辖统计&quot;</span>&gt;</span><br><span class="line">            &lt;h2&gt;案发派出所管辖统计&lt;/h2&gt;</span><br><span class="line">            &lt;div ref=&#123;divRef&#125; className=<span class="string">&quot;chart&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Echarts </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 可视化 </tag>
            
            <tag> Echarts </tag>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VueCli3使用 Vue-Test-Utils + Karma / Chrome进行单元测试</title>
      <link href="2021/04/07/Vue-vue-test-utils/"/>
      <url>2021/04/07/Vue-vue-test-utils/</url>
      
        <content type="html"><![CDATA[<p>在<code>vue2</code>造UI轮子的项目中，因为<code>parcel</code>编译样式时速度有点慢，因此将其迁移到了<code>vue-cli3</code>，同时使用<code>Vue-Test-Utils</code>结合<code>Karma</code>对单元测试框架进行了升级。</p><h2 id="Vue-Test-Utils"><a href="#Vue-Test-Utils" class="headerlink" title="Vue-Test-Utils"></a>Vue-Test-Utils</h2><p><code>Vue Test Utils</code> 是 Vue.js 官方的单元测试实用工具库。</p><p><a href="https://vue-test-utils.vuejs.org/zh/guides/#%E8%B5%B7%E6%AD%A5">官方文档</a></p><p>首先尝试用Mocha+webpack编写单元测试，依然是使用Chai断言库。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在根目录新建tests/units目录，将原有的测试文件改为**.spec.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> chai, &#123;expect&#125; <span class="keyword">from</span> <span class="string">&#x27;chai&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123;shallowMount, mount&#125; <span class="keyword">from</span> <span class="string">&#x27;@vue/test-utils&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Button <span class="keyword">from</span> <span class="string">&#x27;@/components/button&#x27;</span></span><br><span class="line"></span><br><span class="line">describe(<span class="string">&#x27;Button&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    it(<span class="string">&#x27;可以设置icon.&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> wrapper = mount(Button, &#123;</span><br><span class="line">      propsData: &#123;</span><br><span class="line">        icon: <span class="string">&#x27;settings&#x27;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">const</span> useElement = wrapper.find(<span class="string">&#x27;use&#x27;</span>)</span><br><span class="line">    expect(useElement.attributes()[<span class="string">&#x27;href&#x27;</span>]).to.equal(<span class="string">&#x27;#x-settings&#x27;</span>)</span><br><span class="line">    wrapper.destroy()</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="mount-V-S-shallowMount"><a href="#mount-V-S-shallowMount" class="headerlink" title="mount V.S. shallowMount"></a>mount V.S. shallowMount</h3><h4 id="mount"><a href="#mount" class="headerlink" title="mount()"></a>mount()</h4><ul><li><p><strong>参数：</strong></p><ul><li><code>&#123;Component&#125; component</code></li><li><code>&#123;Object&#125; options</code></li></ul></li><li><p><strong>返回值：</strong> <code>&#123;Wrapper&#125;</code></p></li><li><p><strong>选项：</strong>移步<a href="https://vue-test-utils.vuejs.org/zh/api/options.html">选项</a>，常用的有<code>propsData</code>,<code>slots</code>,<code>attachTo</code></p></li><li><p><strong>用法：</strong>创建一个包含被挂载和渲染的 Vue 组件的 <a href="https://vue-test-utils.vuejs.org/zh/api/wrapper/"><code>Wrapper</code></a>。</p></li></ul><h4 id="shallowMount"><a href="#shallowMount" class="headerlink" title="shallowMount()"></a>shallowMount()</h4><p>用法和 <code>mount</code> 一样，创建一个包含被挂载和渲染的 Vue 组件的 <code>Wrapper</code>，不同的是被存根的子组件。</p><h4 id="mount-和shallowMount-的区别"><a href="#mount-和shallowMount-的区别" class="headerlink" title="mount()和shallowMount()的区别"></a>mount()和shallowMount()的区别</h4><ul><li>参考这篇<a href="https://github.com/holylovelqq/vue-unit-test-with-jest/issues/4">笔记</a></li><li><code>mount()</code>会将测试组件中使用到的子子孙孙组件完全渲染，而<code>shallowMount()</code>不会</li><li>为保证测试速度，能用<code>shallowMount()</code>的地方都尽量用<code>mount()</code></li></ul><h2 id="为什么要使用Karma"><a href="#为什么要使用Karma" class="headerlink" title="为什么要使用Karma"></a>为什么要使用Karma</h2><p>将原来<code>button.spec.js</code> 测试用例复制过来后，发现涉及到了样式的测试都未通过</p><p><img src="/images/vue/test-error1.png"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 样式相关的测试用例</span></span><br><span class="line">it(<span class="string">&#x27;icon 默认的 order 是 1&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> wrapper = mount(Button, &#123;</span><br><span class="line">    propsData: &#123;</span><br><span class="line">      icon: <span class="string">&#x27;setting&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> vm = wrapper.vm</span><br><span class="line">  <span class="keyword">const</span> icon = vm.$el.querySelector(<span class="string">&#x27;svg&#x27;</span>)</span><br><span class="line">  expect(getComputedStyle(icon).order).to.eq(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>原因是这个测试框架是运行在node.js里，而非运行在浏览器，所以没有DOM，无法得到元素的样式。</p><p>官方文档中提到<code>attachTo:htmlELement</code>可以将元素设置到DOM中，然而添加后测试依然不通过。</p><p>因此，为了解决这个问题，需要使用<code>Krama</code><strong>启动浏览器</strong>运行测试。</p><h3 id="配置方法"><a href="#配置方法" class="headerlink" title="配置方法"></a>配置方法</h3><h4 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -D karma karma-chrome-launcher karma-mocha karma-sourcemap-loader karma-spec-reporter karma-webpack chai sinon sinon-chai</span><br></pre></td></tr></table></figure><h4 id="创建karma-conf-js"><a href="#创建karma-conf-js" class="headerlink" title="创建karma.conf.js"></a>创建karma.conf.js</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// karma.conf.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> webpackConfig = <span class="built_in">require</span>(<span class="string">&#x27;./webpack.config.js&#x27;</span>)</span><br><span class="line"><span class="comment">// var webpackConfig = require(&#x27;@vue/cli-service/webpack.config.js&#x27;) // 如果没有配置webpack.config.js</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">config</span>) </span>&#123;</span><br><span class="line">  config.set(&#123;</span><br><span class="line">    frameworks: [<span class="string">&#x27;mocha&#x27;</span>],</span><br><span class="line"></span><br><span class="line">    files: [<span class="string">&#x27;test/**/*.spec.js&#x27;</span>],</span><br><span class="line"></span><br><span class="line">    preprocessors: &#123;</span><br><span class="line">      <span class="string">&#x27;**/*.spec.js&#x27;</span>: [<span class="string">&#x27;webpack&#x27;</span>, <span class="string">&#x27;sourcemap&#x27;</span>]</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    webpack: webpackConfig,</span><br><span class="line"></span><br><span class="line">    reporters: [<span class="string">&#x27;spec&#x27;</span>],</span><br><span class="line">    autoWatch: <span class="literal">true</span>,</span><br><span class="line">    browsers: [<span class="string">&#x27;ChromeHeadless&#x27;</span>]</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="配置package-json"><a href="#配置package-json" class="headerlink" title="配置package.json"></a>配置package.json</h4><p>在 <code>package.json</code> 定义测试脚本</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">   <span class="string">&quot;test&quot;</span>: <span class="string">&quot;karma start --single-run&quot;</span>, <span class="comment">// 运行一次</span></span><br><span class="line">   <span class="string">&quot;test:unit&quot;</span>: <span class="string">&quot;karma start&quot;</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="编写测试用例"><a href="#编写测试用例" class="headerlink" title="编写测试用例"></a>编写测试用例</h3><p>添加karma后，将样式相关的测试用例重新编写，举个栗子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">it(<span class="string">&#x27;icon 默认的 order 是 1&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> div = <span class="built_in">document</span>.createElement(<span class="string">&#x27;div&#x27;</span>)</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(div)</span><br><span class="line">  <span class="keyword">const</span> wrapper = mount(Button, &#123;</span><br><span class="line">    attachTo: div,</span><br><span class="line">    propsData: &#123;</span><br><span class="line">      icon: <span class="string">&#x27;settings&#x27;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">const</span> vm = wrapper.vm</span><br><span class="line">  <span class="keyword">const</span> icon = vm.$el.querySelector(<span class="string">&#x27;svg&#x27;</span>)</span><br><span class="line">  expect(getComputedStyle(icon).order).to.eq(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">  div.remove()</span><br><span class="line">  wrapper.destroy()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><img src="/images/vue/test-s.png" alt="测试通过啦"></p>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
          <category> Vue2 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> Vue2 </tag>
            
            <tag> 造轮子 </tag>
            
            <tag> 单元测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue小技巧之属性、事件传递：v-bind=&quot;$props&quot;，v-bind=&quot;$attrs&quot;，v-on=&quot;$listeners&quot;</title>
      <link href="2021/04/02/Vue-v-bind-props/"/>
      <url>2021/04/02/Vue-v-bind-props/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>今天接手了另一位同事的代码改一个需求时，发现这个需求涉及到的组件层层嵌套，<code>props</code>也得层层传递，如图所示：</p><p><img src="/images/vue/props%E7%A9%BF%E9%80%8F.png"></p><p>从A组件传递的<code>props</code>需要分别传递到第二第三层组件中使用。如果我改这个需求得添加一个属性，就意味着我需要在ABCDE…这几个组件调用的地方分别加上这个属性。想想就非常不优雅：不仅费时，也不利于以后的拓展和维护。那么有什么方法可以优化呢？</p><p>正好前段时间写Vue3UI轮子button组件的时候，用到了<code>v-bind=&quot;$attrs&quot;</code>来将属性和事件绑定给子组件。于是进行了一番探索(搜博客+查阅文档)，发现<code>vue2</code>中也有类似的操作，分别是通过<code>v-bind=&quot;$props&quot;</code>,<code>v-bind=&quot;$attrs&quot;</code>传递属性，通过<code>v-on=&quot;$listeners&quot;</code>传递事件。</p><h2 id="使用介绍"><a href="#使用介绍" class="headerlink" title="使用介绍"></a>使用介绍</h2><h3 id="v-bind-”-props”"><a href="#v-bind-”-props”" class="headerlink" title="v-bind=”$props”"></a>v-bind=”$props”</h3><ul><li><p><code>vm.$props</code>: 当前组件接收到的 props 对象。Vue 实例代理了对其 props 对象属性的访问</p></li><li><p><code>v-bind=&quot;$props&quot;</code>将父组件的所有props向下传递给它的子组件,子组件需要在其props:{} 中定义要接受的props</p></li></ul><h3 id="v-bind-”-attrs”"><a href="#v-bind-”-attrs”" class="headerlink" title="v-bind=”$attrs”"></a>v-bind=”$attrs”</h3><ul><li><code>vm.$attrs</code> :包含了父作用域中不作为 prop 被识别 (且获取) 的特性绑定 (class 和 style 除外)。当一个组件没有声明任何 prop 时，这里会包含所有父作用域的绑定 (class 和 style 除外)</li><li><code>v-bind=&quot;$attrs&quot;</code>： 将调用组件时，组件标签上绑定的非props特性(class和style除外)向下传递</li></ul><h3 id="v-on-”-listeners”"><a href="#v-on-”-listeners”" class="headerlink" title="v-on=”$listeners”"></a>v-on=”$listeners”</h3><ul><li><code>vm.$listeners</code>: 包含了父作用域中的 (不含 .native 修饰器的) v-on 事件监听器。它可以通过 v-on=”$listeners” 传入内部组件</li><li><code>v-on=&quot;$listeners&quot;</code>：将父组件标签上的自定义事件向下传递,其子组件可以直接通过this.$emit(eventName)的方式调用</li></ul><p><strong>注：<code>Vue3</code>中移除了<code>$listeners</code>，而将事件存在了<code>vm.$attrs</code>中</strong></p><h2 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h2><ul><li><p>index.vue</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;Parent test=<span class="string">&quot;非props属性&quot;</span> :name=<span class="string">&quot;name&quot;</span> :age=<span class="string">&quot;age&quot;</span> v-on:start1=<span class="string">&quot;fn1&quot;</span> @start2=<span class="string">&quot;fn2&quot;</span>&gt;</span><br><span class="line">    &lt;/Parent&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">  </span><br><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">import</span> Parent <span class="keyword">from</span> <span class="string">&#x27;./parent.vue&#x27;</span>;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    components: &#123;</span><br><span class="line">      Parent</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">          name: <span class="string">&#x27;爷爷给爸爸的值&#x27;</span>,</span><br><span class="line">          age: <span class="string">&#x27;18&#x27;</span></span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        <span class="function"><span class="title">fn1</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;这是从爷爷传来的方法1&#x27;</span>);</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="function"><span class="title">fn2</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;这是从爷爷传来的方法2&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li><li><p>parent.vue</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">      &lt;h3&gt;父组件&lt;/h3&gt;</span><br><span class="line">      &lt;div&gt;非props属性($attrs): &#123;&#123;$attrs&#125;&#125;&lt;/div&gt;</span><br><span class="line">      &lt;child v-on=<span class="string">&quot;$listeners&quot;</span> v-bind=<span class="string">&quot;$props&quot;</span>&gt;&lt;/child&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">  </span><br><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">import</span> Child <span class="keyword">from</span> <span class="string">&#x27;./child.vue&#x27;</span>;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    inheritAttrs: <span class="literal">false</span>,</span><br><span class="line">    components: &#123;</span><br><span class="line">      Child</span><br><span class="line">    &#125;,</span><br><span class="line">    props: [<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;age&#x27;</span>],</span><br><span class="line">    <span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span> &#123; </span><br><span class="line">        <span class="built_in">this</span>.$emit(<span class="string">&#x27;start1&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li><li><p>child.vue</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">      &lt;h3&gt;子组件&lt;/h3&gt;</span><br><span class="line">      &lt;div&gt;爸爸传递过来的name: &#123;&#123;name&#125;&#125;&lt;/div&gt;</span><br><span class="line">      &lt;div&gt;爸爸传递过来的age: &#123;&#123;age&#125;&#125;&lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">  </span><br><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    props: [<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;age&#x27;</span>],</span><br><span class="line">    <span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.$emit(<span class="string">&#x27;start2&#x27;</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.$listeners, <span class="string">&#x27;儿子的事件&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li></ul><p>效果如下：</p><p><img src="/images/vue/props%E7%A9%BF%E9%80%8F1.png"></p><p><img src="/images/vue/props%E7%A9%BF%E9%80%8F2.png"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/6844903848050589704#heading-4">https://juejin.cn/post/6844903848050589704#heading-4</a></p><p><a href="https://cn.vuejs.org/v2/api/#v-on">https://cn.vuejs.org/v2/api/?#v-on</a></p>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>node学习记录（2）-文件模块-制作一个使用命令行操作的todo list</title>
      <link href="2021/03/31/node-notes-2-fs/"/>
      <url>2021/03/31/node-notes-2-fs/</url>
      
        <content type="html"><![CDATA[<blockquote><p>源码链接：<a href="https://github.com/wuyangqin/node-todo-list">https://github.com/wuyangqin/node-todo-list</a></p></blockquote><p>使用node的<code>fs</code>文件模块实现了一个简单的用命令行操作的todo list</p><h2 id="技术细节"><a href="#技术细节" class="headerlink" title="技术细节"></a>技术细节</h2><ul><li>使用node.js <code>fs</code>模块实现文件读写</li><li>使用<code>commander.js</code>编写命令行命令</li><li>使用<code>inquirer.js</code> 实现用户与命令行的交互 </li><li>使用<code>jest.js</code> 模拟fs，编写单元测试</li></ul><h2 id="效果演示"><a href="#效果演示" class="headerlink" title="效果演示"></a>效果演示</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g node-todo-xx</span><br></pre></td></tr></table></figure><p>or</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn global add node-todo-xx</span><br></pre></td></tr></table></figure><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">todo <span class="comment"># 查看所有任务列表,能够操作任务增删改查</span></span><br><span class="line">todo add 任务名 <span class="comment"># 添加一个任务</span></span><br><span class="line">todo clear <span class="comment"># 清空所有任务</span></span><br></pre></td></tr></table></figure><p><strong>todo 查看任务列表</strong></p><p><img src="/images/node-notes/fs-todo.png" alt="查看任务列表"></p><p><img src="/images/node-notes/fs-todo-onetask.png" alt="对某项任务进行操作"></p><p><strong>todo add 添加任务</strong></p><p><img src="/images/node-notes/fs-todo-add.png" alt="添加任务"></p><p><strong>todo clear 清除任务</strong></p><p><img src="/images/node-notes/fs-todo-clear.png" alt="添加任务"></p><h2 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h2><h3 id="逻辑梳理"><a href="#逻辑梳理" class="headerlink" title="逻辑梳理"></a>逻辑梳理</h3><p>该项目的实现逻辑如图所示：</p><p><img src="/images/node-notes/todo-logic.png"></p><h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">├── __mocks__</span><br><span class="line">|  └── fs.js  <span class="comment"># 模拟fs模块</span></span><br><span class="line">├── __test__  <span class="comment"># 存放测试文件</span></span><br><span class="line">|  └── db.test.js</span><br><span class="line">├── cli.js <span class="comment"># 命令行操作逻辑</span></span><br><span class="line">├── db.js <span class="comment"># 读写任务的函数</span></span><br><span class="line">└── index.js <span class="comment"># 任务的操作逻辑</span></span><br></pre></td></tr></table></figure><h3 id="读写文件"><a href="#读写文件" class="headerlink" title="读写文件"></a>读写文件</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> os = <span class="built_in">require</span>(<span class="string">&#x27;os&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> homedir = os.homedir(); <span class="comment">// 获取home目录</span></span><br><span class="line"><span class="keyword">const</span> home = process.env.HOME || homedir; <span class="comment">// 如果用户自己设置了HOME的环境变量</span></span><br><span class="line"><span class="keyword">const</span> dbPath = path.join(home,<span class="string">&#x27;.todo&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> db = &#123;</span><br><span class="line">  <span class="function"><span class="title">read</span>(<span class="params">path = dbPath</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// &#x27;a+&#x27;: Open file for reading and appending. The file is created if it does not exist.</span></span><br><span class="line">      fs.readFile(path,&#123; <span class="attr">flag</span>: <span class="string">&#x27;a+&#x27;</span>&#125;, <span class="function">(<span class="params">readError,data</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (readError) <span class="keyword">return</span> reject(readError)</span><br><span class="line">        <span class="keyword">let</span> list</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          list = <span class="built_in">JSON</span>.parse(data.toString())</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">          list = []</span><br><span class="line">        &#125;</span><br><span class="line">        resolve(list)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">write</span>(<span class="params">list, path = dbPath</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> string = <span class="built_in">JSON</span>.stringify(list)</span><br><span class="line">      fs.writeFile(path,string + <span class="string">&#x27;\n&#x27;</span>,<span class="function">(<span class="params">writeError</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(writeError) <span class="keyword">return</span> reject(writeError)</span><br><span class="line">        resolve()</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports  = db</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><h4 id="测试命令"><a href="#测试命令" class="headerlink" title="测试命令"></a>测试命令</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn <span class="built_in">test</span></span><br></pre></td></tr></table></figure><h4 id="fs-mock"><a href="#fs-mock" class="headerlink" title="fs mock"></a>fs mock</h4><p>从上面的逻辑梳理图可以看到，这个项目最主要的就是对任务文件进行操作的两个函数，因此将围绕这两个函数进行单元测试的编写。</p><p>然而编写单元测试有一条原则就是，<strong>测试代码不要与外界进行交互</strong>，比如如果我通过测试代码读取用户硬盘上的某个文件，而这个文件路径刚好在用户硬盘中存在，这就很尴尬啦。因此<code>jest</code>提供了对node模块进行<code>mock</code>的功能——相当于对node的模块进行接管，调用我们自己编写的方法。具体实现如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在项目根目录创建&#x27;__mock__&#x27;文件夹, 并创建&#x27;fs.js&#x27;文件 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fs = jest.genMockFromModule(<span class="string">&#x27;fs&#x27;</span>) <span class="comment">// 创建模拟的fs模块</span></span><br><span class="line"><span class="keyword">const</span> _fs = jest.requireActual(<span class="string">&#x27;fs&#x27;</span>) <span class="comment">// 引入实际的fs模块</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.assign(fs, _fs) <span class="comment">// 将原fs模块的属性复制给我们创建的模拟fs模块</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> readMocks = &#123;&#125;</span><br><span class="line">fs.setReadFileMock = <span class="function">(<span class="params">path, error, data</span>) =&gt;</span> &#123;</span><br><span class="line">  readMocks[path] = [error, data]</span><br><span class="line">&#125;</span><br><span class="line">fs.readFile = <span class="function">(<span class="params">path,options,callback</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (callback === <span class="literal">undefined</span>) callback = options</span><br><span class="line">  <span class="keyword">if</span> (path <span class="keyword">in</span> readMocks) &#123;</span><br><span class="line">    callback(...readMocks[path])</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    _fs.readFile(path, options, callback)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> writeMocks = &#123;&#125;</span><br><span class="line">fs.setWriteFileMock = <span class="function">(<span class="params">path, fn</span>) =&gt;</span> &#123;</span><br><span class="line">  writeMocks[path] = fn</span><br><span class="line">&#125;</span><br><span class="line">fs.writeFile  = <span class="function">(<span class="params">path, data, options, callback</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (callback === <span class="literal">undefined</span>) callback = options</span><br><span class="line">  <span class="keyword">if</span> (path <span class="keyword">in</span> writeMocks) &#123;</span><br><span class="line">    writeMocks[path](path, data, options, callback)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    _fs.writeFile(path, data, options, callback)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fs.clearMocks = <span class="function">() =&gt;</span> &#123; <span class="comment">// 清除mock</span></span><br><span class="line">  readMocks = &#123;&#125;</span><br><span class="line">  writeMocks = &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = fs</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// __test__文件夹用来存放测试文件，在&#x27;db.spec.js&#x27;中编写读写文件两个函数的测试代码</span></span><br><span class="line"><span class="keyword">const</span> db = <span class="built_in">require</span>(<span class="string">&#x27;../db.js&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line">jest.mock(<span class="string">&#x27;fs&#x27;</span>) <span class="comment">// jest将fs接管</span></span><br><span class="line"></span><br><span class="line">describe(<span class="string">&#x27;db&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  afterEach(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    fs.clearMocks()</span><br><span class="line">  &#125;)</span><br><span class="line">  </span><br><span class="line">  it (<span class="string">&#x27;can read&#x27;</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> data = [&#123;<span class="attr">title</span>: <span class="string">&#x27;hi&#x27;</span>, <span class="attr">done</span>: <span class="literal">false</span>&#125;]</span><br><span class="line">    fs.setReadFileMock(<span class="string">&#x27;/test&#x27;</span>,<span class="literal">null</span>, <span class="built_in">JSON</span>.stringify(data))</span><br><span class="line">    <span class="keyword">const</span> list = <span class="keyword">await</span> db.read(<span class="string">&#x27;/test&#x27;</span>)</span><br><span class="line">    expect(list).toStrictEqual(data)</span><br><span class="line">  &#125;)</span><br><span class="line">  </span><br><span class="line">  it (<span class="string">&#x27;can write&#x27;</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> fakeFile</span><br><span class="line">    fs.setWriteFileMock(<span class="string">&#x27;/test1&#x27;</span>, <span class="function">(<span class="params">path, data, callback</span>) =&gt;</span> &#123;</span><br><span class="line">      fakeFile = data</span><br><span class="line">      callback(<span class="literal">null</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">const</span> list = [&#123;<span class="attr">title</span>: <span class="string">&#x27;hi&#x27;</span>, <span class="attr">done</span>: <span class="literal">false</span>&#125;]</span><br><span class="line">    <span class="keyword">await</span> db.write(list,<span class="string">&#x27;/test1&#x27;</span>)</span><br><span class="line">    expect(fakeFile).toBe(<span class="built_in">JSON</span>.stringify(list) + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>node学习记录（1）-node初识</title>
      <link href="2021/03/24/node-notes-1-intro/"/>
      <url>2021/03/24/node-notes-1-intro/</url>
      
        <content type="html"><![CDATA[<h2 id="Node-简介"><a href="#Node-简介" class="headerlink" title="Node 简介"></a>Node 简介</h2><h3 id="node-js-不是什么"><a href="#node-js-不是什么" class="headerlink" title="node.js 不是什么"></a>node.js 不是什么</h3><ul><li>不是web后端框架</li><li>不是编程语言</li></ul><h3 id="node-js是什么"><a href="#node-js是什么" class="headerlink" title="node.js是什么"></a>node.js是什么</h3><ul><li>将多种技术组合起来</li><li>让JavaScript也能调用系统接口、开发后端应用</li></ul><h3 id="用到了哪些技术"><a href="#用到了哪些技术" class="headerlink" title="用到了哪些技术"></a>用到了哪些技术</h3><ul><li>V8引擎</li><li>libuv</li><li>C/C++实现的 c-ares(实现DNS 域名的解析)，http-parser(解析http)，OpenSSL(https)，zlib(加密)等库</li></ul><h3 id="Node特点"><a href="#Node特点" class="headerlink" title="Node特点"></a>Node特点</h3><p><strong>单线程</strong></p><ul><li>进程就是一个一个的工作计划（工厂中的车间）</li><li>线程是计算机最小的运算单位（工厂中的工人），线程是干活的</li><li>传统的服务器是多线程的，每进来一个请求，就创建一个线程去处理请求</li><li>Node.js的服务器是单线程的，在后台拥有一个I/O线程池</li></ul><p><strong>非阻塞 I/O</strong></p><ul><li><p>I/O：对磁盘的读写操作( Input/ Output)</p></li><li><p>非阻塞：不会等I/O语句结束，而会执行后面的语句（异步）</p><p>异步：调用者发起一个异步调用，然后立即返回去做别的事。“被调用者”通过状态、通知、回调函数等手段来通知“调用者”。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line">fs.readFile(<span class="string">&#x27;/app.js&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err,file</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;我读完文件了！);</span></span><br><span class="line"><span class="string">&#125;)</span></span><br><span class="line"><span class="string">console.log(&#x27;</span>我不会被阻塞！<span class="string">&#x27;)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">//我不会被阻塞是在我读完文件了之前输出 =&gt;异步调用</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">//机制:进行I/O操作，给readFile绑定一个回调函数function(err,file)&#123;&#125;,并在读取textfile完成后执行回调函数。期间，后面的代码继续执行，不受I/O阻塞</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>事件驱动</strong></p><h2 id="Node-js技术架构"><a href="#Node-js技术架构" class="headerlink" title="Node.js技术架构"></a>Node.js技术架构</h2><p><img src="/images/node-notes/node-struct.png" alt="Node.js技术架构"></p><p>stream模块</p><ul><li>第一层 可以用js直接调用的api</li></ul><h4 id="bingdings-让JS和C-C-通信"><a href="#bingdings-让JS和C-C-通信" class="headerlink" title="bingdings 让JS和C/C++通信"></a>bingdings 让JS和C/C++通信</h4><p>举例：</p><ul><li>C/C++实现了一个http_parser库，但不能用JS直接调用这个库，于是需要一个中间的销量</li><li>Node.js用C++对该库进行封装，并用其提供的编译工具将该库编译为.node文件</li><li>js代码可以直接require这个.node文件</li><li>实现js调用C++库，中间的桥梁–binding</li><li>Node.js提供了很多binding – bindings</li></ul><h4 id="V8-JS引擎"><a href="#V8-JS引擎" class="headerlink" title="V8 JS引擎"></a>V8 JS引擎</h4><ul><li>功能<ul><li>将JS源代码变成本地代码并执行</li><li>维护调用栈，确保JS函数的执行顺序</li><li>内存管理，为所有对象分配内存</li><li>垃圾回收，重复利用无用的内存</li><li>实现JS的标准库</li></ul></li><li>注意<ul><li>V8不提供 DOM API</li><li>本身是多线程，如垃圾回收是单独线程，但执行JS是单线程的</li><li>可以开启两个线程分别执行JS</li><li>自带event loop，但Node.js基于liuv自己做了一个</li></ul></li></ul><h4 id="libuv"><a href="#libuv" class="headerlink" title="libuv"></a>libuv</h4><ul><li>一个跨平台的异步I/O库，会根据系统自动选择合适的方案</li><li>I/O:对磁盘的读写操作( Input/ Output)</li><li>功能：可以用于 TCP/UDP/DNS/文件 等的异步操作<ul><li>TCP：http是基于TCPIP，能操作TCP就能做服务器</li><li>UDP：一般用于网页聊天</li><li>DNS：域名</li></ul></li></ul><h3 id="Event-Loop"><a href="#Event-Loop" class="headerlink" title="Event Loop"></a>Event Loop</h3><h4 id="什么是loop"><a href="#什么是loop" class="headerlink" title="什么是loop"></a>什么是loop</h4><ul><li>loop就是循环</li><li>由于事件是分优先级的，所以处理起来也是分先后的</li><li>node.js需要按顺序轮询每种事件</li><li>这种轮询往往是循环的</li></ul><h4 id="Event-Loop-1"><a href="#Event-Loop-1" class="headerlink" title="Event Loop"></a>Event Loop</h4><ul><li>对事件处理顺序的管理</li></ul><h4 id="顺序示意图"><a href="#顺序示意图" class="headerlink" title="顺序示意图"></a>顺序示意图</h4><p><img src="/images/node-notes/node-eventloop.png" alt="Event Loop图示"></p><ul><li>重点阶段<ul><li>timers 检查计时器</li><li>poll 轮询，检查系统时间</li><li>check检查setImmediate回调</li></ul></li><li>注意<ul><li>大部分时间，Node.js都停在poll 轮询阶段</li><li>大部分事件都在poll阶段被处理，如文件、网络请求</li></ul></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>用libuv进行异步I/O操作</li><li>用event loop管理事件处理顺序</li><li>用C/C++库高效处理DNS/HTTP</li><li>用bindings让JS能和C/C++沟通</li><li>用V8运行JS</li><li>用Node.js标准库简化JS</li></ul><h4 id="Node-js工作流程"><a href="#Node-js工作流程" class="headerlink" title="Node.js工作流程"></a>Node.js工作流程</h4><p><img src="/images/node-notes/node-progress.png" alt="Node.js工作流程图示"></p><h2 id="Node-js-API"><a href="#Node-js-API" class="headerlink" title="Node.js API"></a>Node.js API</h2><h3 id="API文档"><a href="#API文档" class="headerlink" title="API文档"></a>API文档</h3><ul><li>官方文档：<a href="http://nodejs.cn/api/">http://nodejs.cn/api/</a></li><li>民间版本： <a href="https://devdocs.io/">https://devdocs.io/</a></li></ul><h3 id="API有哪些功能"><a href="#API有哪些功能" class="headerlink" title="API有哪些功能"></a>API有哪些功能</h3><ul><li>assersion 断言</li><li>testing</li><li>async hooks</li><li>*Buffer  一小段缓存</li><li>*Child Processes 子进程</li><li>*Cluster</li><li>*Events 发布订阅模式</li><li>*Debugger 调试</li><li>*File System 文件系统 对文件的增删改查</li><li>*Globals 全局变量</li><li>*HTTP</li><li>*Path 路径</li><li>*Process 当前进程的相关信息</li><li>*Query String </li><li>*Stream 流格式</li><li>*Timers</li><li>*URL</li><li>*Worker Threads   node10之后才有的</li></ul>]]></content>
      
      
      <categories>
          
          <category> node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue3学习笔记</title>
      <link href="2021/03/21/Vue3-notes/"/>
      <url>2021/03/21/Vue3-notes/</url>
      
        <content type="html"><![CDATA[<h2 id="亮点"><a href="#亮点" class="headerlink" title="亮点"></a>亮点</h2><ul><li>Performance（比Vue2 runtime快了两倍）</li><li>Tree shaking (按需编译代码)</li><li>Ts support</li><li>Composition API（组合API）</li><li>Custom Renderer API(自定义渲染器)</li></ul><h2 id="数据响应"><a href="#数据响应" class="headerlink" title="数据响应"></a>数据响应</h2><p> Vue3.0 之前的对象数据响应式的原理是 Object.defineProperty(), 数组的响应式原理是拦截了数组的7个方法（包括 push、pop、shift、unshift、 splice、 sort、 reverse）。这种方式存在的问题：对于对象，我们无法直接检测到属性的新增和删除；对于数组我们无法检测到直接去修改数组下标对应的内容以及利用 length 修改数组的长度。</p><p>Vue3.0的数据响应的原理是利用 <code>Proxy </code>实现的。Proxy在ES2015规范中被正式发布，它在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。</p><ul><li>Proxy 可以直接监听对象而非属性。因此对象的属性新增和删除也可以被监听。</li><li>Proxy 可以直接监听数组的变化。因此数组直接修改下标的内容以及长度也可以被监听。</li><li>Proxy 有多达13种拦截方法，不限于apply、deleteProperty、has等</li></ul><h2 id="diff算法优化"><a href="#diff算法优化" class="headerlink" title="diff算法优化"></a>diff算法优化</h2><ul><li>Vue2中的虚拟dom是进行全量比对</li><li>Vue3新增了静态标记（<code>PatchFlag</code>）</li></ul><p>在与上次虚拟节点进行比对时候，只对比带有<code>patch flag</code>的节点（绑定了响应式数据的节点）， 并且可以通过flag的信息 得知当前节点要比对的具体内容。</p><h1 id="新特性"><a href="#新特性" class="headerlink" title="新特性"></a>新特性</h1><h2 id="组合式API"><a href="#组合式API" class="headerlink" title="组合式API"></a>组合式API</h2><h3 id="为什么"><a href="#为什么" class="headerlink" title="为什么"></a>为什么</h3><p>总结一下就是：<strong>避免逻辑关注点过于碎片化，</strong>提高代码的可读性和可维护性。</p><p>在Vue2中，我们如果要实现一个需求，那么这些逻辑会被分散在data、methods、computed等各个<code>Options API</code>，而在Vue3中，我们可以将同一个需求的各个逻辑模块整合起来，放在<code>Composition API</code>。如果用颜色来区分各个逻辑块，那么下图可以直观地展示这种区别。</p><p><img src="/images/vue3-switch/composition.png"></p><h3 id="setup"><a href="#setup" class="headerlink" title="setup"></a>setup</h3><ul><li><p>一个接受<code>props</code>和<code>context</code>的函数，从<code>setup</code>返回的内容都将暴露给组件的其余部分</p><ul><li>props: 传入组件的属性:setup 中接收的<code>props</code>是响应式的， 当传入新的 props 时，会及时被更新。由于是响应式的， 所以<strong>不可以使用 ES6 解构</strong>，解构会消除它的响应式</li><li>context：暴露<code>attrs</code>、<code>slots</code>、<code>emit</code>这三个组件的property</li></ul></li><li><p>在<strong>创建组件之前</strong>，初始化 props 之后调用执行，因此<code>setup</code>中无法访问组件实例<code>this</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="title">beforeCreate</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;beforeCreate&#x27;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">created</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;created&#x27;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;mounted&#x27;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  setup (props, context) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;setup&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// setup</span></span><br><span class="line"><span class="comment">// beforeCreate</span></span><br><span class="line"><span class="comment">// created</span></span><br><span class="line"><span class="comment">// mounted</span></span><br></pre></td></tr></table></figure></li><li><p>我刚开始使用<code>setup</code>的时候，也产生过疑惑，这样不是将所有的代码都塞到<code>setup</code>里面，让它变得非常庞大臃肿吗？官方文档给出了解决方案——将各逻辑模块分别提取到独立的<a href="https://vue3js.cn/docs/zh/guide/composition-api-introduction.html#%E7%8B%AC%E7%AB%8B%E7%9A%84-computed-%E5%B1%9E%E6%80%A7"><strong>组合式函数</strong></a></p></li></ul><h3 id="reactive"><a href="#reactive" class="headerlink" title="reactive"></a>reactive</h3><ul><li>reactive是Vue3中提供的实现响应式数据的方法</li><li>在Vue2中响应式数据是通过defineProperty来实现的，而在Vue3中响应式数据是通过ES6的Proxy来实现的</li></ul><p><strong>注意</strong>:</p><ul><li><p>reactive参数必须是对象（json/arr）</p></li><li><p>如果给reactive传递了其他对象</p><ul><li>默认情况下修改对象，界面不会自动更新</li><li>如果想更新，可以通过重新赋值的方式</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;p&gt;&#123;&#123;state.age&#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;button @click=<span class="string">&quot;myFn&quot;</span>&gt;点我&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">import</span> &#123; reactive &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  name: <span class="string">&#x27;App&#x27;</span>,</span><br><span class="line">  <span class="function"><span class="title">setup</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> state = reactive(&#123;</span><br><span class="line">      age: <span class="number">123</span>,</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">myFn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      state.age = <span class="number">666</span></span><br><span class="line">      <span class="built_in">console</span>.log(state) <span class="comment">// Proxy&#123;age:666&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      state,</span><br><span class="line">      myFn,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li></ul><h3 id="带ref-的响应式变量-响应式引用"><a href="#带ref-的响应式变量-响应式引用" class="headerlink" title="带ref 的响应式变量 (响应式引用)"></a>带ref 的响应式变量 (响应式引用)</h3><ul><li><p>在setup中直接声明的变量是非响应式的，因此需引入<code>ref</code>函数</p></li><li><p><code>ref</code>接受参数并返回一个<a href="https://juejin.cn/post/6844904041357508615">包装对象</a>，包装对象具有 <code>value</code> property ，可使用该 property 访问或更改响应式变量的值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ref &#125; form <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> visible = ref(<span class="literal">false</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(visible) <span class="comment">// &#123; value: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(visible.value) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">visible.value = <span class="literal">true</span></span><br><span class="line"><span class="built_in">console</span>.log(visible.value) <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><a href="https://juejin.cn/post/6844904042242523144#heading-4">为什么要返回一个包装对象</a>?</p><p>提供一个让我们能够在函数之间以引用的方式传递任意类型值的容器。这个容器可以在封装了逻辑的组合函数中将状态以引用的方式传回给组件。组件负责展示（追踪依赖），组合函数负责管理状态（触发更新）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">setup</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> valueA = useLogicA() <span class="comment">// valueA 可能被 useLogicA() 内部的代码修改从而触发更新</span></span><br><span class="line">  <span class="keyword">const</span> valueB = useLogicB()</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    valueA,</span><br><span class="line">    valueB</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 作者：摸鱼架构师</span></span><br><span class="line"><span class="comment">// 链接：https://juejin.cn/post/6844904042242523144</span></span><br><span class="line"><span class="comment">// 来源：掘金</span></span><br></pre></td></tr></table></figure></li><li><p>ref底层的本质其实还是reactive，系统会自动根据我们给ref传入的值将它转换成<code>ref(xx) -&gt; reactive(&#123;value: xx&#125;)</code></p></li></ul><h3 id="ref和reactive的区别"><a href="#ref和reactive的区别" class="headerlink" title="ref和reactive的区别"></a>ref和reactive的区别</h3><p>其目的都是对数据添加响应式效果,<strong>区别在于是否需要添加一层引用包装</strong></p><p>Vue在处理的时候会先判断数据是什么类型的：</p><ul><li>如果在template里面使用的是ref类型(<code>__v_isRef</code>)的数据，那么Vue会自动帮我们添加.value</li><li>如果template里使用的是reactive类型的数据，那么Vue不会自动帮我们添加.value</li></ul><h4 id="isRef和isReactive"><a href="#isRef和isReactive" class="headerlink" title="isRef和isReactive"></a>isRef和isReactive</h4><p>通过 <code>isRef</code> 和<code>isReactive</code>可以判断数据是 <code>ref</code> 还是 <code>reactive</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> age = ref(<span class="number">18</span>)</span><br><span class="line"><span class="keyword">const</span> state = reactive(&#123; <span class="attr">age</span>: <span class="number">18</span> &#125;)</span><br><span class="line"><span class="built_in">console</span>.log(isRef(age),<span class="string">&#x27;isRef--age&#x27;</span>)  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(isRef(state),<span class="string">&#x27;isRef--state&#x27;</span>)  <span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(isReactive(age),<span class="string">&#x27;isReactive--age&#x27;</span>)  <span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(isReactive(state),<span class="string">&#x27;isReactive--state&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="toRefs"><a href="#toRefs" class="headerlink" title="toRefs"></a>toRefs</h3><p>解构的同时保持<code>props</code>和<code>reactive</code>内部变量的响应式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; toRefs &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="function"><span class="title">setup</span>(<span class="params">props</span>)</span>&#123;</span><br><span class="line"><span class="keyword">const</span> &#123; user &#125; = toRefs(props)</span><br><span class="line">    consloe.log(user.value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;img alt=<span class="string">&quot;Vue logo&quot;</span> src=<span class="string">&quot;./assets/logo.png&quot;</span> /&gt;</span><br><span class="line">  &lt;h1&gt;&#123;&#123; title &#125;&#125;&lt;/h1&gt;</span><br><span class="line">  &lt;button @click=<span class="string">&quot;handleClick&quot;</span>&gt;✌&lt;/button&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang=<span class="string">&quot;ts&quot;</span>&gt;</span><br><span class="line"><span class="keyword">import</span> &#123; defineComponent, reactive, toRefs &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> defineComponent(&#123;</span><br><span class="line">  name: <span class="string">&quot;App&quot;</span>,</span><br><span class="line">  <span class="function"><span class="title">setup</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> data = reactive(&#123;</span><br><span class="line">      title: <span class="string">&quot;你好, Vue3&quot;</span>,</span><br><span class="line">      handleClick: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        data.title = <span class="string">&quot;数据来了&quot;</span>;</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">const</span> dataAsRefs = toRefs(data);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    Type of dataAsRefs:</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        title: Ref&lt;string&gt;,</span></span><br><span class="line"><span class="comment">        handleClick: Ref&lt;() =&gt; void&gt;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">return</span> &#123; ...dataAsRefs &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line">&lt;/script&gt;   </span><br></pre></td></tr></table></figure><h3 id="computed属性"><a href="#computed属性" class="headerlink" title="computed属性"></a>computed属性</h3><ul><li><p>使用从 Vue 导入的 <code>computed</code> 函数在 Vue 组件外部创建计算属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ref, computed &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> counter = ref(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">const</span> twiceTheCounter = computed(<span class="function">() =&gt;</span> counter.value * <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">counter.value++</span><br><span class="line"><span class="built_in">console</span>.log(counter.value) <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(twiceTheCounter.value) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure></li><li><p><code>computed</code>函数返回一个<em>只读</em>的<strong>响应式引用</strong>，由一个作为 <code>computed</code> 的第一个参数传递的 getter 类回调输出。为了访问新创建的计算变量的 <strong>value</strong>，我们需要像使用 <code>ref</code> 一样使用 <code>.value</code> property。</p></li></ul><h3 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h3><p><code>watch</code> 需要侦听特定的数据源，并在回调函数中执行副作用。默认情况下，它也是惰性的，即只有当被侦听的源发生变化时才执行回调</p><h4 id="侦听单个数据源"><a href="#侦听单个数据源" class="headerlink" title="侦听单个数据源"></a>侦听单个数据源</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 侦听一个 getter</span></span><br><span class="line"><span class="keyword">const</span> state = reactive(&#123; <span class="attr">count</span>: <span class="number">0</span> &#125;)</span><br><span class="line">watch(</span><br><span class="line">  () =&gt; state.count,</span><br><span class="line">  (count, prevCount) =&gt; &#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接侦听ref</span></span><br><span class="line"><span class="keyword">const</span> count = ref(<span class="number">0</span>)</span><br><span class="line">watch(count, <span class="function">(<span class="params">count, prevCount</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="侦听多个数据源"><a href="#侦听多个数据源" class="headerlink" title="侦听多个数据源"></a>侦听多个数据源</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">watch([fooRef, barRef], <span class="function">(<span class="params">[foo, bar], [prevFoo, prevBar]</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="watchEffect"><a href="#watchEffect" class="headerlink" title="watchEffect"></a>watchEffect</h3><p><code>watchEffect</code>方法接收的第一个参数：<code>effect</code>函数，用于定义副作用。他会立即执行传入的<code>effect</code>函数，同时响应式追踪其依赖，并在其依赖变更时重新运行该函数。</p><p>目的：为了根据响应式状态<em>自动应用</em>和<em>重新应用</em>副作用</p><blockquote><p>注：函数副作用是指当调用函数时，除了返回函数值之外，还对主调用函数产生附加的影响。副作用的函数不仅仅只是返回了一个值，而且还做了其他的事情</p></blockquote><p>如下代码中，副作用函数的作用是：当 <code>count</code> 被访问时，旋即在控制台打出日志。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> count = ref(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">watchEffect(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(count.value))</span><br><span class="line"><span class="comment">// -&gt; logs 0</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  count.value++</span><br><span class="line">  <span class="comment">// -&gt; logs 1</span></span><br><span class="line">&#125;, <span class="number">100</span>)</span><br></pre></td></tr></table></figure><h4 id="副作用刷新时机"><a href="#副作用刷新时机" class="headerlink" title="副作用刷新时机"></a>副作用刷新时机</h4><p>默认情况下，会在所有的组件 <code>update</code> <strong>前</strong>执行，如果需要在组件更新<strong>后</strong>重新运行侦听器副作用，可以传递带有 <code>flush</code> 选项的附加 <code>options</code> 对象 (默认为 <code>&#39;pre&#39;</code>)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fire before component updates</span></span><br><span class="line">watchEffect(</span><br><span class="line">  () =&gt; &#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    flush: <span class="string">&#x27;post&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h4 id="停止侦听"><a href="#停止侦听" class="headerlink" title="停止侦听"></a>停止侦听</h4><p><code>watchEffect</code>会返回一个用于停止这个监听的函数。</p><ul><li><p>这个函数可以在组件被卸载时隐式调用：当 <code>watchEffect</code> 在组件的 setup() 函数或生命周期钩子被调用时，侦听器会被链接到该组件的生命周期，并在组件卸载时自动停止</p></li><li><p>也可以在<code>setup</code>函数里被显式调用，以停止侦听</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> stop = watchEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// later</span></span><br><span class="line">stop()</span><br></pre></td></tr></table></figure></li></ul><h4 id="清除副作用"><a href="#清除副作用" class="headerlink" title="清除副作用"></a>清除副作用</h4><p>有时副作用函数会执行一些异步的副作用，比如当数据变化时发送一次异步请求，如果请求过程中数据发生多次变化，那么就得多次发送请求。这样不仅浪费资源，还会因无法判断异步请求的执行顺序增加不确定性。</p><p>为了解决这个问题，<code>watchEffect</code>副作用传入的函数接收一个<code>onInvalidate</code>函数作为入参，用来注册清理失效时的回调。</p><p><code>onInvalidate</code>只作用于异步函数，并且只有在如下两种情况下才会被调用：</p><ul><li>副作用即将重新执行时</li><li>侦听器被停止 (如果在 <code>setup()</code> 或生命周期钩子函数中使用了 <code>watchEffect</code>，则在组件卸载时)</li></ul><p>我的理解中对异步副作用的清除就相当于<strong>函数防抖</strong>，执行这一次的副作用时，清理上一次的异步副作用，使得之前挂起的异步操作无效。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">watchEffect(<span class="function"><span class="params">onInvalidate</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 异步api调用，返回一个操作对象</span></span><br><span class="line">  <span class="keyword">const</span> token = performAsyncOperation(id.value)</span><br><span class="line">  onInvalidate(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 取消异步api的调用。</span></span><br><span class="line">    token.cancel()</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>Vue3 之所以是通过传入一个函数去注册失效回调，而不是从回调返回它，是因为返回值对于异步错误处理很重要。</p><p>在执行数据请求时，副作用函数往往是一个异步函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> data = ref(<span class="literal">null</span>)</span><br><span class="line">watchEffect(<span class="keyword">async</span> onInvalidate =&gt; &#123;</span><br><span class="line">  onInvalidate(<span class="function">() =&gt;</span> &#123;...&#125;) <span class="comment">// 在Promise解析之前注册清除函数</span></span><br><span class="line">  data.value = <span class="keyword">await</span> fetchData(props.id)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="watchEffect和watch的区别"><a href="#watchEffect和watch的区别" class="headerlink" title="watchEffect和watch的区别"></a>watchEffect和watch的区别</h3><ul><li> <code>watchEffect</code> 不需要指定监听的属性，他会自动的收集依赖， 只要我们回调中引用到了 响应式的属性， 那么当这些属性变更的时候，这个回调都会执行，而 <code>watch</code> 只能监听指定的属性而做出变更(v3开始可以同时指定多个)。</li><li> <code>watch</code> 访问侦听状态变化前后的值。</li><li> <code>watch</code>可以懒执行回调：<code> watchEffect</code> 如果存在，组件初始化的时候就会执行一次用以收集依赖（与<code>computed</code>同理），而后收集到的依赖发生变化，这个回调才会再次执行，而 watch 不需要，因为他一开始就指定了依赖。</li></ul><h2 id="Fragment"><a href="#Fragment" class="headerlink" title="Fragment"></a>Fragment</h2><p>组件现在可以有多个根节点，此时需要明确定义属性应该分布在哪里。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">header</span>&gt;</span>...<span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">main</span> <span class="attr">v-bind</span>=<span class="string">&quot;$attrs&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">footer</span>&gt;</span>...<span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="Teleport组件"><a href="#Teleport组件" class="headerlink" title="Teleport组件"></a>Teleport组件</h2><p><code>vue3</code>提供了一个非常方便的新特性——<code>teloport</code>，可以理解为传送门，允许我们控制在 DOM 中哪个父节点下呈现 HTML，将模板渲染的位置与组件逻辑剥离开来。</p><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p><code>teleport</code>接受两个属性：</p><p><strong>to - string</strong></p><p>以<code>Dialog</code>组件为例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Teleport</span> <span class="attr">to</span>=<span class="string">&quot;#app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;xx-dialog-overlay&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;onClickOverlay&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;xx-dialog-wrapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;xx-dialog&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">header</span> <span class="attr">:class</span>=<span class="string">&quot;&#123; &#x27;title&#x27;: title || $slots.title &#125;&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>=<span class="string">&quot;$slots.title&quot;</span> <span class="attr">class</span>=<span class="string">&quot;title-slot&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;title&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-else</span>&gt;</span>&#123;&#123; title &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;xx-dialog-close&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;close&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">main</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">slot</span> <span class="attr">v-if</span>=<span class="string">&quot;$slots.content&quot;</span> <span class="attr">name</span>=<span class="string">&quot;content&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else</span>&gt;</span>&#123;&#123; content &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">footer</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">x-button</span> <span class="attr">size</span>=<span class="string">&quot;small&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;onCancel&quot;</span>&gt;</span>取消<span class="tag">&lt;/<span class="name">x-button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">x-button</span> <span class="attr">size</span>=<span class="string">&quot;small&quot;</span> <span class="attr">theme</span>=<span class="string">&quot;primary&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;onConfirm&quot;</span>&gt;</span>确定<span class="tag">&lt;/<span class="name">x-button</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Teleport</span>&gt;</span></span><br></pre></td></tr></table></figure><p>效果演示：</p><p><img src="/images/vue3-dialog/teleport.png"></p><p>可以看到通过<code>to</code>属性，指定该组件挂载到了<code>&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</code>中。</p><p><strong>注意</strong>：</p><ul><li><p><code>to</code>属性传入的值必须是有效的查询选择器或 HTMLElement</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 正确 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">teleport</span> <span class="attr">to</span>=<span class="string">&quot;#some-id&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">teleport</span> <span class="attr">to</span>=<span class="string">&quot;.some-class&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">teleport</span> <span class="attr">to</span>=<span class="string">&quot;[data-teleport]&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 错误 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">teleport</span> <span class="attr">to</span>=<span class="string">&quot;h1&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">teleport</span> <span class="attr">to</span>=<span class="string">&quot;some-string&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>默认挂载到第一个选择的元素</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span>container1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span>container2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">teleport</span> <span class="attr">to</span>=<span class="string">&quot;.container&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">teleport</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><p><img src="/images/vue3-dialog/teleport1.png" alt="挂载到第一个.container"></p><p><strong>disabled-boolean</strong></p><p>此可选属性可用于禁用 <code>teleport</code> 的功能，这意味着其插槽内容将不会移动到任何位置，而是在您在周围父组件中指定了 <code>teleport</code> 的位置渲染。</p><h3 id="与-Vue-components-一起使用"><a href="#与-Vue-components-一起使用" class="headerlink" title="与 Vue components 一起使用"></a>与 Vue components 一起使用</h3><p>如果 <code>teleport</code> 包含 Vue 组件，则它仍将是 <code>teleport</code> 父组件的逻辑子组件，仍接收父组件传来的属性。</p><h2 id="Suspense组件"><a href="#Suspense组件" class="headerlink" title="Suspense组件"></a>Suspense组件</h2><p><code>Suspense</code> 是Vue3推出的一个内置特殊组件，用来定义具有异步请求数据的组件的显示。如果使用 Suspense，要 setup函数中需要返回一个 <code>Promise</code>。</p><p>新建 <code>AyncShow.vue</code> 文件，setup函数需要返回一个Promise对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;h1&gt;&#123;&#123;result&#125;&#125;&lt;/h1&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script lang=<span class="string">&quot;ts&quot;</span>&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="function"><span class="title">setup</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resoluve</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">                resoluve(&#123;<span class="attr">result</span>: <span class="number">100</span>&#125;)</span><br><span class="line">            &#125;, <span class="number">2000</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>在<code>App.vue</code>中使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;Suspense&gt;</span><br><span class="line">      &lt;template #<span class="keyword">default</span>&gt; </span><br><span class="line">        &lt;div&gt;</span><br><span class="line">          &lt;AsyncShow/&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">      &lt;/template&gt;</span><br><span class="line">      &lt;template #fallback&gt;</span><br><span class="line">        &lt;h1&gt;Loading...&lt;/h1&gt;</span><br><span class="line">      &lt;/template&gt;</span><br><span class="line">  &lt;/Suspense&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang=<span class="string">&quot;ts&quot;</span>&gt;</span><br><span class="line"><span class="keyword">import</span> &#123; defineComponent, ref, toRefs&#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> AsyncShow <span class="keyword">from</span> <span class="string">&#x27;./components/AsyncShow.vue&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> defineComponent(&#123;</span><br><span class="line">  name: <span class="string">&#x27;App&#x27;</span>,</span><br><span class="line">  components: &#123;</span><br><span class="line">    AsyncShow</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><ul><li><code>Suspense</code>组件内置了两个具名插槽slot,一个是<code>default</code>，用来显示异步组件请求成功的内容；一个是<code>fallback</code>用来显示异步组件请求响应前页面显示的内容。</li><li><code>default</code>插槽可以有多个组件，但是需要有一个根节点。</li></ul><h2 id="defineComponent"><a href="#defineComponent" class="headerlink" title="defineComponent"></a>defineComponent</h2><p><code>defineComponent</code>为了支持 TypeScript 存在的。defineComponent并没有实现特殊逻辑，可以将传入的对象获得对应的类型。我们使用defineComponent定义的组件可以很好的支持 setup、props等的类型提示。</p><h1 id="非兼容的变更"><a href="#非兼容的变更" class="headerlink" title="非兼容的变更"></a>非兼容的变更</h1><h2 id="全局API"><a href="#全局API" class="headerlink" title="全局API"></a>全局API</h2><h3 id="Vue2的全局API"><a href="#Vue2的全局API" class="headerlink" title="Vue2的全局API"></a>Vue2的全局API</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">&#x27;button-counter&#x27;</span>, &#123;</span><br><span class="line">  data: <span class="function">() =&gt;</span> (&#123;</span><br><span class="line">    count: <span class="number">0</span></span><br><span class="line">  &#125;),</span><br><span class="line">  template: <span class="string">&#x27;&lt;button @click=&quot;count++&quot;&gt;Clicked &#123;&#123; count &#125;&#125; times.&lt;/button&gt;&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">Vue.directive(<span class="string">&#x27;focus&#x27;</span>, &#123;</span><br><span class="line">  inserted: <span class="function"><span class="params">el</span> =&gt;</span> el.focus()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这样会导致同一个 Vue 构造函数<strong>创建的每个根实例共享相同的全局配置</strong></p><p>为了避免这些问题，在Vue3中引入了<code>createApp</code></p><h3 id="Vue3-createApp"><a href="#Vue3-createApp" class="headerlink" title="Vue3 createApp"></a>Vue3 createApp</h3><p>调用 <code>createApp</code> 返回一个应用实例，应用实例暴露当前全局 API 的子集，经验法则是，任何全局改变 Vue 行为的 API 现在都会移动到应用实例上</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> app = createApp(MyApp)</span><br><span class="line"></span><br><span class="line">app.component(<span class="string">&#x27;button-counter&#x27;</span>, &#123;</span><br><span class="line">  data: <span class="function">() =&gt;</span> (&#123;</span><br><span class="line">    count: <span class="number">0</span></span><br><span class="line">  &#125;),</span><br><span class="line">  template: <span class="string">&#x27;&lt;button @click=&quot;count++&quot;&gt;Clicked &#123;&#123; count &#125;&#125; times.&lt;/button&gt;&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.directive(<span class="string">&#x27;focus&#x27;</span>, &#123;</span><br><span class="line">  mounted: <span class="function"><span class="params">el</span> =&gt;</span> el.focus()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在所有应用实例都挂载了，与其组件树一起，将具有相同的 “button-counter” 组件 和 “focus” 指令不污染全局环境</span></span><br><span class="line">app.mount(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="v-model"><a href="#v-model" class="headerlink" title="v-model"></a>v-model</h2><h3 id="Vue2的v-model"><a href="#Vue2的v-model" class="headerlink" title="Vue2的v-model"></a>Vue2的v-model</h3><ul><li><p>Vue2.x中，在组件上使用 <code>v-model</code> 相当于绑定 <code>value</code> prop 和 <code>input</code> 事件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">x-switch</span> <span class="attr">v-model</span>=<span class="string">&quot;checked&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 简写: --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">x-switch</span> <span class="attr">:value</span>=<span class="string">&quot;checked&quot;</span> @<span class="attr">input</span>=<span class="string">&quot;checked = $event&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>如果想更改绑定的属性名，或绑定多个变量，可使用<code>.sync</code></p><p>子组件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.$emit(<span class="string">&#x27;update:value&#x27;</span>, newValue)</span><br></pre></td></tr></table></figure><p>父组件：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">x-switch</span> <span class="attr">:value.sync</span>=<span class="string">&quot;checked&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="Vue3的v-model"><a href="#Vue3的v-model" class="headerlink" title="Vue3的v-model"></a>Vue3的v-model</h3><ul><li>属性名任意，假设为 x</li><li>事件名必须为 <code>&#39;update:x&#39;</code></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">x-switch</span> <span class="attr">v-model:value</span>=<span class="string">&quot;checked&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 简写: --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">x-switch</span> <span class="attr">:value</span>=<span class="string">&quot;checked&quot;</span> @<span class="attr">update:value</span>=<span class="string">&quot;checked = $event&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><h2 id="h-渲染函数"><a href="#h-渲染函数" class="headerlink" title="h() 渲染函数"></a>h() 渲染函数</h2><p><code>Vue2</code>中的<a href="https://vuejs.bootcss.com/guide/render-function.html">渲染函数</a>为<code>createElement()</code>，而在<code>Vue3</code>中被称为<code>h()</code>，用于创建虚拟节点（更准确地命名为<code>createVNode()</code>，出于频繁使用和简洁的目的，改为了<code>h()</code>）。</p><p><code>h()</code>同样接受三个参数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @returns &#123;VNode&#125;</span></span><br><span class="line">h(</span><br><span class="line">  <span class="comment">// &#123;String | Object | Function | null&#125; tag</span></span><br><span class="line">  <span class="comment">// 一个 HTML 标签名、一个组件、一个异步组件，或者 null。</span></span><br><span class="line">  <span class="comment">// 使用 null 将会渲染一个注释。</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// 必需的。</span></span><br><span class="line">  <span class="string">&#x27;div&#x27;</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// &#123;Object&#125; props</span></span><br><span class="line">  <span class="comment">// 与 attribute、prop 和事件相对应的对象。</span></span><br><span class="line">  <span class="comment">// 我们会在模板中使用。</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// 可选的。</span></span><br><span class="line">  &#123;&#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// &#123;String | Array | Object&#125; children</span></span><br><span class="line">  <span class="comment">// 子 VNodes, 使用 `h()` 构建,</span></span><br><span class="line">  <span class="comment">// 或使用字符串获取 &quot;文本 Vnode&quot; 或者</span></span><br><span class="line">  <span class="comment">// 有 slot 的对象。</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// 可选的。</span></span><br><span class="line">  [</span><br><span class="line">    <span class="string">&#x27;Some text comes first.&#x27;</span>,</span><br><span class="line">    h(<span class="string">&#x27;h1&#x27;</span>, <span class="string">&#x27;A headline&#x27;</span>),</span><br><span class="line">    h(MyComponent, &#123;</span><br><span class="line">      someProp: <span class="string">&#x27;foobar&#x27;</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>实际应用如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> XDialog <span class="keyword">from</span> <span class="string">&#x27;../Dialog.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; createApp, h &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> openDialog = (&#123;</span><br><span class="line">    title = <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    content = <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    onConfirm = <span class="function">() =&gt;</span> &#123;&#125;,</span><br><span class="line">    onCancel = <span class="function">() =&gt;</span> &#123;&#125;,</span><br><span class="line">    closeOnClickOverlay = <span class="literal">true</span></span><br><span class="line">&#125;) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> div =  <span class="built_in">document</span>.createElement(<span class="string">&#x27;div&#x27;</span>)</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(div)</span><br><span class="line">    <span class="keyword">const</span> close = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        app.unmount()</span><br><span class="line">        div.remove()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> app = createApp(&#123;</span><br><span class="line">        <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> h(</span><br><span class="line">                XDialog,</span><br><span class="line">                &#123;</span><br><span class="line">                    visible: <span class="literal">true</span>,</span><br><span class="line">                    title,</span><br><span class="line">                    content,</span><br><span class="line">                    onConfirm,</span><br><span class="line">                    onCancel,</span><br><span class="line">                    closeOnClickOverlay,</span><br><span class="line">                    <span class="string">&#x27;onUpdate:visible&#x27;</span>:<span class="function">(<span class="params">newVisible</span>) =&gt;</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (!newVisible) &#123;</span><br><span class="line">                            close()</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    app.mount(div)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h2><p>在 Vue 2 中，在 <code>v-for</code> 里使用的 <code>ref</code>  会用 ref 数组填充相应的 <code>$refs</code> property。当存在嵌套的 <code>v-for</code> 时，这种行为会变得不明确且效率低下。</p><p>在 Vue 3 中，这样的用法将不再在 <code>$ref</code> 中自动创建数组。如果要从单个绑定获取多个 ref，需将 <code>ref</code> 绑定到一个更灵活的函数上</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">&quot;item in list&quot;</span> <span class="attr">:ref</span>=<span class="string">&quot;setItemRef&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ref, onBeforeUpdate, onUpdated &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="function"><span class="title">setup</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> itemRefs = []</span><br><span class="line">    <span class="keyword">const</span> setItemRef = <span class="function"><span class="params">el</span> =&gt;</span> &#123;</span><br><span class="line">      itemRefs.push(el) <span class="comment">// 这里的el即为循环的DOM元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      itemRefs,</span><br><span class="line">      setItemRef</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="v-bind-”object“排序"><a href="#v-bind-”object“排序" class="headerlink" title="v-bind=”object“排序"></a>v-bind=”object“排序</h2><h3 id="Vue2-单独的-property优先"><a href="#Vue2-单独的-property优先" class="headerlink" title="Vue2 单独的 property优先"></a>Vue2 单独的 property优先</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- template --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;red&quot;</span> <span class="attr">v-bind</span>=<span class="string">&quot;&#123; id: &#x27;blue&#x27; &#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- result --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;red&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Vue3-绑定顺序决定渲染结果"><a href="#Vue3-绑定顺序决定渲染结果" class="headerlink" title="Vue3 绑定顺序决定渲染结果"></a>Vue3 绑定顺序决定渲染结果</h3><p>v-bind 的绑定顺序会影响渲染结果</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- template --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;red&quot;</span> <span class="attr">v-bind</span>=<span class="string">&quot;&#123; id: &#x27;blue&#x27; &#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- result --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;blue&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- template --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind</span>=<span class="string">&quot;&#123; id: &#x27;blue&#x27; &#125;&quot;</span> <span class="attr">id</span>=<span class="string">&quot;red&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- result --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;red&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
          <category> Vue3 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> Vue3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue3造轮子总结 - 基于Vite + Vue3 + TypeScript实现的简单UI框架</title>
      <link href="2021/03/19/Vue3-ui-notes/"/>
      <url>2021/03/19/Vue3-ui-notes/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>历时将近一个月的时间，Vue3造轮子的项目暂时完结，果然不断实践不断踩坑才是巩固新知识的最好方法，对Vue3算是有了一个整体的把握。把官网部署上线之后成就感也是满满的哈哈哈。所以先对这个项目进行一个整体的回顾~</p><h2 id="技术细节"><a href="#技术细节" class="headerlink" title="技术细节"></a>技术细节</h2><ul><li>使用<code>Vue3</code> + <code>TypeScript</code> 开发组件，基本运用了<code>Vue3</code>的新特性</li><li>使用<code>Vue3 </code>+ <code>Vue Router</code>制作官网，官网支持代码的预览和展示，并进行了移动端适配</li><li>使用<code>marked</code>实现官网对Markdown文件的支持</li><li>使用<code>prism.js</code>实现代码的高亮展示</li><li>使用<code>Vite</code>进行项目的搭建、开发和部署</li><li>手动编写 shell 自动化部署脚本</li><li>使用 <code>Rollup</code> 打包库文件，并发布到 npm</li></ul><h2 id="成果展示"><a href="#成果展示" class="headerlink" title="成果展示"></a>成果展示</h2><p><img src="/images/vue/vue3-ui-index.png"></p><p><a href="https://wuyangqin.github.io/xing-ui-v3-dist/#/">官网地址</a></p><p><a href="https://github.com/wuyangqin/xing-ui-v3">源码查看</a></p><h2 id="项目回顾"><a href="#项目回顾" class="headerlink" title="项目回顾"></a>项目回顾</h2><h3 id="项目搭建"><a href="#项目搭建" class="headerlink" title="项目搭建"></a>项目搭建</h3><p>项目采用<code>vite</code>来搭建项目</p><ul><li><p>什么是vite</p><p><code>vite</code> 是一个由原生 <strong>ESM</strong> 驱动的Web开发构建工具。在开发环境下基于浏览器原生 <code>ES imports</code> 开发，在生产环境下基于 <code>Rollup</code> 打包</p></li><li><p>vite的特点</p><ul><li>快速的冷启动：不需要等待打包操作；即时的热模块更新</li><li>替换性能和模块数量的解耦让更新飞起；</li><li>真正的按需编译：不再等待整个应用编译完成</li></ul></li><li><p>创建项目</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装脚手架工具</span></span><br><span class="line">yarn global add create-vite-app@1.18.0</span><br><span class="line"><span class="comment"># 创建并进入工程目录</span></span><br><span class="line">mkdir xing-ui-v3 &amp;&amp; <span class="built_in">cd</span> xing-ui-v3</span><br><span class="line"><span class="comment"># 创建项目目录</span></span><br><span class="line">cva xing-ui-v3</span><br></pre></td></tr></table></figure></li><li><p>项目主要目录结构</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">├── index.html</span><br><span class="line">├── vite.config.ts<span class="comment"># vite配置文件</span></span><br><span class="line">├── public<span class="comment"># 该项目静态资源</span></span><br><span class="line">├── plugins<span class="comment"># 该项目所使用插件</span></span><br><span class="line">└── src</span><br><span class="line">    ├── assets  </span><br><span class="line">    |└── css<span class="comment"># 公共css文件</span></span><br><span class="line">├── components<span class="comment"># 制作官网需要的组件</span></span><br><span class="line">├── lib<span class="comment"># 需导出的UI组件库</span></span><br><span class="line">├── markdown<span class="comment"># 官网展示所需md文件</span></span><br><span class="line">├── router<span class="comment"># 路由</span></span><br><span class="line">├── views<span class="comment"># 官网页面逻辑</span></span><br><span class="line">├── App.vue</span><br><span class="line">├── main.ts</span><br><span class="line">    └── index.scss</span><br></pre></td></tr></table></figure></li></ul><h3 id="组件开发"><a href="#组件开发" class="headerlink" title="组件开发"></a>组件开发</h3><h4 id="组件开发思路"><a href="#组件开发思路" class="headerlink" title="组件开发思路"></a>组件开发思路</h4><p>每个组件的开发基本遵循的开发思路为：</p><p><img src="/images/vue/vue3-components.png"></p><ol><li><p>需求分析：明确每个组件需要实现的功能，交互方式，设计基本样式和API</p></li><li><p>逻辑实现：将功能上的逻辑走通，下文会详细叙述每个组件开发过程中运用到的<code>Vue3</code>新特性、遇到的问题及解决过程</p></li><li><p>完善css样式：为方便后期维护，将组件库的公共scss变量以及各个组件的scss变量存放到公共的scss文件中</p><p>*注：在该项目的开发中，尝试配置全局的scss文件失败，后续会继续尝试优化</p></li><li><p>优化测试：优化代码，测试功能是否正常运行，后续会添加每个组件的单元测试，以及实现持续集成测试</p></li></ol><p><em>注：该UI框架的开发是以学习<code>Vue3</code>为主要目的，因此每个组件都只实现了部分基础功能，并不能满足实际项目开发需要；组件的功能和样式参考了主流的UI框架</em></p><h4 id="Switch-开关"><a href="#Switch-开关" class="headerlink" title="Switch 开关"></a>Switch 开关</h4><p><a href="https://wuyangqin.github.io/2021/02/20/Vue3-1-switch/">Switch组件总结</a></p><p><img src="/images/vue3-switch/switch.gif"></p><h4 id="Button-按钮"><a href="#Button-按钮" class="headerlink" title="Button 按钮"></a>Button 按钮</h4><p><a href="https://wuyangqin.github.io/2021/02/27/Vue3-2-button/">Button组件总结</a></p><p><img src="/images/vue3-button/button.png"></p><h4 id="Dialog-对话框"><a href="#Dialog-对话框" class="headerlink" title="Dialog 对话框"></a>Dialog 对话框</h4><p><a href="https://wuyangqin.github.io/2021/03/07/Vue3-3-dialog/">Dialog组件总结</a></p><p><img src="/images/vue3-dialog/dialog.png"></p><h4 id="Tabs-标签页"><a href="#Tabs-标签页" class="headerlink" title="Tabs 标签页"></a>Tabs 标签页</h4><p><a href="https://wuyangqin.github.io/2021/03/16/Vue3-4-tabs/">Tabs组件总结</a></p><p><img src="/images/vue3-tabs/tabs.gif"></p><h3 id="完善官网"><a href="#完善官网" class="headerlink" title="完善官网"></a>完善官网</h3><h4 id="支持引入markdown文件"><a href="#支持引入markdown文件" class="headerlink" title="支持引入markdown文件"></a>支持引入markdown文件</h4><ul><li><p>安装<code>marked</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add --dev marked</span><br></pre></td></tr></table></figure></li><li><p>配置<code>md.ts</code>（自制vite插件）</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @ts-nocheck</span></span><br><span class="line"><span class="keyword">import</span> path <span class="keyword">from</span> <span class="string">&#x27;path&#x27;</span></span><br><span class="line"><span class="keyword">import</span> fs <span class="keyword">from</span> <span class="string">&#x27;fs&#x27;</span></span><br><span class="line"><span class="keyword">import</span> marked <span class="keyword">from</span> <span class="string">&#x27;marked&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mdToJs = <span class="function"><span class="params">str</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> content = <span class="built_in">JSON</span>.stringify(marked(str))</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`export default <span class="subst">$&#123;content&#125;</span>`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">md</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        configureServer: [ <span class="comment">// 用于开发</span></span><br><span class="line">            <span class="keyword">async</span> (&#123; app &#125;) =&gt; &#123;</span><br><span class="line">                app.use(<span class="keyword">async</span> (ctx, next) =&gt; &#123; <span class="comment">// koa</span></span><br><span class="line">                    <span class="keyword">if</span> (ctx.path.endsWith(<span class="string">&#x27;.md&#x27;</span>)) &#123; <span class="comment">// 如果文件时以.md结尾，就转译为js(因为浏览器只支持js)</span></span><br><span class="line">                        ctx.type = <span class="string">&#x27;js&#x27;</span></span><br><span class="line">                        <span class="keyword">const</span> filePath = path.join(process.cwd(), ctx.path)</span><br><span class="line">                        ctx.body = mdToJs(fs.readFileSync(filePath).toString())</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">await</span> next()</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;,</span><br><span class="line">        ],</span><br><span class="line">        transforms: [&#123;  <span class="comment">// 用于 rollup // 插件</span></span><br><span class="line">            test: <span class="function"><span class="params">context</span> =&gt;</span> context.path.endsWith(<span class="string">&#x27;.md&#x27;</span>),</span><br><span class="line">            transform: <span class="function">(<span class="params">&#123; code &#125;</span>) =&gt;</span> mdToJs(code)</span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>创建<code>vite.config.ts</code></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @ts-nocheck</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; md &#125; <span class="keyword">from</span> <span class="string">&quot;./plugins/md&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    plugins: [md()] <span class="comment">// 使用md插件</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>使用示例</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">article</span> <span class="attr">v-mtml</span>=<span class="string">&quot;md&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> md <span class="keyword">from</span> <span class="string">&#x27;../markdown/attr-button.md&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123;ref&#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  setup () &#123;</span><br><span class="line">    <span class="keyword">const</span> md = ref&lt;<span class="built_in">string</span>&gt;(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    md.value = md</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      md</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li></ul><h4 id="代码高亮展示"><a href="#代码高亮展示" class="headerlink" title="代码高亮展示"></a>代码高亮展示</h4><ul><li><p>为什么使用<code>prism.js</code>？</p><p>在Vue2造轮子的项目中，我使用了<code>highlight.js</code>进行代码高亮，于是这个项目我也先尝试使用了这个库。</p><p>然而，引入后，运行时会报错<code>Uncaught ReferenceError: require is not defined</code>。</p><p> google后了解到，<code>vite</code>使用的是浏览器自带的<code>module</code>去解析<code>js</code>的，而<code>require</code>语法是<code>node</code>语法，因此不支持使用 <code>require</code> 方式来导入模块。</p><p>然后查看了一下<code>highlight.js</code>的源代码，发现其入口文件是这样的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> hljs = <span class="built_in">require</span>(<span class="string">&#x27;./core&#x27;</span>);</span><br><span class="line"><span class="comment">/* --- */</span></span><br><span class="line"><span class="built_in">module</span>.exports = hljs;</span><br></pre></td></tr></table></figure><p>于是只能采用方应杭老师的建议，使用<code>prism.js</code>。</p></li><li><p>如何引入</p><p>查看<code>prism.js</code>的源代码，发现有这么一段</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">global</span> !== <span class="string">&#x27;undefined&#x27;</span>) &#123;</span><br><span class="line"><span class="built_in">global</span>.Prism = Prism;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>指其声明了一个全局变量<code>Prism</code>，因此可以这样引入</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;pre <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;language-html&quot;</span> v-html=<span class="string">&quot;Prism.highlight(code, Prism.languages.html, type)&quot;</span> /&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang=<span class="string">&quot;ts&quot;</span>&gt;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;prismjs&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> Prism = (<span class="built_in">window</span> <span class="keyword">as</span> any).Prism</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>封装代码高亮组件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">pre</span> <span class="attr">class</span>=<span class="string">&quot;language-html&quot;</span> <span class="attr">v-html</span>=<span class="string">&quot;Prism.highlight(code, Prism.languages.html, type)&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> <span class="string">&#x27;prismjs&#x27;</span>;</span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> Prism = (<span class="built_in">window</span> <span class="keyword">as</span> any).Prism</span></span><br><span class="line"></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">  name: <span class="string">&#x27;pre-code&#x27;</span>,</span></span><br><span class="line">  props: &#123;</span><br><span class="line">    code: &#123;</span><br><span class="line"><span class="javascript">      type: <span class="built_in">String</span>,</span></span><br><span class="line"><span class="javascript">      <span class="keyword">default</span>: <span class="string">&#x27;&#x27;</span></span></span><br><span class="line">    &#125;,</span><br><span class="line">    type: &#123;</span><br><span class="line"><span class="javascript">      type: <span class="built_in">String</span>,</span></span><br><span class="line"><span class="javascript">      <span class="keyword">default</span>: <span class="string">&#x27;html&#x27;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"><span class="javascript">  <span class="function"><span class="title">setup</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line">      Prism</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">lang</span>=<span class="string">&quot;scss&quot;</span>&gt;</span></span><br><span class="line"><span class="css"><span class="keyword">@import</span> <span class="string">&#x27;../../assets/css/prism.css&#x27;</span>;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>封装代码展示组件</p></li></ul><p>效果：</p><p><img src="/images/vue/vue3-ui-code.png"></p><h4 id="打包部署"><a href="#打包部署" class="headerlink" title="打包部署"></a>打包部署</h4><ul><li><p>在vite.config.ts中配置build path</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    base: <span class="string">&#x27;./&#x27;</span>,</span><br><span class="line">    assetsDir: <span class="string">&#x27;assets&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>编写一键部署脚本</p><p>项目根目录添加<code>deploy.sh</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">rm -rf dist &amp;&amp;</span><br><span class="line">yarn build &amp;&amp;</span><br><span class="line"><span class="built_in">cd</span> dist &amp;&amp;</span><br><span class="line">git init &amp;&amp;</span><br><span class="line">git add . &amp;&amp;</span><br><span class="line">git commit -m <span class="string">&quot;update&quot;</span> &amp;&amp;</span><br><span class="line">git branch -M master &amp;&amp;</span><br><span class="line">git remote add origin git@github.com:wuyangqin/xing-ui-v3-dist.git &amp;&amp;</span><br><span class="line">git push -f -u origin master &amp;&amp;</span><br><span class="line"><span class="built_in">cd</span> -</span><br><span class="line"><span class="built_in">echo</span> https://wuyangqin.github.io/xing-ui-v3-dist/<span class="comment">#/</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="发布至npm"><a href="#发布至npm" class="headerlink" title="发布至npm"></a>发布至npm</h3><h4 id="rollup-编译库文件"><a href="#rollup-编译库文件" class="headerlink" title="rollup 编译库文件"></a>rollup 编译库文件</h4><ul><li><p>在<code>lib</code>目录新建<code>index.ts</code>导出需导出的文件</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123; <span class="keyword">default</span> <span class="keyword">as</span> XSwitch &#125; <span class="keyword">from</span> <span class="string">&#x27;./Switch.vue&#x27;</span></span><br><span class="line"><span class="keyword">export</span> &#123; <span class="keyword">default</span> <span class="keyword">as</span> XButton &#125; <span class="keyword">from</span> <span class="string">&#x27;./Button.vue&#x27;</span></span><br><span class="line"><span class="keyword">export</span> &#123; <span class="keyword">default</span> <span class="keyword">as</span> XTabs &#125; <span class="keyword">from</span> <span class="string">&#x27;./tabs/tabs.vue&#x27;</span></span><br><span class="line"><span class="keyword">export</span> &#123; <span class="keyword">default</span> <span class="keyword">as</span> XTab &#125; <span class="keyword">from</span> <span class="string">&#x27;./tabs/tab.vue&#x27;</span></span><br><span class="line"><span class="keyword">export</span> &#123; <span class="keyword">default</span> <span class="keyword">as</span> XDialog &#125; <span class="keyword">from</span> <span class="string">&#x27;./Dialog.vue&#x27;</span></span><br><span class="line"><span class="keyword">export</span> &#123; <span class="keyword">default</span> <span class="keyword">as</span> XIcon &#125; <span class="keyword">from</span> <span class="string">&#x27;./Icon.vue&#x27;</span></span><br><span class="line"><span class="keyword">export</span> &#123; openDialog <span class="keyword">as</span> openDialog &#125; <span class="keyword">from</span> <span class="string">&#x27;./plugin/openDialog&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>配置<code>rollup.config.js</code></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> esbuild <span class="keyword">from</span> <span class="string">&#x27;rollup-plugin-esbuild&#x27;</span> <span class="comment">// 把ts变成js</span></span><br><span class="line"><span class="keyword">import</span> vue <span class="keyword">from</span> <span class="string">&#x27;rollup-plugin-vue&#x27;</span>  <span class="comment">// 把vue结尾的文件变成js</span></span><br><span class="line"><span class="keyword">import</span> scss <span class="keyword">from</span> <span class="string">&#x27;rollup-plugin-scss&#x27;</span> <span class="comment">// 把scss结尾的变成js</span></span><br><span class="line"><span class="keyword">import</span> dartSass <span class="keyword">from</span> <span class="string">&#x27;sass&#x27;</span>; <span class="comment">// 用来支持rollup-plugin-scss插件</span></span><br><span class="line"><span class="keyword">import</span> &#123; terser &#125; <span class="keyword">from</span> <span class="string">&quot;rollup-plugin-terser&quot;</span> <span class="comment">// 把js代码变得别人看不懂</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  input: <span class="string">&#x27;src/lib/index.ts&#x27;</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    globals: &#123; <span class="comment">// 用到了外部依赖Vue</span></span><br><span class="line">      vue: <span class="string">&#x27;Vue&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    name: <span class="string">&#x27;xing-ui-v3&#x27;</span>,</span><br><span class="line">    file: <span class="string">&#x27;dist/lib/xing-ui-v3.js&#x27;</span>,</span><br><span class="line">    format: <span class="string">&#x27;umd&#x27;</span>,</span><br><span class="line">    plugins: [terser()]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    scss(&#123; <span class="attr">include</span>: <span class="regexp">/\.scss$/</span>, sass: dartSass &#125;),</span><br><span class="line">    esbuild(&#123;</span><br><span class="line">      include: <span class="regexp">/\.[jt]s$/</span>,</span><br><span class="line">      minify: process.env.NODE_ENV === <span class="string">&#x27;production&#x27;</span>,</span><br><span class="line">      target: <span class="string">&#x27;es2015&#x27;</span></span><br><span class="line">    &#125;),</span><br><span class="line">    vue(&#123;</span><br><span class="line">      include: <span class="regexp">/\.vue$/</span>,</span><br><span class="line">    &#125;)</span><br><span class="line">  ],</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>使用rollup打包</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rollup -c</span><br></pre></td></tr></table></figure></li></ul><h4 id="发布至npm-1"><a href="#发布至npm-1" class="headerlink" title="发布至npm"></a>发布至npm</h4><ul><li><p>配置package.json</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;xing-ui-v3&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;0.0.1&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;files&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;dist/lib/*&quot;</span> <span class="comment">// 发布dist/lib下的所有文件</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">&quot;main&quot;</span>: <span class="string">&quot;dist/lib/xing-ui-v3.js&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>发布</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm login</span><br><span class="line">npm publish</span><br></pre></td></tr></table></figure></li></ul><h2 id="Xing-UI-Vue2版"><a href="#Xing-UI-Vue2版" class="headerlink" title="Xing-UI Vue2版"></a>Xing-UI Vue2版</h2><p>在<code>Vue3</code>版本的UI库实现之前，还实现了<code>Vue2</code>版本，对应的官网和源码链接如下：</p><p><a href="https://wuyangqin.github.io/xing-ui/">效果预览</a></p><p><a href="https://github.com/wuyangqin/xing-ui">源码查看</a></p><h2 id="后期规划"><a href="#后期规划" class="headerlink" title="后期规划"></a>后期规划</h2><ul><li>添加图标库</li><li>添加单元测试</li><li>组件库持续更新</li></ul>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
          <category> Vue3 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> 造轮子 </tag>
            
            <tag> Vue3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue3造轮子（四）-Tabs组件</title>
      <link href="2021/03/16/Vue3-4-tabs/"/>
      <url>2021/03/16/Vue3-4-tabs/</url>
      
        <content type="html"><![CDATA[<h2 id="效果预览"><a href="#效果预览" class="headerlink" title="效果预览"></a>效果预览</h2><p><img src="/images/vue3-tabs/tabs.gif"></p><p><a href="https://github.com/wuyangqin/xing-ui-v3">代码链接</a></p><p><a href="https://github.com/wuyangqin/xing-ui-v3/commits/07da8167bb0401938f1db86c57c54be01b7ae83c">提交历史</a></p><h2 id="API设计"><a href="#API设计" class="headerlink" title="API设计"></a>API设计</h2><h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><ul><li><p>tabs的子组件只能是tab组件</p></li><li><p>点击标签切换，动态渲染内容 – v-model:selected，动态组件</p></li><li><p>tab标签下横线移动，且长度根据标签宽度变化</p></li></ul><h3 id="用户怎么用该组件"><a href="#用户怎么用该组件" class="headerlink" title="用户怎么用该组件"></a>用户怎么用该组件</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">x-tabs</span> <span class="attr">v-model:selected</span>=<span class="string">&quot;selectTab&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">x-tab</span> <span class="attr">label</span>=<span class="string">&quot;星星&quot;</span> <span class="attr">name</span>=<span class="string">&quot;star&quot;</span>&gt;</span>一颗小星星<span class="tag">&lt;/<span class="name">x-tab</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">x-tab</span> <span class="attr">label</span>=<span class="string">&quot;羊&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sheep&quot;</span>&gt;</span>羊羊羊<span class="tag">&lt;/<span class="name">x-tab</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">x-tab</span> <span class="attr">label</span>=<span class="string">&quot;咩咩&quot;</span> <span class="attr">name</span>=<span class="string">&quot;mie&quot;</span>&gt;</span>咩咩是全世界最可爱的猫咪<span class="tag">&lt;/<span class="name">x-tab</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">x-tabs</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h2><p>从需求出发，将每个需求分别拆分成几个小问题一一解决</p><h3 id="如何确认子组件的类型"><a href="#如何确认子组件的类型" class="headerlink" title="如何确认子组件的类型"></a>如何确认子组件的类型</h3><p>要解决这个问题，首先得知道如何拿到子组件。由于<code>Tab</code>组件都是通过默认插槽的形式和<code>Tabs</code>组件一起使用，因此只要拿到<code>Tabs</code>组件的插槽就可以了。</p><p>在<code>Vue2</code>中，是使用<code>$slots</code>来获取插槽。而在<code>Vue3</code>中，通过文档可知，<code>setup</code>函数接受的第二个参数<code>context</code>中，暴露了<code>slots</code>这个属性，因此可通过<code>context.slots</code>后获取插槽，再通过组件的name判断组件类型</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> defaults = context.slots.default()</span><br><span class="line">defaults.forEach(<span class="function"><span class="params">pane</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (pane.type.name !== <span class="string">&#x27;xx-tab&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;Tabs 子标签必须是 Tab 组件&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="如何动态渲染嵌套的组件"><a href="#如何动态渲染嵌套的组件" class="headerlink" title="如何动态渲染嵌套的组件"></a>如何动态渲染嵌套的组件</h3><p>拿到了默认插槽(<code>tab</code>组件)后，首先想到的是通过循环渲染，然后比较子组件的<code>name</code>属性和<code>selected</code>的值过滤未选中的组件内容。</p><p>然而这样会遇到一个问题：将<code>v-for</code>和<code>v-if</code>一起使用了。官方文档并<a href="https://vue3js.cn/docs/zh/style-guide/#%E9%81%BF%E5%85%8D-v-if-%E5%92%8C-v-for-%E4%B8%80%E8%B5%B7%E4%BD%BF%E7%94%A8%E5%BF%85%E8%A6%81">不推荐这样做</a>。</p><p>因此，先通过计算属性拿到当前选中的组件，再通过动态组件渲染</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">&quot;currentTab&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;selected&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">setup</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> currentTab = computed(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> defaults.filter(<span class="function"><span class="params">pane</span> =&gt;</span> pane.props.name === props.selected)[<span class="number">0</span>]</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> &#123; currentTab &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注</strong>：如果<component/>渲染的内容改变，必须要将<code>key</code>标识也改变，否则将无法动态变化</p><h3 id="如何制作移动的导航条"><a href="#如何制作移动的导航条" class="headerlink" title="如何制作移动的导航条"></a>如何制作移动的导航条</h3><h4 id="确定标签导航的html结构"><a href="#确定标签导航的html结构" class="headerlink" title="确定标签导航的html结构"></a>确定标签导航的html结构</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;xx-tabs-nav&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 标签 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;xx-tabs-nav-item&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">v-for</span>=<span class="string">&quot;(pane,index) in tabPanes&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">:class</span>=<span class="string">&quot;&#123; selected: pane.name === selected &#125;&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">:key</span>=<span class="string">&quot;index&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;changeTab(pane.name)&quot;</span>&gt;</span></span><br><span class="line">    &#123;&#123; pane.label &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 导航条 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;xx-tabs-nav-indicator&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>根据需求，导航条的宽度应为当前选中标签的宽度，而导航条的位置应该是选中标签的left - 导航容器的left。那么问题就变成了：如何获取导航容器，导航条，选中标签这三个DOM元素呢？</p><h4 id="如何获取DOM元素"><a href="#如何获取DOM元素" class="headerlink" title="如何获取DOM元素"></a>如何获取DOM元素</h4><p>在<code>Vue2</code>中，可以使用<code>ref</code>和<code>$refs</code>来获取DOM元素，而在<code>Vue3</code>中有了新变化。如果在<code>v-for</code>中使用<code>ref</code>，需要将 <code>ref</code> 绑定到一个更灵活的函数上。</p><p>基于此，可以使用如下方式创建设置导航条属性的方法：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;xx-tabs-nav&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;navContainer&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;xx-tabs-nav-item&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">v-for</span>=<span class="string">&quot;(pane,index) in tabPanes&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">:class</span>=<span class="string">&quot;&#123; selected: pane.name === selected &#125;&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">:ref</span>=<span class="string">&quot;el =&gt; &#123; if (pane.name === selected) selectedItem = el &#125;&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">:key</span>=<span class="string">&quot;index&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;changeTab(pane.name)&quot;</span>&gt;</span></span><br><span class="line">    &#123;&#123; pane.label &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;xx-tabs-nav-indicator&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;indicator&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">setup</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> selectedItem = ref&lt;HTMLDivElement&gt;(<span class="literal">null</span>)</span><br><span class="line">    <span class="keyword">const</span> indicator = ref&lt;HTMLDivElement&gt;(<span class="literal">null</span>)</span><br><span class="line">    <span class="keyword">const</span> navContainer = ref&lt;HTMLDivElement&gt;(<span class="literal">null</span>)</span><br><span class="line">    <span class="keyword">const</span> getIndicatorAttr = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; width &#125; = selectedItem.value.getBoundingClientRect()</span><br><span class="line">      <span class="keyword">const</span> &#123; <span class="attr">left</span>: containerLeft &#125; = navContainer.value.getBoundingClientRect()</span><br><span class="line">      <span class="keyword">const</span> &#123; <span class="attr">left</span>: selectedItemLeft &#125; = selectedItem.value.getBoundingClientRect()</span><br><span class="line">      <span class="keyword">const</span> left = selectedItemLeft - containerLeft</span><br><span class="line">      indicator.value.style.left = left + <span class="string">&#x27;px&#x27;</span></span><br><span class="line">      indicator.value.style.width = width + <span class="string">&#x27;px&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> count = ref(<span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="如何实现宽度动态变化"><a href="#如何实现宽度动态变化" class="headerlink" title="如何实现宽度动态变化"></a>如何实现宽度动态变化</h4><p>很容易想到，当控制标签选中的变量<code>selected</code>发生变化后，生命周期函数<code>updated</code>即会执行，因此我们可以在组件挂载完成及更新完成时分别调用<code>getIndicatorAttr</code>方法实现宽度的动态变化。</p><p>在Vue 3中，可以使用直接导入的 <code>onX</code> 函数注册生命周期钩子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; onMounted, onUpdated &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">setup</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    onMounted(getIndicatorAttr)</span><br><span class="line">    onUpdated(getIndicatorAttr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="如何优化"><a href="#如何优化" class="headerlink" title="如何优化"></a>如何优化</h4><p>虽然需求已经实现，但问题又来了：这段代码还有没有优化空间呢？</p><p>于是想到，能不能通过<strong>监听<code>selected</code>的变化</strong>来实现<code>getIndicatorAttr</code>方法的调用呢？</p><p>查阅文档发现，Vue3还提供了一个新特性——<code>watchEffect</code>响应式追踪其依赖的变化。于是根据文档进行了尝试：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> count = ref(<span class="number">0</span>)</span><br><span class="line">onMounted(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;onMounted&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line">watchEffect(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(count.value))</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  count.value++</span><br><span class="line">&#125;, <span class="number">100</span>)</span><br><span class="line"><span class="comment">// -&gt; 0</span></span><br><span class="line"><span class="comment">// -&gt; onMounted</span></span><br><span class="line"><span class="comment">// -&gt; 1</span></span><br></pre></td></tr></table></figure><p>可以看到<code>watchEffect</code>会在<strong>onMounted执行前</strong>调用一次，并在所传入函数中的依赖发生变化时再次被调用。</p><p>但DOM元素在组件挂载完成后才能获取到，因此采取了这样的调用方式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">onMounted(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">  watchEffect(getIndicatorAttr())</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>然而，当我欣喜地期待着功能完美实现的时候，马上就打脸了：</p><p><img src="/images/vue3-tabs/tabs-bug.gif" alt="怎么不按剧本来呢"></p><h4 id="解决使用watchEffect的bug"><a href="#解决使用watchEffect的bug" class="headerlink" title="解决使用watchEffect的bug"></a>解决使用<code>watchEffect</code>的bug</h4><p>这是什么情况？马上打console看了看：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">onMounted(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;onMounted&#x27;</span>);</span><br><span class="line">  watchEffect(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(selectedItem.value);</span><br><span class="line">    getIndicatorAttr()</span><br><span class="line">  &#125;, &#123; <span class="attr">flush</span>:<span class="string">&#x27;pre&#x27;</span> &#125;) <span class="comment">// Vue3正式版默认flush为pre（即在渲染前执行watchEffect）</span></span><br><span class="line">&#125;)</span><br><span class="line">onUpdated(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;onUpdated&#x27;</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><img src="/images/vue3-tabs/tabs-console.gif"></p><p>重新梳理逻辑：</p><p><img src="/images/vue3-tabs/why.png"></p><p>原本是期望<code>selected</code>变化导致<code>selectedItem</code>变化，之后<code>watchEffect</code>执行，改变<code>indicator</code>位置。实际上却是：<code>watchEffect</code>在<code>selectedItem</code>变化前就执行了，发现其还未变化，因此传入的函数并未立即调用。</p><p>查阅文档发现确实如此：</p><blockquote><p>Vue 的响应性系统会缓存副作用函数，并异步地刷新它们，这样可以避免同一个“tick” 中多个状态改变导致的不必要的重复调用。在核心的具体实现中，组件的 <code>update</code> 函数也是一个被侦听的副作用。当一个用户定义的副作用函数进入队列时，默认情况下，会在所有的组件 <code>update</code> <strong>前</strong>执行</p></blockquote><p>文档也给出了相应的解决方案：</p><blockquote><p>如果需要在组件更新<strong>后</strong>重新运行侦听器副作用，可以传递带有 <code>flush</code> 选项的附加 <code>options</code> 对象 (默认为 <code>&#39;pre&#39;</code>)：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fire before component updates</span></span><br><span class="line">watchEffect(</span><br><span class="line">  () =&gt; &#123;</span><br><span class="line">    getIndicatorAttr()</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    flush: <span class="string">&#x27;post&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><img src="/images/vue3-tabs/success.gif" alt="问题解决~"></p><h2 id="Vue3笔记"><a href="#Vue3笔记" class="headerlink" title="Vue3笔记"></a>Vue3笔记</h2><h3 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h3><p>在 Vue 2 中，在 <code>v-for</code> 里使用的 <code>ref</code>  会用 ref 数组填充相应的 <code>$refs</code> property。当存在嵌套的 <code>v-for</code> 时，这种行为会变得不明确且效率低下。</p><p>在 Vue 3 中，这样的用法将不再在 <code>$ref</code> 中自动创建数组。如果要从单个绑定获取多个 ref，需将 <code>ref</code> 绑定到一个更灵活的函数上</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">&quot;item in list&quot;</span> <span class="attr">:ref</span>=<span class="string">&quot;setItemRef&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ref, onBeforeUpdate, onUpdated &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="function"><span class="title">setup</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> itemRefs = []</span><br><span class="line">    <span class="keyword">const</span> setItemRef = <span class="function"><span class="params">el</span> =&gt;</span> &#123;</span><br><span class="line">      itemRefs.push(el) <span class="comment">// 这里的el即为循环的DOM元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      itemRefs,</span><br><span class="line">      setItemRef</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h3><p><code>watch</code> 需要侦听特定的数据源，并在回调函数中执行副作用。默认情况下，它也是惰性的，即只有当被侦听的源发生变化时才执行回调</p><h4 id="侦听单个数据源"><a href="#侦听单个数据源" class="headerlink" title="侦听单个数据源"></a>侦听单个数据源</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 侦听一个 getter</span></span><br><span class="line"><span class="keyword">const</span> state = reactive(&#123; <span class="attr">count</span>: <span class="number">0</span> &#125;)</span><br><span class="line">watch(</span><br><span class="line">  () =&gt; state.count,</span><br><span class="line">  (count, prevCount) =&gt; &#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接侦听ref</span></span><br><span class="line"><span class="keyword">const</span> count = ref(<span class="number">0</span>)</span><br><span class="line">watch(count, <span class="function">(<span class="params">count, prevCount</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="侦听多个数据源"><a href="#侦听多个数据源" class="headerlink" title="侦听多个数据源"></a>侦听多个数据源</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">watch([fooRef, barRef], <span class="function">(<span class="params">[foo, bar], [prevFoo, prevBar]</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="watchEffect"><a href="#watchEffect" class="headerlink" title="watchEffect"></a>watchEffect</h3><p><code>watchEffect</code>方法接收的第一个参数：<code>effect</code>函数，用于定义副作用。他会立即执行传入的<code>effect</code>函数，同时响应式追踪其依赖，并在其依赖变更时重新运行该函数。</p><p>目的：为了根据响应式状态<em>自动应用</em>和<em>重新应用</em>副作用</p><blockquote><p>注：函数副作用是指当调用函数时，除了返回函数值之外，还对主调用函数产生附加的影响。副作用的函数不仅仅只是返回了一个值，而且还做了其他的事情</p></blockquote><p>如下代码中，副作用函数的作用是：当 <code>count</code> 被访问时，旋即在控制台打出日志。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> count = ref(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">watchEffect(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(count.value))</span><br><span class="line"><span class="comment">// -&gt; logs 0</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  count.value++</span><br><span class="line">  <span class="comment">// -&gt; logs 1</span></span><br><span class="line">&#125;, <span class="number">100</span>)</span><br></pre></td></tr></table></figure><h4 id="副作用刷新时机"><a href="#副作用刷新时机" class="headerlink" title="副作用刷新时机"></a>副作用刷新时机</h4><p>默认情况下，会在所有的组件 <code>update</code> <strong>前</strong>执行，如果需要在组件更新<strong>后</strong>重新运行侦听器副作用，可以传递带有 <code>flush</code> 选项的附加 <code>options</code> 对象 (默认为 <code>&#39;pre&#39;</code>)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fire before component updates</span></span><br><span class="line">watchEffect(</span><br><span class="line">  () =&gt; &#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    flush: <span class="string">&#x27;post&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h4 id="停止侦听"><a href="#停止侦听" class="headerlink" title="停止侦听"></a>停止侦听</h4><p><code>watchEffect</code>会返回一个用于停止这个监听的函数。</p><ul><li><p>这个函数可以在组件被卸载时隐式调用：当 <code>watchEffect</code> 在组件的 setup() 函数或生命周期钩子被调用时，侦听器会被链接到该组件的生命周期，并在组件卸载时自动停止</p></li><li><p>也可以在<code>setup</code>函数里被显式调用，以停止侦听</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> stop = watchEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// later</span></span><br><span class="line">stop()</span><br></pre></td></tr></table></figure></li></ul><h4 id="清除副作用"><a href="#清除副作用" class="headerlink" title="清除副作用"></a>清除副作用</h4><p>有时副作用函数会执行一些异步的副作用，比如当数据变化时发送一次异步请求，如果请求过程中数据发生多次变化，那么就得多次发送请求。这样不仅浪费资源，还会因无法判断异步请求的执行顺序增加不确定性。</p><p>为了解决这个问题，<code>watchEffect</code>副作用传入的函数接收一个<code>onInvalidate</code>函数作为入参，用来注册清理失效时的回调。</p><p><code>onInvalidate</code>只作用于异步函数，并且只有在如下两种情况下才会被调用：</p><ul><li>副作用即将重新执行时</li><li>侦听器被停止 (如果在 <code>setup()</code> 或生命周期钩子函数中使用了 <code>watchEffect</code>，则在组件卸载时)</li></ul><p>我的理解中对异步副作用的清除就相当于<strong>函数防抖</strong>，执行这一次的副作用时，清理上一次的异步副作用，使得之前挂起的异步操作无效。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">watchEffect(<span class="function"><span class="params">onInvalidate</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 异步api调用，返回一个操作对象</span></span><br><span class="line">  <span class="keyword">const</span> token = performAsyncOperation(id.value)</span><br><span class="line">  onInvalidate(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 取消异步api的调用。</span></span><br><span class="line">    token.cancel()</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>Vue3 之所以是通过传入一个函数去注册失效回调，而不是从回调返回它，是因为返回值对于异步错误处理很重要。</p><p>在执行数据请求时，副作用函数往往是一个异步函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> data = ref(<span class="literal">null</span>)</span><br><span class="line">watchEffect(<span class="keyword">async</span> onInvalidate =&gt; &#123;</span><br><span class="line">  onInvalidate(<span class="function">() =&gt;</span> &#123;...&#125;) <span class="comment">// 在Promise解析之前注册清除函数</span></span><br><span class="line">  data.value = <span class="keyword">await</span> fetchData(props.id)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="watchEffect和watch的区别"><a href="#watchEffect和watch的区别" class="headerlink" title="watchEffect和watch的区别"></a>watchEffect和watch的区别</h3><ul><li> <code>watchEffect</code> 不需要指定监听的属性，他会自动的收集依赖， 只要我们回调中引用到了 响应式的属性， 那么当这些属性变更的时候，这个回调都会执行，而 <code>watch</code> 只能监听指定的属性而做出变更(v3开始可以同时指定多个)。</li><li><code>watch</code> 访问侦听状态变化前后的值。</li><li><code>watch</code>可以懒执行回调：<code> watchEffect</code> 如果存在，组件初始化的时候就会执行一次用以收集依赖（与<code>computed</code>同理），而后收集到的依赖发生变化，这个回调才会再次执行，而 watch 不需要，因为他一开始就指定了依赖。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>生命周期钩子：onMounted / onUpdated </li><li><code>v-for</code>中绑定<code>ref</code></li><li>watchEffect的使用（注意其副作用的刷新时机）</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>官方文档：<a href="https://vue3js.cn/docs/zh/guide/reactivity-computed-watchers.html#watcheffect">https://vue3js.cn/docs/zh/guide/reactivity-computed-watchers.html#watcheffect</a></p><p><a href="https://www.jianshu.com/p/a8fdf52d0bcf">https://www.jianshu.com/p/a8fdf52d0bcf</a></p><p><a href="https://segmentfault.com/a/1190000023669309">https://segmentfault.com/a/1190000023669309</a></p>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
          <category> Vue3 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> 造轮子 </tag>
            
            <tag> Vue3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue3造轮子（三）-Dialog组件</title>
      <link href="2021/03/07/Vue3-3-dialog/"/>
      <url>2021/03/07/Vue3-3-dialog/</url>
      
        <content type="html"><![CDATA[<h2 id="效果预览"><a href="#效果预览" class="headerlink" title="效果预览"></a>效果预览</h2><p><img src="/images/vue3-dialog/dialog.png"></p><p><a href="https://github.com/wuyangqin/xing-ui-v3">代码链接</a></p><p><a href="https://github.com/wuyangqin/xing-ui-v3/commits/aa06d1bddb7c8c922ad912cd66722a764e4eaccb">提交历史</a></p><h2 id="API设计"><a href="#API设计" class="headerlink" title="API设计"></a>API设计</h2><h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><ul><li>点击后弹出  – v-model:visible</li><li>有遮罩层 overlay，可控制点击遮罩层是否关闭 – closeOnClickOverlay</li><li>有 close 按钮</li><li>有标题，支持自定义标题 – title / slot=”title” </li><li>有内容 ，支持自定义内容 – content / slot=”content”</li><li>有 确认 / 取消 按钮，同时支持确认 / 取消事件 – onConfirm / onCancel</li><li>支持异步关闭</li><li>支持组件式调用，也支持函数式调用 – 动态挂载组件</li><li>可以指定挂载节点 – getContainer</li></ul><h3 id="用户怎么用该组件"><a href="#用户怎么用该组件" class="headerlink" title="用户怎么用该组件"></a>用户怎么用该组件</h3><p><strong>组件调用</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">x-dialog</span> </span></span><br><span class="line"><span class="tag">  <span class="attr">visible</span></span></span><br><span class="line"><span class="tag">  <span class="attr">title</span>=<span class="string">&quot;标题&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">content</span>=<span class="string">&quot;内容太&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">:onConfirm</span>=<span class="string">&quot;fn1&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">:onCancel</span>=<span class="string">&quot;fn2&quot;</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">x-ialog</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>函数式调用</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">setup() =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> showDialog = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      openDialog(&#123;</span><br><span class="line">        title: <span class="string">&#x27;标题&#x27;</span>,</span><br><span class="line">        content: <span class="string">&#x27;嗨 小星星&#x27;</span>,</span><br><span class="line">        onConfirm:<span class="function">() =&gt;</span> &#123;&#125;,</span><br><span class="line">        onCancel:<span class="function">() =&gt;</span> &#123;&#125;,</span><br><span class="line">        closeOnClickOverlay: <span class="literal">false</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123; showDialog &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Vue3笔记"><a href="#Vue3笔记" class="headerlink" title="Vue3笔记"></a>Vue3笔记</h2><h3 id="Teleport"><a href="#Teleport" class="headerlink" title="Teleport"></a>Teleport</h3><p><a href="https://vue3js.cn/docs/zh/guide/teleport.html">参考文档</a></p><p><code>Dialog</code>组件使用<code>fixed</code>定位，如果将其嵌套在某个组件内部，很可能会产生嵌套组件定位层级问题，处理起来会比较麻烦。因此，需要将模板渲染的位置与组件逻辑剥离开来。<code>vue3</code>提供了一个非常方便的新特性——<code>teloport</code>，可以理解为传送门，允许我们控制在 DOM 中哪个父节点下呈现 HTML。</p><h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><p><code>teleport</code>接受两个属性：</p><p><strong>to - string</strong></p><p>以<code>Dialog</code>组件为例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Teleport</span> <span class="attr">to</span>=<span class="string">&quot;#app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;xx-dialog-overlay&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;onClickOverlay&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;xx-dialog-wrapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;xx-dialog&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">header</span> <span class="attr">:class</span>=<span class="string">&quot;&#123; &#x27;title&#x27;: title || $slots.title &#125;&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>=<span class="string">&quot;$slots.title&quot;</span> <span class="attr">class</span>=<span class="string">&quot;title-slot&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;title&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-else</span>&gt;</span>&#123;&#123; title &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;xx-dialog-close&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;close&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">main</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">slot</span> <span class="attr">v-if</span>=<span class="string">&quot;$slots.content&quot;</span> <span class="attr">name</span>=<span class="string">&quot;content&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else</span>&gt;</span>&#123;&#123; content &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">footer</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">x-button</span> <span class="attr">size</span>=<span class="string">&quot;small&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;onCancel&quot;</span>&gt;</span>取消<span class="tag">&lt;/<span class="name">x-button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">x-button</span> <span class="attr">size</span>=<span class="string">&quot;small&quot;</span> <span class="attr">theme</span>=<span class="string">&quot;primary&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;onConfirm&quot;</span>&gt;</span>确定<span class="tag">&lt;/<span class="name">x-button</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Teleport</span>&gt;</span></span><br></pre></td></tr></table></figure><p>效果演示：</p><p><img src="/images/vue3-dialog/teleport.png"></p><p>可以看到通过<code>to</code>属性，指定该组件挂载到了<code>&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</code>中。</p><p><strong>注意</strong>：</p><ul><li><p><code>to</code>属性传入的值必须是有效的查询选择器或 HTMLElement</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 正确 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">teleport</span> <span class="attr">to</span>=<span class="string">&quot;#some-id&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">teleport</span> <span class="attr">to</span>=<span class="string">&quot;.some-class&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">teleport</span> <span class="attr">to</span>=<span class="string">&quot;[data-teleport]&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 错误 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">teleport</span> <span class="attr">to</span>=<span class="string">&quot;h1&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">teleport</span> <span class="attr">to</span>=<span class="string">&quot;some-string&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>默认挂载到第一个选择的元素</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span>container1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span>container2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">teleport</span> <span class="attr">to</span>=<span class="string">&quot;.container&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">teleport</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><p><img src="/images/vue3-dialog/teleport1.png" alt="挂载到第一个.container"></p><p><strong>disabled-boolean</strong></p><p>此可选属性可用于禁用 <code>teleport</code> 的功能，这意味着其插槽内容将不会移动到任何位置，而是在您在周围父组件中指定了 <code>teleport</code> 的位置渲染。</p><h4 id="与-Vue-components-一起使用"><a href="#与-Vue-components-一起使用" class="headerlink" title="与 Vue components 一起使用"></a>与 Vue components 一起使用</h4><p>如果 <code>teleport</code> 包含 Vue 组件，则它仍将是 <code>teleport</code> 父组件的逻辑子组件，仍接收父组件传来的属性。</p><h3 id="h-渲染函数"><a href="#h-渲染函数" class="headerlink" title="h() 渲染函数"></a>h() 渲染函数</h3><p>如果想要实现函数式调用<code>Dialog</code>组件，则需要通过渲染函数实现该组件的动态挂载。<code>Vue2</code>中的<a href="https://vuejs.bootcss.com/guide/render-function.html">渲染函数</a>为<code>createElement()</code>，而在<code>Vue3</code>中被称为<code>h()</code>，用于创建虚拟节点（更准确地命名为<code>createVNode()</code>，出于频繁使用和简洁的目的，改为了<code>h()</code>）。</p><p><code>h()</code>同样接受三个参数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @returns &#123;VNode&#125;</span></span><br><span class="line">h(</span><br><span class="line">  <span class="comment">// &#123;String | Object | Function | null&#125; tag</span></span><br><span class="line">  <span class="comment">// 一个 HTML 标签名、一个组件、一个异步组件，或者 null。</span></span><br><span class="line">  <span class="comment">// 使用 null 将会渲染一个注释。</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// 必需的。</span></span><br><span class="line">  <span class="string">&#x27;div&#x27;</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// &#123;Object&#125; props</span></span><br><span class="line">  <span class="comment">// 与 attribute、prop 和事件相对应的对象。</span></span><br><span class="line">  <span class="comment">// 我们会在模板中使用。</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// 可选的。</span></span><br><span class="line">  &#123;&#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// &#123;String | Array | Object&#125; children</span></span><br><span class="line">  <span class="comment">// 子 VNodes, 使用 `h()` 构建,</span></span><br><span class="line">  <span class="comment">// 或使用字符串获取 &quot;文本 Vnode&quot; 或者</span></span><br><span class="line">  <span class="comment">// 有 slot 的对象。</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// 可选的。</span></span><br><span class="line">  [</span><br><span class="line">    <span class="string">&#x27;Some text comes first.&#x27;</span>,</span><br><span class="line">    h(<span class="string">&#x27;h1&#x27;</span>, <span class="string">&#x27;A headline&#x27;</span>),</span><br><span class="line">    h(MyComponent, &#123;</span><br><span class="line">      someProp: <span class="string">&#x27;foobar&#x27;</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>实际应用如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> XDialog <span class="keyword">from</span> <span class="string">&#x27;../Dialog.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; createApp, h &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> openDialog = (&#123;</span><br><span class="line">    title = <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    content = <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    onConfirm = <span class="function">() =&gt;</span> &#123;&#125;,</span><br><span class="line">    onCancel = <span class="function">() =&gt;</span> &#123;&#125;,</span><br><span class="line">    closeOnClickOverlay = <span class="literal">true</span></span><br><span class="line">&#125;) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> div =  <span class="built_in">document</span>.createElement(<span class="string">&#x27;div&#x27;</span>)</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(div)</span><br><span class="line">    <span class="keyword">const</span> close = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        app.unmount()</span><br><span class="line">        div.remove()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> app = createApp(&#123;</span><br><span class="line">        <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> h(</span><br><span class="line">                XDialog,</span><br><span class="line">                &#123;</span><br><span class="line">                    visible: <span class="literal">true</span>,</span><br><span class="line">                    title,</span><br><span class="line">                    content,</span><br><span class="line">                    onConfirm,</span><br><span class="line">                    onCancel,</span><br><span class="line">                    closeOnClickOverlay,</span><br><span class="line">                    <span class="string">&#x27;onUpdate:visible&#x27;</span>:<span class="function">(<span class="params">newVisible</span>) =&gt;</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (!newVisible) &#123;</span><br><span class="line">                            close()</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    app.mount(div)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><code>teleport</code>指定挂载节点</li><li><code>h()</code>动态挂载组件</li></ul>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
          <category> Vue3 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> 造轮子 </tag>
            
            <tag> Vue3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue3造轮子（二）-Button组件</title>
      <link href="2021/02/27/Vue3-2-button/"/>
      <url>2021/02/27/Vue3-2-button/</url>
      
        <content type="html"><![CDATA[<h2 id="效果预览"><a href="#效果预览" class="headerlink" title="效果预览"></a>效果预览</h2><p><img src="/images/vue3-button/button.png"></p><p><a href="https://github.com/wuyangqin/xing-ui-v3">代码链接</a></p><p><a href="https://github.com/wuyangqin/xing-ui-v3/commits/a3eebc79f3ca6affd7c5fc6b87d1e076fe4a82fe">提交历史</a></p><h2 id="API设计"><a href="#API设计" class="headerlink" title="API设计"></a>API设计</h2><h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><ul><li><p>支持button的基本事件 — click, focus,mouseover等 — 属性绑定</p></li><li><p>可以是基础按钮，可以是链接 — theme</p></li><li><p>可以有不同的等级 — level</p></li><li><p>可以改变大小 — size</p></li><li><p>可以禁用 — diabled</p></li><li><p>加载状态 — loading</p></li></ul><h3 id="用户怎么用该组件"><a href="#用户怎么用该组件" class="headerlink" title="用户怎么用该组件"></a>用户怎么用该组件</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">x-button</span> </span></span><br><span class="line"><span class="tag">  @<span class="attr">click</span>=<span class="string">?</span> </span></span><br><span class="line"><span class="tag">  @<span class="attr">focus</span>=<span class="string">?</span> </span></span><br><span class="line"><span class="tag">  @<span class="attr">mouseover</span>=<span class="string">?</span></span></span><br><span class="line"><span class="tag">  <span class="attr">theme</span>=<span class="string">&quot;default or primary or link&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">level</span>=<span class="string">&quot;nomal or info or warning or success or danger&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">size</span>=<span class="string">&quot;mini or small or normal or large&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">disabled</span></span></span><br><span class="line"><span class="tag">  <span class="attr">loading</span></span></span><br><span class="line"><span class="tag">&gt;</span><span class="tag">&lt;/<span class="name">x-button</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Vue3笔记"><a href="#Vue3笔记" class="headerlink" title="Vue3笔记"></a>Vue3笔记</h2><h3 id="属性绑定"><a href="#属性绑定" class="headerlink" title="属性绑定"></a>属性绑定</h3><h4 id="非Prop-属性继承"><a href="#非Prop-属性继承" class="headerlink" title="非Prop 属性继承"></a>非Prop 属性继承</h4><p><a href="https://vue3js.cn/docs/zh/guide/component-attrs.html">参考文档</a></p><ul><li>如果父组件传给子组件的属性，子组件中没有相应 <code>props</code>或 <code>emits</code>定义，则这些属性被称为<strong>非Prop属性</strong></li><li>当组件<strong>返回单个根节点</strong>时，<code>Vue3</code>会默认将所有非 prop属性绑定到子组件的根元素。</li></ul><p>基于此特性，父组件中绑定的事件可以直接传至子组件，因此可以初步实现button组件对事件的支持，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父组件</span></span><br><span class="line">&lt;template&gt; </span><br><span class="line">  &lt;x-button @click=<span class="string">&quot;clickButton&quot;</span></span><br><span class="line">      @focus=<span class="string">&quot;clickButton&quot;</span></span><br><span class="line">      @mouseover=<span class="string">&quot;clickButton&quot;</span>&gt;</span><br><span class="line">    点我</span><br><span class="line">  &lt;/x-button&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script lang=<span class="string">&quot;ts&quot;</span>&gt;</span><br><span class="line"><span class="keyword">import</span> XButton <span class="keyword">from</span> <span class="string">&quot;../lib/Button.vue&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  components: &#123; Button &#125;,</span><br><span class="line">  <span class="function"><span class="title">setup</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> clickButton = <span class="function">()=&gt;</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;clickButton&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- button 组件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;x-button-dv&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;x-button&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">slot</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="禁用属性继承"><a href="#禁用属性继承" class="headerlink" title="禁用属性继承"></a>禁用属性继承</h4><p>从上面的代码中，不难发现一个问题——button组件的事件其实应该绑定给<code>&lt;button/&gt;</code>元素而不是其根元素；而事件之外的其他属性需绑定给根元素。解决这些问题的思路如下：</p><ul><li>通过将 <code>inheritAttrs</code> 选项设置为 <code>false</code>，禁用非prop属性的继承</li><li>获取传来的属性，通过<code>v-bind</code>将事件绑定给<code>&lt;button/&gt;</code>元素</li><li>将其余属性绑定给根元素</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;x-button-dv&quot;</span> :size=<span class="string">&quot;size&quot;</span>&gt;</span><br><span class="line">    &lt;button <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;x-button&quot;</span> v-bind=<span class="string">&quot;rest&quot;</span>&gt;</span><br><span class="line">      &lt;slot&gt;&lt;/slot&gt;</span><br><span class="line">    &lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  name: <span class="string">&#x27;x-button&#x27;</span>,</span><br><span class="line">  inheritAttrs: <span class="literal">false</span>,</span><br><span class="line">  setup (props, context) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; size, ...rest &#125; = context.attrs <span class="comment">// 将事件绑定给button，其余属性绑定给外层div</span></span><br><span class="line">    <span class="keyword">return</span> &#123; size, rest &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="props-V-S-attrs"><a href="#props-V-S-attrs" class="headerlink" title="props  V.S.  attrs"></a>props  V.S.  attrs</h3><ul><li>props要先声明才能取值，attrs不用声明</li><li>当props声明了属性时，该属性不能在attrs里面取到</li><li>props不包含事件，attrs包含</li><li>当属性的数据类型为Booalen时，必须要给该属性绑定value，否则attrs中为空字符串</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 父组件</span><br><span class="line"><span class="tag">&lt;<span class="name">x-button</span> <span class="attr">size</span>=<span class="string">&quot;small&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">disabled</span></span></span><br><span class="line"><span class="tag">              <span class="attr">:multiple</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">              @<span class="attr">click</span>=<span class="string">&quot;clickButton&quot;</span></span></span><br><span class="line"><span class="tag">              @<span class="attr">mouseenter</span>=<span class="string">&quot;clickButton&quot;</span></span></span><br><span class="line"><span class="tag">              @<span class="attr">focus</span>=<span class="string">&quot;clickButton&quot;</span>&gt;</span></span><br><span class="line">      点我</span><br><span class="line"><span class="tag">&lt;/<span class="name">x-button</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 子组件</span></span><br><span class="line"> props: &#123;</span><br><span class="line">    size: &#123;</span><br><span class="line">      type: <span class="built_in">String</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  setup (props, context) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(    &#123;...props&#125;)</span><br><span class="line">    <span class="built_in">console</span>.log(    &#123;...context.attrs&#125;)</span><br><span class="line">    <span class="keyword">const</span> &#123; size, ...rest &#125; = context.attrs <span class="comment">// 将事件绑定给button，其余属性绑定给外层div</span></span><br><span class="line">    <span class="keyword">return</span> &#123; size, rest &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><img src="/images/vue3-button/props-vs-attrs.png" alt="输出结果"></p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h3 id="css影响最小原则"><a href="#css影响最小原则" class="headerlink" title="css影响最小原则"></a>css影响最小原则</h3><p><strong>CSS 绝对不能影响库使用者</strong></p><ul><li>尽量不使用 scoped<br>因为 data-v-xxx 中的 xxx 每次运行可能不同<br>必须输出稳定不变的 class 选择器，方便使用者覆盖</li><li>必须加前缀，不容易被使用者覆盖</li></ul><h3 id="css写loading动画"><a href="#css写loading动画" class="headerlink" title="css写loading动画"></a>css写loading动画</h3><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.xx-loadingIndicator</span>&#123;</span><br><span class="line"> <span class="variable">$main-theme-color</span>: <span class="number">#87dfd6</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">14px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">14px</span>;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">  <span class="attribute">margin-right</span>: <span class="number">4px</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">14px</span>;</span><br><span class="line">  <span class="attribute">border-color</span>: <span class="variable">$main-theme-color</span> <span class="variable">$main-theme-color</span> <span class="variable">$main-theme-color</span> transparent;</span><br><span class="line">  <span class="attribute">border-style</span>: solid;</span><br><span class="line">  <span class="attribute">border-width</span>: <span class="number">2px</span>;</span><br><span class="line">  <span class="attribute">animation</span>: xx-spin <span class="number">1s</span> infinite linear;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@keyframes</span> xx-spin &#123;</span><br><span class="line">  0% &#123; <span class="attribute">transform</span>: rotate(<span class="number">0deg</span>) &#125;</span><br><span class="line">  <span class="number">100%</span> &#123; transform: rotate(<span class="number">360deg</span>) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>Vue 属性继承<ul><li>默认属性传给根元素</li><li><code>inheritAttrs: false</code> 禁用属性继承</li><li><code>v-bind=&quot;$attrs&quot;</code>绑定属性， <code> context.attrs</code>获取属性</li></ul></li><li>props V.S. attrs</li></ul>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
          <category> Vue3 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> 造轮子 </tag>
            
            <tag> Vue3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue3造轮子（一）-Switch组件</title>
      <link href="2021/02/20/Vue3-1-switch/"/>
      <url>2021/02/20/Vue3-1-switch/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><a href="%5Bwuyangqin.github.io/xing-ui/%5D(https://wuyangqin.github.io/xing-ui/)">UI造轮子Vue2版</a>官网初步部署上线了，决定暂时告一段落，先学习Vue3的造轮子课。这个阶段的学习总结以Vue3新特性为主，以及这其中踩到的坑，节奏依然是写轮子–&gt;看文档–&gt;写总结，然后会将Vue3的学习笔记做一个整体的总结。加油~(ง •_•)ง</p><h2 id="效果预览"><a href="#效果预览" class="headerlink" title="效果预览"></a>效果预览</h2><p><img src="/images/vue3-switch/switch.gif"></p><p><a href="https://github.com/wuyangqin/xing-ui-v3">代码链接</a></p><p><a href="https://github.com/wuyangqin/xing-ui-v3/commits/d221188bd2dc987cb169aeb66fe5a060b2283a02">提交历史</a></p><h2 id="API设计"><a href="#API设计" class="headerlink" title="API设计"></a>API设计</h2><h3 id="value"><a href="#value" class="headerlink" title="value"></a>value</h3><ul><li>组件内部，用<code>value</code>控制开关的开与关 — <code>computed</code>计算属性控制开关状态的样式</li><li><code>value</code>应该是由父组件传入 — 父组件用<code>ref</code>声明变量，子组件用<code>props</code>接受值（父子通信）</li><li>当父组件调用该子组件时，应该知道当前子组件的状态 — <code>v-model</code>实现父子双向绑定</li></ul><h3 id="disable-loading"><a href="#disable-loading" class="headerlink" title="disable loading"></a>disable loading</h3><ul><li>disable 禁用属性，loading，加载状态，处在该状态下开关无法进行操作</li><li>样式类型的属性，因此也是使用<code>computed</code>计算属性控制样式</li></ul><h2 id="Vue3笔记"><a href="#Vue3笔记" class="headerlink" title="Vue3笔记"></a>Vue3笔记</h2><h3 id="组件注册"><a href="#组件注册" class="headerlink" title="组件注册"></a>组件注册</h3><h4 id="Vue2-x"><a href="#Vue2-x" class="headerlink" title="Vue2.x"></a>Vue2.x</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  render: <span class="function"><span class="params">h</span> =&gt;</span> h(App)</span><br><span class="line">&#125;).$mount(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure><h4 id="Vue3-x"><a href="#Vue3-x" class="headerlink" title="Vue3.x"></a>Vue3.x</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line"><span class="keyword">const</span> app = createApp(App)</span><br><span class="line">app.mount(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="Composition-API（组合式API）"><a href="#Composition-API（组合式API）" class="headerlink" title="Composition API（组合式API）"></a>Composition API（组合式API）</h3><h4 id="为什么"><a href="#为什么" class="headerlink" title="为什么"></a>为什么</h4><p>总结一下就是：<strong>避免逻辑关注点过于碎片化，</strong>提高代码的可读性和可维护性。</p><p>在Vue2中，我们如果要实现一个需求，那么这些逻辑会被分散在data、methods、computed等各个<code>Options API</code>，而在Vue3中，我们可以将同一个需求的各个逻辑模块整合起来，放在<code>Composition API</code>。如果用颜色来区分各个逻辑块，那么下图可以直观地展示这种区别。</p><p><img src="/images/vue3-switch/composition.png"></p><h4 id="setup"><a href="#setup" class="headerlink" title="setup"></a>setup</h4><ul><li><p>一个接受<code>props</code>和<code>context</code>的函数，从<code>setup</code>返回的内容都将暴露给组件的其余部分</p><ul><li>props: 传入组件的属性:setup 中接收的<code>props</code>是响应式的， 当传入新的 props 时，会及时被更新。由于是响应式的， 所以<strong>不可以使用 ES6 解构</strong>，解构会消除它的响应式</li><li>context：暴露<code>attrs</code>、<code>slots</code>、<code>emit</code>这三个组件的property</li></ul></li><li><p>在<strong>创建组件之前</strong>，初始化 props 之后调用执行，因此<code>setup</code>中无法访问组件实例<code>this</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="title">beforeCreate</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;beforeCreate&#x27;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">created</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;created&#x27;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;mounted&#x27;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  setup (props, context) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;setup&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// setup</span></span><br><span class="line"><span class="comment">// beforeCreate</span></span><br><span class="line"><span class="comment">// created</span></span><br><span class="line"><span class="comment">// mounted</span></span><br></pre></td></tr></table></figure></li><li><p>我刚开始使用<code>setup</code>的时候，也产生过疑惑，这样不是将所有的代码都塞到<code>setup</code>里面，让它变得非常庞大臃肿吗？官方文档给出了解决方案——将各逻辑模块分别提取到独立的<a href="https://vue3js.cn/docs/zh/guide/composition-api-introduction.html#%E7%8B%AC%E7%AB%8B%E7%9A%84-computed-%E5%B1%9E%E6%80%A7"><strong>组合式函数</strong></a></p></li></ul><h4 id="带ref-的响应式变量-响应式引用"><a href="#带ref-的响应式变量-响应式引用" class="headerlink" title="带ref 的响应式变量 (响应式引用)"></a>带ref 的响应式变量 (响应式引用)</h4><ul><li><p>在setup中直接声明的变量是非响应式的，因此需引入<code>ref</code>函数</p></li><li><p><code>ref</code>接受参数并返回一个<a href="https://juejin.cn/post/6844904041357508615">包装对象</a>，包装对象具有 <code>value</code> property ，可使用该 property 访问或更改响应式变量的值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ref &#125; form <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> visible = ref(<span class="literal">false</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(visible) <span class="comment">// &#123; value: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(visible.value) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">visible.value = <span class="literal">true</span></span><br><span class="line"><span class="built_in">console</span>.log(visible.value) <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><a href="https://juejin.cn/post/6844904042242523144#heading-4">为什么要返回一个包装对象</a>?</p><p>提供一个让我们能够在函数之间以引用的方式传递任意类型值的容器。这个容器可以在封装了逻辑的组合函数中将状态以引用的方式传回给组件。组件负责展示（追踪依赖），组合函数负责管理状态（触发更新）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">setup</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> valueA = useLogicA() <span class="comment">// valueA 可能被 useLogicA() 内部的代码修改从而触发更新</span></span><br><span class="line">  <span class="keyword">const</span> valueB = useLogicB()</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    valueA,</span><br><span class="line">    valueB</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 作者：摸鱼架构师</span></span><br><span class="line"><span class="comment">// 链接：https://juejin.cn/post/6844904042242523144</span></span><br><span class="line"><span class="comment">// 来源：掘金</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="toRefs"><a href="#toRefs" class="headerlink" title="toRefs"></a>toRefs</h4><p>解构的同时保持<code>props</code>内部变量的响应式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; toRefs &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="function"><span class="title">setup</span>(<span class="params">props</span>)</span>&#123;</span><br><span class="line"><span class="keyword">const</span> &#123; user &#125; = toRefs(props)</span><br><span class="line">    consloe.log(user.value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="computed属性"><a href="#computed属性" class="headerlink" title="computed属性"></a>computed属性</h4><ul><li><p>使用从 Vue 导入的 <code>computed</code> 函数在 Vue 组件外部创建计算属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ref, computed &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> counter = ref(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">const</span> twiceTheCounter = computed(<span class="function">() =&gt;</span> counter.value * <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">counter.value++</span><br><span class="line"><span class="built_in">console</span>.log(counter.value) <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(twiceTheCounter.value) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure></li><li><p><code>computed</code>函数返回一个<em>只读</em>的<strong>响应式引用</strong>，由一个作为 <code>computed</code> 的第一个参数传递的 getter 类回调输出。为了访问新创建的计算变量的 <strong>value</strong>，我们需要像使用 <code>ref</code> 一样使用 <code>.value</code> property。</p></li></ul><h3 id="v-model"><a href="#v-model" class="headerlink" title="v-model"></a>v-model</h3><h4 id="使用-value和-input进行父子组件双向通信"><a href="#使用-value和-input进行父子组件双向通信" class="headerlink" title="使用:value和@input进行父子组件双向通信"></a>使用:value和@input进行父子组件双向通信</h4><p>其实<code>v-model</code>就是一个语法糖，我们可以先拆解出来它具体做了什么，以switch组件为例：</p><p><img src="/images/vue3-switch/props-emit.png"></p><p>父组件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;x-<span class="keyword">switch</span> :value=<span class="string">&quot;checked&quot;</span> @input=<span class="string">&quot;visible = $event&quot;</span>&gt;&lt;/x-<span class="keyword">switch</span>&gt;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"> setup () &#123;</span><br><span class="line">   <span class="keyword">const</span> checked = ref(<span class="literal">false</span>)</span><br><span class="line">   <span class="keyword">const</span> toggle = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">     checked.value = !checked.value</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> &#123; checked, toggle &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>子组件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line">setup (props, context) &#123;</span><br><span class="line">  <span class="keyword">const</span> toggle = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    context.emit(<span class="string">&#x27;input&#x27;</span>, !props.value)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123; toggle &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Vue2的v-model"><a href="#Vue2的v-model" class="headerlink" title="Vue2的v-model"></a>Vue2的v-model</h4><ul><li><p>Vue2.x中，在组件上使用 <code>v-model</code> 相当于绑定 <code>value</code> prop 和 <code>input</code> 事件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">x-switch</span> <span class="attr">v-model</span>=<span class="string">&quot;checked&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 简写: --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">x-switch</span> <span class="attr">:value</span>=<span class="string">&quot;checked&quot;</span> @<span class="attr">input</span>=<span class="string">&quot;checked = $event&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>如果想更改绑定的属性名，或绑定多个变量，可使用<code>.sync</code></p><p>子组件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.$emit(<span class="string">&#x27;update:value&#x27;</span>, newValue)</span><br></pre></td></tr></table></figure><p>父组件：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">x-switch</span> <span class="attr">:value.sync</span>=<span class="string">&quot;checked&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="Vue3的v-model"><a href="#Vue3的v-model" class="headerlink" title="Vue3的v-model"></a>Vue3的v-model</h4><ul><li>属性名任意，假设为 x</li><li>事件名必须为 <code>&#39;update:x&#39;</code></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">x-switch</span> <span class="attr">v-model:value</span>=<span class="string">&quot;checked&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 简写: --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">x-switch</span> <span class="attr">:value</span>=<span class="string">&quot;checked&quot;</span> @<span class="attr">update:value</span>=<span class="string">&quot;checked = $event&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>使用 ref 创建内部数据</li><li>使用 :value 和 @input 让父子组件进行交流(组件通信)</li><li>使用 v-model</li><li>Vue 2 和 Vue 3 的区别<ul><li>新 <code>v-model:prop</code> 代替以前的 <code>v-model</code> 和 <code>.sync</code></li><li>新增 context.emit，与 this.$emit 作用相同</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
          <category> Vue3 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> 造轮子 </tag>
            
            <tag> Vue3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue 封装一个移动端拖拽组件和自定义指令</title>
      <link href="2021/01/20/Vue-drag-comp/"/>
      <url>2021/01/20/Vue-drag-comp/</url>
      
        <content type="html"><![CDATA[<p>公司项目的上一个版本中，应用内的消息提醒有一个这样的小气泡：</p><p><img src="/images/vue/drag-1.png"></p><p>之前这个气泡是固定的，但在新版本的开发中，固定的气泡会阻碍一些按钮的交互，因此跟产品沟通了一下，决定为这个气泡加入沿屏幕右侧纵向拖拽的功能。</p><p>在网上找了几个觉得都不太满意。于是结合在网上找到的，尝试自己封装一个公共组件，便于以后类似功能的拓展。</p><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><ul><li><p>可拖拽</p></li><li><p>边界检测</p><p>默认为屏幕宽高；如有父级元素则为父级元素宽高；可自行设置边界</p></li><li><p>可设置拖拽方向  –&gt; 横轴移动 / 纵轴移动 / 自由拖拽，默认为自由拖拽</p></li><li><p>点击浮动的气泡触发下一步操作</p></li></ul><h3 id="怎么使用？"><a href="#怎么使用？" class="headerlink" title="怎么使用？"></a>怎么使用？</h3><p>一开始想的是组件式使用，后来，鉴于拖拽都是直接操作DOM 元素，且组件式使用不够灵活，采用了自定义指令的方式。</p><p>但还是将两种使用方式都记录下来：</p><ul><li><p>组件式</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">v-drag</span> <span class="attr">:x-move</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">    需拖拽元素</span><br><span class="line"><span class="tag">&lt;/<span class="name">v-drag</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>自定义指令</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-drag</span> @<span class="attr">click</span>=<span class="string">&quot;fn&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-drag</span>=<span class="string">&quot;options&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">options:&#123;</span><br><span class="line">    XMove: <span class="literal">false</span>,</span><br><span class="line">    YMove: <span class="literal">true</span></span><br><span class="line">    maxWidth: <span class="number">300</span>,</span><br><span class="line">    maxHeight: <span class="number">100</span>,</span><br><span class="line">    minWidth: <span class="number">10</span>,</span><br><span class="line">    minHeight: <span class="number">10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="效果预览"><a href="#效果预览" class="headerlink" title="效果预览"></a>效果预览</h2><p><img src="/images/vue/drag-2.gif"></p><ul><li><p>自定义指令</p><p><a href="https://codepen.io/wuyangqin/pen/abpMovz">详见链接</a></p></li><li><p>组件式调用</p><p><a href="https://codepen.io/wuyangqin/pen/LYxqdeJ">详见链接</a></p></li></ul><p><strong>注</strong>：</p><p>为方便演示，均监听了鼠标事件，用于移动端时可将鼠标事件的监听注释。</p><p>组件式只能设置拖拽方向</p><h2 id="遇到的问题及解决"><a href="#遇到的问题及解决" class="headerlink" title="遇到的问题及解决"></a>遇到的问题及解决</h2><h3 id="滑动时警告问题"><a href="#滑动时警告问题" class="headerlink" title="滑动时警告问题"></a>滑动时警告问题</h3><p>将touch事件绑定给document后，发现拖拽元素时页面也会滚动，并且出现了如下警告</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[Intervention] Unable to preventDefault inside passive event listener due to target being treated as passive. </span><br><span class="line">See https:&#x2F;&#x2F;www.chromestatus.com&#x2F;features&#x2F;5093566007214080</span><br></pre></td></tr></table></figure><p>Google了一下后知道，原来移动端chrome出了一个新特性<code>Passive Event Listeners</code>，不会调用 preventDefault 函数来阻止事件的默认行为，这样浏览器就能快速生成事件，从而提升页面性能。</p><h4 id="解决办法1："><a href="#解决办法1：" class="headerlink" title="解决办法1："></a>解决办法1：</h4><p>在touch的事件监听方法上绑定第三个参数{ passive: false }，<br> 通过传递 passive 为 false 来明确告诉浏览器：事件处理程序调用 preventDefault 来阻止默认滑动行为。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">elem.addEventListener(</span><br><span class="line">  <span class="string">&#x27;touchstart&#x27;</span>,</span><br><span class="line">  fn,</span><br><span class="line">  &#123; <span class="attr">passive</span>: <span class="literal">false</span> &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h4 id="解决办法2："><a href="#解决办法2：" class="headerlink" title="解决办法2："></a>解决办法2：</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* &#123; touch-action: pan-y; &#125; </span><br><span class="line">// 使用全局样式样式去掉</span><br></pre></td></tr></table></figure><h2 id="最终代码"><a href="#最终代码" class="headerlink" title="最终代码"></a>最终代码</h2><h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 拖拽滑动 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;defaultDragComp&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">ref</span>=<span class="string">&quot;defaultDragComp&quot;</span></span></span><br><span class="line"><span class="tag">       @<span class="attr">click.stop</span>=<span class="string">&quot;goNext&quot;</span></span></span><br><span class="line"><span class="tag">       @<span class="attr">touchstart</span>=<span class="string">&quot;down&quot;</span></span></span><br><span class="line"><span class="tag">  &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">  name: <span class="string">&#x27;drag-comp&#x27;</span>,</span></span><br><span class="line">  props: &#123;</span><br><span class="line">    XMove: &#123;</span><br><span class="line"><span class="javascript">      type: <span class="built_in">Boolean</span>,</span></span><br><span class="line"><span class="javascript">      <span class="keyword">default</span>: <span class="literal">true</span></span></span><br><span class="line"><span class="javascript">    &#125;, <span class="comment">// 是否能在x轴拖拽</span></span></span><br><span class="line">    YMove: &#123;</span><br><span class="line"><span class="javascript">      type: <span class="built_in">Boolean</span>,</span></span><br><span class="line"><span class="javascript">      <span class="keyword">default</span>: <span class="literal">true</span></span></span><br><span class="line"><span class="javascript">    &#125; <span class="comment">// 是否能在y轴拖拽</span></span></span><br><span class="line">  &#125;,</span><br><span class="line"><span class="javascript">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">      defaultDragComp: <span class="literal">null</span>,</span></span><br><span class="line"><span class="javascript">      dragging: <span class="literal">false</span>,</span></span><br><span class="line">      position: &#123;x: 0, y: 0&#125;,</span><br><span class="line">      maxW: 0,</span><br><span class="line">      maxH: 0</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"><span class="javascript">  <span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">this</span>.initDragComp()</span></span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line"><span class="javascript">    <span class="comment">// 获取拖拽元素及边界</span></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">initDragComp</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> defaultDragComp = <span class="built_in">this</span>.$refs.defaultDragComp</span></span><br><span class="line"><span class="javascript">      <span class="built_in">this</span>.defaultDragComp = defaultDragComp</span></span><br><span class="line"><span class="javascript">      <span class="built_in">this</span>.maxW = <span class="built_in">window</span>.innerWidth - defaultDragComp.offsetWidth</span></span><br><span class="line"><span class="javascript">      <span class="built_in">this</span>.maxH = <span class="built_in">window</span>.innerHeight - defaultDragComp.offsetHeight</span></span><br><span class="line">    &#125;,</span><br><span class="line"><span class="javascript">    <span class="comment">// 点击拖拽元素的下一步操作</span></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">goNext</span>(<span class="params">done</span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">this</span>.$emit(<span class="string">&#x27;goNext&#x27;</span>)</span></span><br><span class="line">    &#125;,</span><br><span class="line"><span class="javascript">    <span class="comment">// 监听鼠标手指触碰事件，记录初始位置</span></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">down</span>(<span class="params">event</span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">document</span>.addEventListener(<span class="string">&#x27;touchmove&#x27;</span>, <span class="built_in">this</span>.move)</span></span><br><span class="line"><span class="javascript">      <span class="built_in">document</span>.addEventListener(<span class="string">&#x27;touchend&#x27;</span>, <span class="built_in">this</span>.end)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> &#123;offsetLeft, offsetTop&#125; = <span class="built_in">this</span>.defaultDragComp</span></span><br><span class="line"><span class="javascript">      <span class="built_in">this</span>.dragging = <span class="literal">true</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> touch</span></span><br><span class="line">      if (event.touches) &#123;</span><br><span class="line">        touch = event.touches[0]</span><br><span class="line"><span class="javascript">      &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line">        touch = event</span><br><span class="line">      &#125;</span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> &#123;clientX, clientY&#125; = touch</span></span><br><span class="line"><span class="javascript">      <span class="built_in">this</span>.position = &#123;</span></span><br><span class="line">        x: clientX - offsetLeft,</span><br><span class="line">        y: clientY - offsetTop</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"><span class="javascript">    <span class="comment">// 监听document手指移动事件，更新元素位置，边界检测</span></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">move</span>(<span class="params">event</span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> &#123;</span></span><br><span class="line">        defaultDragComp,</span><br><span class="line">        dragging,</span><br><span class="line">        XMove,</span><br><span class="line">        YMove,</span><br><span class="line">        position,</span><br><span class="line">        maxW,</span><br><span class="line">        maxH</span><br><span class="line"><span class="javascript">      &#125; = <span class="built_in">this</span></span></span><br><span class="line">      event.preventDefault()</span><br><span class="line"></span><br><span class="line">      if (dragging) &#123;</span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> touch</span></span><br><span class="line">        if (event.touches) &#123;</span><br><span class="line">          touch = event.touches[0]</span><br><span class="line"><span class="javascript">        &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line">          touch = event</span><br><span class="line">        &#125;</span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> &#123;clientX, clientY&#125; = touch</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> deltaX = clientX - position.x</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> deltaY = clientY - position.y</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="comment">// 边界检测</span></span></span><br><span class="line">        if (deltaX &lt; 0) &#123;</span><br><span class="line">          deltaX = 0</span><br><span class="line"><span class="javascript">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (deltaX &gt; maxW) &#123;</span></span><br><span class="line">          deltaX = maxW</span><br><span class="line">        &#125;</span><br><span class="line">        if (deltaY &lt; 0) &#123;</span><br><span class="line">          deltaY = 0</span><br><span class="line"><span class="javascript">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (deltaY &gt; maxH) &#123;</span></span><br><span class="line">          deltaY = maxH</span><br><span class="line">        &#125;</span><br><span class="line">        if (XMove) &#123;</span><br><span class="line"><span class="javascript">          defaultDragComp.style.left = deltaX + <span class="string">&#x27;px&#x27;</span></span></span><br><span class="line">        &#125;</span><br><span class="line">        if (YMove) &#123;</span><br><span class="line"><span class="javascript">          defaultDragComp.style.top = deltaY + <span class="string">&#x27;px&#x27;</span></span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"><span class="javascript">    <span class="comment">// 手指释放时，移除全局监听事件</span></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">end</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">this</span>.dragging = <span class="literal">false</span></span></span><br><span class="line"><span class="javascript">      <span class="built_in">document</span>.removeEventListener(<span class="string">&#x27;touchmove&#x27;</span>, <span class="built_in">this</span>.move)</span></span><br><span class="line"><span class="javascript">      <span class="built_in">document</span>.removeEventListener(<span class="string">&#x27;touchend&#x27;</span>, <span class="built_in">this</span>.end)</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">lang</span>=<span class="string">&quot;less&quot;</span>&gt;</span></span><br><span class="line">#defaultDragComp &#123;</span><br><span class="line"><span class="css">  <span class="attribute">position</span>: fixed;</span></span><br><span class="line"><span class="css">  <span class="attribute">z-index</span>: <span class="number">1010</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a>自定义指令</h3><p><strong>drag.js</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="function"><span class="title">inserted</span>(<span class="params">el, bindings</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> dragging = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">let</span> position = &#123;<span class="attr">x</span>: <span class="number">0</span>, <span class="attr">y</span>: <span class="number">0</span>&#125;</span><br><span class="line">    el.addEventListener(<span class="string">&#x27;touchstart&#x27;</span>, down, &#123;<span class="attr">passive</span>: <span class="literal">false</span>&#125;)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取配置项，设置默认值</span></span><br><span class="line">    <span class="keyword">let</span> options = bindings.value</span><br><span class="line">    <span class="keyword">let</span> &#123;XMove, YMove&#125; = options</span><br><span class="line">    <span class="keyword">let</span> canXMove = XMove || <span class="literal">true</span></span><br><span class="line">    <span class="keyword">let</span> canYMove = YMove || <span class="literal">true</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取边界</span></span><br><span class="line">    <span class="keyword">let</span> &#123;maxW, maxH, minW, minH&#125; = getBoundary(el, options)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断是否存在移动端touch事件，获取事件对象</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getEvent</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">let</span> touch</span><br><span class="line">      <span class="keyword">if</span> (event.touches) &#123;</span><br><span class="line">        touch = event.touches[<span class="number">0</span>]</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        touch = event</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> touch</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 手指触碰</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">down</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">document</span>.addEventListener(<span class="string">&#x27;touchmove&#x27;</span>, move, &#123;<span class="attr">passive</span>: <span class="literal">false</span>&#125;)</span><br><span class="line">      <span class="built_in">document</span>.addEventListener(<span class="string">&#x27;touchend&#x27;</span>, end, &#123;<span class="attr">passive</span>: <span class="literal">false</span>&#125;)</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">let</span> &#123;offsetLeft, offsetTop&#125; = el</span><br><span class="line">      dragging = <span class="literal">true</span></span><br><span class="line">      <span class="keyword">let</span> touch = getEvent(event)</span><br><span class="line">      <span class="keyword">let</span> &#123;clientX, clientY&#125; = touch</span><br><span class="line">      position = &#123;</span><br><span class="line">        x: clientX - offsetLeft,</span><br><span class="line">        y: clientY - offsetTop</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 手指移动</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">move</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span> (dragging) &#123;</span><br><span class="line">        <span class="keyword">let</span> touch = getEvent(event)</span><br><span class="line">        event.preventDefault()</span><br><span class="line">        <span class="keyword">let</span> &#123;clientX, clientY&#125; = touch</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> deltaX = clientX - position.x</span><br><span class="line">        <span class="keyword">let</span> deltaY = clientY - position.y</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (deltaX &lt; minW) &#123;</span><br><span class="line">          deltaX = minW</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (deltaX &gt; maxW) &#123;</span><br><span class="line">          deltaX = maxW</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (deltaY &lt; minH) &#123;</span><br><span class="line">          deltaY = minH</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (deltaY &gt; maxH) &#123;</span><br><span class="line">          deltaY = maxH</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (canXMove) &#123;</span><br><span class="line">          el.style.left = deltaX + <span class="string">&#x27;px&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (canYMove) &#123;</span><br><span class="line">          el.style.top = deltaY + <span class="string">&#x27;px&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 手指释放</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">end</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      dragging = <span class="literal">false</span></span><br><span class="line">      <span class="built_in">document</span>.removeEventListener(<span class="string">&#x27;touchmove&#x27;</span>, move)</span><br><span class="line">      <span class="built_in">document</span>.removeEventListener(<span class="string">&#x27;touchend&#x27;</span>, end)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取边界</span></span><br><span class="line"><span class="comment">// 优先级：自定义设置 &gt; 带定位父级元素  &gt; 屏幕</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getBoundary</span>(<span class="params">el, options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> parentNode = el.offsetParent</span><br><span class="line">  <span class="keyword">let</span> &#123;maxWidth, maxHeight, minWidth, minHeight&#125; = options</span><br><span class="line">  <span class="keyword">let</span> deltaW = <span class="built_in">window</span>.innerWidth</span><br><span class="line">  <span class="keyword">let</span> deltaH = <span class="built_in">window</span>.innerHeight</span><br><span class="line">  <span class="keyword">let</span> minW = minWidth || <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> minH = minHeight || <span class="number">0</span></span><br><span class="line">  <span class="keyword">if</span> (parentNode) &#123;</span><br><span class="line">    <span class="keyword">let</span> &#123;width, height&#125; = parentNode.getBoundingClientRect()</span><br><span class="line">    deltaW = width</span><br><span class="line">    deltaH = height</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> maxW = (maxWidth || deltaW) - el.offsetWidth</span><br><span class="line">  <span class="keyword">let</span> maxH = (maxHeight || deltaH) - el.offsetHeight</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    maxW,</span><br><span class="line">    maxH,</span><br><span class="line">    minW,</span><br><span class="line">    minH,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>main.js</strong></p><p>注册全局指令</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入指令</span></span><br><span class="line"><span class="keyword">import</span> vDrag <span class="keyword">from</span> <span class="string">&#x27;@/directive/drag&#x27;</span></span><br><span class="line"></span><br><span class="line">Vue.directive(<span class="string">&#x27;drag&#x27;</span>, vDrag)</span><br></pre></td></tr></table></figure><p><strong>使用</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;parent&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;drag-comp&quot;</span> <span class="attr">v-drag</span>=<span class="string">&quot;options&quot;</span> @<span class="attr">click.stop</span>=<span class="string">&quot;fn1&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;drag-comp fixed&quot;</span> <span class="attr">v-drag</span>=<span class="string">&quot;options&quot;</span>&gt;</span>fixed<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line">      options: &#123;</span><br><span class="line"><span class="javascript">        <span class="comment">// maxWidth:200</span></span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">fn1</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">&#x27;click&#x27;</span>);</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">lang</span>=<span class="string">&quot;less&quot;</span>&gt;</span></span><br><span class="line">.parent &#123;</span><br><span class="line"><span class="css">  <span class="attribute">position</span>: relative;</span></span><br><span class="line"><span class="css">  <span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css">  <span class="attribute">height</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="css">  <span class="attribute">border</span>: <span class="number">1px</span> solid deepskyblue;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.drag-comp &#123;</span><br><span class="line"><span class="css">  <span class="attribute">position</span>: fixed;</span></span><br><span class="line"><span class="css">  <span class="attribute">z-index</span>: <span class="number">99</span>;</span></span><br><span class="line"><span class="css">  <span class="attribute">right</span>: <span class="number">10px</span>;</span></span><br><span class="line"><span class="css">  <span class="attribute">bottom</span>: <span class="number">85px</span>;</span></span><br><span class="line"><span class="css">  <span class="attribute">width</span>: <span class="number">40px</span>;</span></span><br><span class="line"><span class="css">  <span class="attribute">height</span>: <span class="number">40px</span>;</span></span><br><span class="line"><span class="css">  <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">2px</span> <span class="number">4px</span> <span class="number">#ddd</span>;</span></span><br><span class="line"><span class="css">  <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span></span><br><span class="line"><span class="css">  <span class="attribute">color</span>: <span class="number">#fff</span>;</span></span><br><span class="line"><span class="css">  <span class="attribute">font-size</span>: <span class="number">12px</span>;</span></span><br><span class="line"><span class="css">  <span class="attribute">display</span>: flex;</span></span><br><span class="line"><span class="css">  <span class="attribute">align-items</span>: center;</span></span><br><span class="line"><span class="css">  <span class="attribute">justify-content</span>: center;</span></span><br><span class="line"><span class="css">  <span class="attribute">background-color</span>: deepskyblue;</span></span><br><span class="line"></span><br><span class="line">  &amp;.fixed &#123;</span><br><span class="line"><span class="css">    <span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="css">    <span class="attribute">background</span>: skyblue;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
          <category> Vue2 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> Vue2 </tag>
            
            <tag> 移动端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack基础</title>
      <link href="2021/01/10/webpack-note/"/>
      <url>2021/01/10/webpack-note/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是webpack？"><a href="#什么是webpack？" class="headerlink" title="什么是webpack？"></a>什么是webpack？</h2><ul><li>官方解释： At its core, webpack is a static module bundler for modern JavaScript applications.</li><li>翻译： 从本质上来讲，webpack 是一个现代的JavaScript应用的静态<strong>模块打包</strong>工具</li><li>可以分析各个模块的依赖关系，自动打包成我们常见的静态文件如：js css jpg等</li><li>打包的三个阶段<ul><li>初始化读取与合并配置参数加载需要编译的文件</li><li>根据自己设置的格式进行编译</li><li>将编译好的代码输出到指定位置</li></ul></li></ul><p><a href="https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=3378498490,2105022646&fm=26&gp=0.jpg"><img src="https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=3378498490,2105022646&fm=26&gp=0.jpg"></a></p><h3 id="前端模块化"><a href="#前端模块化" class="headerlink" title="前端模块化"></a>前端模块化</h3><ul><li>目前使用前端模块化的一些方案：AMD、CMD、CommonJS、ES6。</li><li>在ES6之前，我们要想进行模块化开发，就必须借助于其他的工具，让我们可以进行模块化开发。</li><li>并且在通过模块化开发完成了项目后，还需要处理模块间的各种依赖，并且将其进行整合打包。</li><li>而webpack其中一个<strong>核心就是让我们可能进行模块化开发，并且会帮助我们处理模块间的依赖关系</strong>。</li><li>而且不仅仅是JavaScript文件，我们的CSS、图片、json文件等等在webpack中都可以被当做模块来使用</li><li>这就是webpack中模块化的概念。</li></ul><h3 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h3><ul><li>就是将webpack中的各种资源模块进行打包合并成一个或多个包(Bundle)。</li><li>并且在打包的过程中，还可以对资源进行处理，比如压缩图片，将scss转成css，将ES6语法转成ES5语法，将TypeScript转成JavaScript等等操作。</li><li>但是打包的操作似乎grunt/gulp也可以帮助我们完成，它们有什么不同呢？</li></ul><h3 id="和grunt-gulp的对比"><a href="#和grunt-gulp的对比" class="headerlink" title="和grunt/gulp的对比"></a>和grunt/gulp的对比</h3><ul><li><p>grunt/gulp的核心是</p><p>Task</p><ul><li>我们可以配置一系列的task，并且定义task要处理的事务（例如ES6、ts转化，图片压缩，scss转成css）</li><li>之后让grunt/gulp来依次执行这些task，而且让整个流程自动化。</li><li>所以grunt/gulp也被称为前端自动化任务管理工具。</li></ul></li><li><p>什么时候用grunt/gulp呢？</p><ul><li>如果你的工程模块依赖非常简单，甚至是没有用到模块化的概念。</li><li>只需要进行简单的合并、压缩，就使用grunt/gulp即可。</li><li>但是如果整个项目使用了模块化管理，而且相互依赖非常强，我们就可以使用更加强大的webpack了。</li></ul></li><li><p>grunt/gulp和webpack有什么不同呢？</p><ul><li>grunt/gulp更加强调的是前端流程的自动化，模块化不是它的核心。</li><li>webpack更加强调模块化开发管理，而文件压缩合并、预处理等功能，是他附带的功能。</li></ul></li></ul><h2 id="webpack的安装"><a href="#webpack的安装" class="headerlink" title="webpack的安装"></a>webpack的安装</h2><ul><li><p>安装webpack首先需要安装Node.js，Node.js自带了软件包管理工具npm<br>查看自己的node版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node -vCopy</span><br></pre></td></tr></table></figure></li><li><p>全局安装webpack(这里我先指定版本号3.6.0，因为vue cli2依赖该版本)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install webpack@3.6.0 -gCopy</span><br></pre></td></tr></table></figure></li><li><p>局部安装 webpack</p></li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 在对应目录下执行该命令</span></span><br><span class="line">npm install webpack@3.6.0  --save-dev</span><br><span class="line"><span class="comment">##  因为webpack我们项目打包后不需要使用 ， 所以它只是我们开发时的一个工具  --save-dev  是开发时依赖Copy</span></span><br></pre></td></tr></table></figure><ul><li><p>全局安装和局部安装的区别</p><ul><li>在终端直接执行的webpack命令，使用的是全局安装的webpack</li><li>当在packag.json中定义了scripts时，其中包含了webpack命令，那么使用的是局部webpack</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">   &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;,</span><br><span class="line">   &quot;bulid&quot;: &quot;webpack&quot;</span><br><span class="line"> &#125;,Copy</span><br></pre></td></tr></table></figure></li></ul><h2 id="webpack的配置"><a href="#webpack的配置" class="headerlink" title="webpack的配置"></a>webpack的配置</h2><h3 id="入口和出口"><a href="#入口和出口" class="headerlink" title="入口和出口"></a>入口和出口</h3><ul><li>如果每次使用webpack的命令都需要写上入口和出口作为参数，就很麻烦。</li><li>我们要创建一个 webpack.config.js文件</li></ul><p><img src="/images/webpack/entry.png"></p><h3 id="如何使用局部安装的webpack"><a href="#如何使用局部安装的webpack" class="headerlink" title="如何使用局部安装的webpack"></a>如何使用局部安装的webpack</h3><h4 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h4><ul><li>第一步：项目中需要安装自己局部的webpack<ul><li>这里我们让局部安装 <a href="mailto:webpack@3.6.0">webpack@3.6.0</a> </li><li>Vue CLI3中已经升级到webpack4，但是它将配置文件隐藏了起来，所以查看起来不是很方便。</li></ul></li><li>第二步，通过node_modules/.bin/webpack启动webpack打包</li></ul><h4 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h4><p>但是，每次执行都敲这么一长串很不方便:</p><ul><li>我们可以在package.json的scripts中定义自己的执行脚本。</li></ul><p>package.json中的scripts的脚本在执行时，会按照一定的顺序寻找命令对应的位置。</p><ul><li>首先，会寻找本地的node_modules/.bin路径中对应的命令。</li><li>如果没有找到，会去全局的环境变量中寻找。</li></ul><p><img src="/images/webpack/package.png"></p><h2 id="4-webpack-loader加载器"><a href="#4-webpack-loader加载器" class="headerlink" title="4 webpack-loader加载器"></a>4 webpack-loader加载器</h2><blockquote><p><strong>loader是webpack中一个非常核心的概念。</strong></p></blockquote><ul><li><p>webpack用来做什么呢？</p><ul><li><p>在我们之前的实例中，我们主要是用webpack来处理我们写的js代码，并且webpack会自动处理js之间相关的依赖。</p></li><li><p>但是，在开发中我们不仅仅有基本的js代码处理，我们也需要加载css、图片，也包括一些高级的将ES6转成ES5代码，将</p><p>TypeScript转成ES5代码，将scss、less转成css，将.jsx、.vue文件转成js文件等等。</p></li><li><p>对于webpack本身的能力来说，对于这些转化是不支持的。</p></li><li><p>那怎么办呢？给webpack扩展对应的loader就可以啦。</p></li></ul></li><li><p>loader使用过程：</p><ul><li>步骤一：通过npm安装需要使用的loader</li><li>步骤二：在webpack.config.js中的modules关键字下进行配置</li></ul></li><li><p>大部分loader我们都可以在webpack的官网中找到，并且学习对应的用法。</p></li></ul><p>webpack.config.js 文件如下： <strong>如何配置 响应的 loader 在module内</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">&#x27;./src/main.js&#x27;</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">&#x27;dist&#x27;</span>),</span><br><span class="line">    filename: <span class="string">&#x27;bundle.js&#x27;</span>,</span><br><span class="line">    publicPath: <span class="string">&#x27;dist/&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [&#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        <span class="comment">// style-loader 负责将样式添加到DOM中</span></span><br><span class="line">        <span class="comment">// css-loader 负责将css文件进行加载</span></span><br><span class="line">        <span class="comment">// 注意：  使用多个 loader时， webpack是从右向左解析的</span></span><br><span class="line">        use: [<span class="string">&#x27;style-loader&#x27;</span>, <span class="string">&#x27;css-loader&#x27;</span>]</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(png|jpg|gif)$/</span>,</span><br><span class="line">        use: [&#123;</span><br><span class="line">          loader: <span class="string">&#x27;file-loader&#x27;</span>,</span><br><span class="line">          options: &#123;</span><br><span class="line">            name: <span class="string">&#x27;img/[name].[hash:8].[ext]&#x27;</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;]</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">        exclude: <span class="regexp">/(node_modules|bower_components)/</span>,</span><br><span class="line">        use: &#123;</span><br><span class="line">          loader: <span class="string">&#x27;babel-loader&#x27;</span>,</span><br><span class="line">          options: &#123;</span><br><span class="line">            presets: [<span class="string">&#x27;es2015&#x27;</span>]</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;Copy</span><br></pre></td></tr></table></figure><h2 id="5-webpack插件-plugin"><a href="#5-webpack插件-plugin" class="headerlink" title="5 webpack插件 plugin"></a>5 webpack插件 plugin</h2><h3 id="plugin是什么？"><a href="#plugin是什么？" class="headerlink" title="plugin是什么？"></a>plugin是什么？</h3><ul><li>plugin是插件的意思，通常是用于对某个现有的架构进行扩展。</li><li>webpack中的插件，就是对webpack现有功能的各种扩展，比如打包优化，文件压缩等等。</li></ul><h3 id="loader和plugin区别"><a href="#loader和plugin区别" class="headerlink" title="loader和plugin区别"></a>loader和plugin区别</h3><ul><li>loader主要用于转换某些类型的模块，它是一个转换器。</li><li>plugin是插件，它是对webpack本身的扩展，是一个扩展器。</li></ul><h3 id="plugin的使用过程："><a href="#plugin的使用过程：" class="headerlink" title="plugin的使用过程："></a>plugin的使用过程：</h3><ul><li>步骤一：通过npm安装需要使用的plugins(某些webpack已经内置的插件不需要安装)</li><li>步骤二：在webpack.config.js中的plugins中配置插件。</li></ul>]]></content>
      
      
      <categories>
          
          <category> webpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS正则兼容，报错safari invalid regular expression</title>
      <link href="2020/11/30/keng-ios-reg/"/>
      <url>2020/11/30/keng-ios-reg/</url>
      
        <content type="html"><![CDATA[<h3 id="情景复现"><a href="#情景复现" class="headerlink" title="情景复现"></a>情景复现</h3><p>今天在项目中发现Android显示正常，而iOS显示一片空白，用safari打开后发现报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Invalid regular expression: invalid group specifier name</span><br></pre></td></tr></table></figure><p><img src="/images/ios-reg-error.png"></p><h3 id="排查原因及解决"><a href="#排查原因及解决" class="headerlink" title="排查原因及解决"></a>排查原因及解决</h3><p>谷歌后得到<a href="https://stackoverflow.com/questions/51568821/works-in-chrome-but-breaks-in-safari-invalid-regular-expression-invalid-group">stackoverflow</a>的答案：safari，firefox的正则表达式不支持<code>?&lt;=、?&lt;!、?!、?= </code>等表达，而我在项目中为了根据特定字符截取字符串中间部分，使用了如下正则：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> matchNameReg = <span class="regexp">/(?&lt;=name=&quot;).*?(?=&quot;)/</span></span><br></pre></td></tr></table></figure><p>因此只能采取替代方案，用<code>split</code>分割字符串。修改后报错解决。</p>]]></content>
      
      
      <categories>
          
          <category> 踩坑记 </category>
          
          <category> 移动端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 移动端 </tag>
            
            <tag> 踩坑记 </tag>
            
            <tag> 正则 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简单实现一个ajax</title>
      <link href="2020/10/05/js-ajax/"/>
      <url>2020/10/05/js-ajax/</url>
      
        <content type="html"><![CDATA[<h2 id="ajax"><a href="#ajax" class="headerlink" title="ajax"></a>ajax</h2><h2 id="什么是Ajax"><a href="#什么是Ajax" class="headerlink" title="什么是Ajax"></a>什么是Ajax</h2><p>ajax:前后端分离后，都是后台通过接口返回数据，前端需要通过接口访问数据。那么这个通过接口访问后台数据的过程就叫ajax。</p><blockquote><p>简单来说就是用 JS 向服务端发起一个请求，并获取服务器返回的内容</p></blockquote><p>参考 ：<a href="https://zhuanlan.zhihu.com/p/22564745">https://zhuanlan.zhihu.com/p/22564745</a></p><h2 id="ajax-步骤"><a href="#ajax-步骤" class="headerlink" title="ajax 步骤"></a>ajax 步骤</h2><ol><li>买手机  –&gt;  创建ajax对象</li><li>拨号  –&gt;   链接url接口地址  设置传输数据方法：get和post<ul><li>get和post的区别：一般get获取数据，而post发送数据<ul><li>get发送数据最多为2kb，post理论上没有限制，但不同浏览器有不同限制</li><li>get发送数据在url地址 post在消息内发送数据</li><li>get有缓存，相对不安全；post没有，相对安全</li><li>get方式和post方式传递的数据在服务端获取也不相同</li></ul></li></ul></li><li>说 –&gt; 发送数据参数</li><li>听  –&gt;  接收返回的数据，并渲染到html页面</li></ol><h2 id="简单实现"><a href="#简单实现" class="headerlink" title="简单实现"></a>简单实现</h2><h3 id="get"><a href="#get" class="headerlink" title="get"></a>get</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> oAjax = <span class="keyword">new</span> XMLHttpRequest();<span class="comment">//创建ajax对象</span></span><br><span class="line">oAjax.open(<span class="string">&#x27;get&#x27;</span>,<span class="string">&#x27;arr.txt&#x27;</span>);<span class="comment">//链接地址  设置请求的方法</span></span><br><span class="line">oAjax.send();<span class="comment">//发送数据参数</span></span><br><span class="line">oAjax.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="comment">//页面注册事件更新</span></span><br><span class="line">    <span class="keyword">if</span>(oAjax.readyState == <span class="number">4</span>)&#123;<span class="comment">//ajax执行状态码</span></span><br><span class="line">        <span class="keyword">if</span>(oAjax.status == <span class="number">200</span>)&#123;<span class="comment">//http状态码 200 说明一切ok</span></span><br><span class="line">            <span class="keyword">var</span> data = oAjax.responseText;</span><br><span class="line">            <span class="comment">// 异步获取数据  后续操作  都得写在这  可以封装函数传参 将data传出去</span></span><br><span class="line">            <span class="comment">// console.log(typeof data);//string</span></span><br><span class="line">            <span class="comment">// 将具有js格式的字符串 转换为js代码或数据</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="post"><a href="#post" class="headerlink" title="post"></a>post</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> oAjax = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">oAjax.open(<span class="string">&#x27;post&#x27;</span>,<span class="string">&#x27;aaa.txt&#x27;</span>);</span><br><span class="line">oAjax.setRequestHeader(<span class="string">&#x27;Content-type&#x27;</span>,<span class="string">&#x27;application/x-www-form-urlencoded&#x27;</span>);<span class="comment">//设置请求头传输数据的类型编码方式</span></span><br><span class="line"></span><br><span class="line">oAjax.send();</span><br><span class="line"></span><br><span class="line">oAjax.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="comment">//页面注册事件更新</span></span><br><span class="line">    <span class="keyword">if</span>(oAjax.readyState == <span class="number">4</span>)&#123;<span class="comment">//ajax执行状态码</span></span><br><span class="line">        <span class="keyword">if</span>(oAjax.status == <span class="number">200</span>)&#123;<span class="comment">//http状态码 200 说明一切ok</span></span><br><span class="line">            <span class="built_in">console</span>.log(oAjax.responseText);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="readyState-ajax执行状态码"><a href="#readyState-ajax执行状态码" class="headerlink" title="readyState ajax执行状态码"></a>readyState ajax执行状态码</h3><ul><li>0：初始化   还没有调用open()方法</li><li>1： 载入  已调用send()方法，正在发送请求</li><li>2： 载入完成   send()方法完成，已收到全部相应内容</li><li>3： 解析  正在解析相应内容</li><li>4： 完成   响应内容解析完成，可以在客户端使用了</li></ul><h3 id="status-http状态码"><a href="#status-http状态码" class="headerlink" title="status http状态码"></a>status http状态码</h3><ul><li>100-199 Infromationale responses 接受请求</li><li>200-299 Successful responses 成功响应</li><li>300-399 Redirects 重定向</li><li>400-499 Client errors 客户端错误</li><li>500-599 Sever errors 服务端错误</li></ul><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">//封装一个ajax请求</span></span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">ajax</span>(<span class="params">options</span>)</span>&#123;</span><br><span class="line">     <span class="comment">//创建XMLHttpRequest对象</span></span><br><span class="line">     <span class="keyword">var</span> request = <span class="built_in">window</span>.XMLHttpRequest ? <span class="keyword">new</span> XMLHttpRequest : <span class="keyword">new</span> ActiveXObject()</span><br><span class="line"></span><br><span class="line">     <span class="comment">//初始化参数的内容</span></span><br><span class="line">     options = options ||&#123;&#125;</span><br><span class="line">     options.type = (options.type ||<span class="string">&#x27;GET&#x27;</span>).toUpperCase()</span><br><span class="line">     options.dataType = options.dataType || <span class="string">&#x27;json&#x27;</span></span><br><span class="line">     <span class="keyword">var</span> params = options.data</span><br><span class="line"></span><br><span class="line">     <span class="comment">//发送请求</span></span><br><span class="line">     <span class="keyword">if</span>(options.type == <span class="string">&#x27;GET&#x27;</span>)&#123;</span><br><span class="line">       request.open(<span class="string">&#x27;GET&#x27;</span>,options.url + <span class="string">&#x27;?&#x27;</span> + params,<span class="literal">true</span>)</span><br><span class="line">       request.send(<span class="literal">null</span>)</span><br><span class="line">     &#125;<span class="keyword">else</span> <span class="keyword">if</span>(options.type == <span class="string">&#x27;POST&#x27;</span>)&#123;</span><br><span class="line">       request.open(<span class="string">&#x27;POST&#x27;</span>,options.url,<span class="literal">true</span>)</span><br><span class="line">       request.setRequestHeader(<span class="string">&#x27;Content-Type&#x27;</span>, <span class="string">&quot;application/x-www-form-urlencoded&quot;</span>)<span class="comment">//规定输出为键值对的形式</span></span><br><span class="line">       request.send(params)</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//接收请求</span></span><br><span class="line">     request.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(request.readyState == <span class="number">4</span>)&#123;</span><br><span class="line">         <span class="keyword">var</span> status = request.status</span><br><span class="line">         <span class="keyword">if</span> (status &gt;= <span class="number">200</span> &amp;&amp; status &lt; <span class="number">300</span>)&#123;</span><br><span class="line">           options.success &amp;&amp; options.success(request.responseText,request.responseXML)</span><br><span class="line">         &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">           options.fail &amp;&amp;options.fail(status)</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;  </span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line">   ajax(&#123;</span><br><span class="line">     type: <span class="string">&#x27;post&#x27;</span>,</span><br><span class="line">     dataType: <span class="string">&#x27;json&#x27;</span>,</span><br><span class="line">     data: &#123;&#125;,</span><br><span class="line">     url: <span class="string">&#x27;xxx&#x27;</span>,</span><br><span class="line">     success: <span class="function"><span class="keyword">function</span>(<span class="params">text,xml</span>)</span>&#123;<span class="comment">//请求成功后的回调函数</span></span><br><span class="line">       <span class="built_in">console</span>.log(text)</span><br><span class="line">     &#125;,</span><br><span class="line">     fail: <span class="function"><span class="keyword">function</span>(<span class="params">status</span>)</span>&#123;<span class="comment">////请求失败后的回调函数</span></span><br><span class="line">       <span class="built_in">console</span>.log(status)</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> ajax </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图解原型与原型链</title>
      <link href="2020/10/04/js-prototype/"/>
      <url>2020/10/04/js-prototype/</url>
      
        <content type="html"><![CDATA[<h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><ul><li>每个函数都具有一个存储共用的属性和方法的对象  叫  原型对象</li><li>构造函数(类)可以通过<code>prototype</code>这样一个指针来指向该原型对象</li><li>每当实例化一个对象，该对象就有一个默认的属性<code>__proto__</code>，通过该属性来指向该构造函数的原型对象，从而共享原型对象上的属性和方法</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [];</span><br><span class="line"><span class="keyword">var</span> arr2 = [];</span><br><span class="line"><span class="built_in">console</span>.log(arr.sort == arr2.sort) <span class="comment">//true;</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.__proto__ == <span class="built_in">Array</span>.prototype);<span class="comment">//说明对象的__proto__和构造函数的prototype都指向同一个东西--原型对象</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.__proto__.constructor);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.prototype.constructor); <span class="comment">//Array()&#123;[native code]&#125;   Array的构造函数</span></span><br></pre></td></tr></table></figure><p><img src="/images/js/prototype-1.png" alt="原型图示"></p><h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><p>当通过构造函数实例化一个对象后，对象会具有一个__proto__的属性，该属性自动连接到该对象的构造函数的  原型prototype上，这个链式关系就是原型链</p><ul><li>所有构造函数的原型也都有一个 <code> __proto__</code>,除了Object之外的所有原型对象的 <code>__proto__</code>  都指向Object的原型</li><li><code>Object.prototype.__proto__ </code>会指向null</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//原型链</span></span><br><span class="line"><span class="comment">// 通过Array的构造函数 实例化了一个对象 arr</span></span><br><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr.__proto__ == <span class="built_in">Array</span>.prototype);<span class="comment">//arr 中__proto__ 链到了Array.prototype(Array的原型)</span></span><br><span class="line"><span class="built_in">console</span>.log(arr);</span><br><span class="line"><span class="built_in">console</span>.log(arr.__proto__.__proto__);<span class="comment">//Array.prototype 也有个 __proto__  链到了谁？链到了Object.prototype（链到构造函数Object的原型）</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.__proto__.__proto__.__proto__);<span class="comment">//Object.prototype 也有个 __proto__ 链到谁？  null 空对象</span></span><br></pre></td></tr></table></figure><p><img src="/images/js/prototype-2.png" alt="原型链图示"></p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DOM事件流及事件委托</title>
      <link href="2020/10/03/js-DOMevent/"/>
      <url>2020/10/03/js-DOMevent/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是DOM"><a href="#什么是DOM" class="headerlink" title="什么是DOM"></a>什么是DOM</h2><blockquote><p>文档对象模型（Document Object Model，简称<strong>DOM</strong>），是W3C组织推荐的处理可扩展标记语言（HTML 或者 XML ）的标准<strong>编程接口</strong></p></blockquote><p><strong>简言之，它会将web页面和脚本或程序语言连接起来。</strong></p><h3 id="html-和DOM的区别"><a href="#html-和DOM的区别" class="headerlink" title="html 和DOM的区别"></a>html 和DOM的区别</h3><ul><li>html就是标签，文档对象在页面中的表示，DOM就是对这些标签形成一个对象模型(DOM树)，规定了这些标签对象的属性和方法</li><li>这些标签/元素在DOM下统称为<strong>节点</strong></li></ul><h2 id="DOM事件流"><a href="#DOM事件流" class="headerlink" title="DOM事件流"></a>DOM事件流</h2><p><strong>事件流</strong>描述的是从页面中接收事件的顺序</p><p><strong>事件</strong>发送时会在元素节点之间按照特定的顺序传播，路径所经过的所有节点都会收到该事件，这个传播过程即<strong>DOM事件流</strong></p><p>比如我们给一个div注册了点击事件：</p><ol><li><p>捕获阶段：从根节点到事件触发的目标节点（<strong>根  –&gt;  事件的目标元素</strong>）</p><p>document  –&gt;  document.Element –&gt; body –&gt;</p></li><li><p>当前目标阶段：事件触发的目标元素（确定目标节点）</p></li><li><p>冒泡阶段：从触发事件的目标节点到根节点（<strong>事件的目标元素  –&gt;  根</strong>）</p></li></ol><p><a href="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0a7520f235ca4f7bbd57a98f024ce46c~tplv-k3u1fbpfcp-watermark.image"><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0a7520f235ca4f7bbd57a98f024ce46c~tplv-k3u1fbpfcp-watermark.image" alt="DOM事件流"></a></p><ul><li><p>事件捕获：</p><p>IE最早提出的，事件开始由最具体的元素接受，然后逐级向上传播到DOM最顶层节点的过程。</p><p><strong>即：从外向内找监听函数</strong></p></li><li><p>事件捕获：</p><p>网景公司最早提出的，由DOM最顶层节点开始，然后逐级向下传播到最具体的元素的过程。</p><p><strong>即：从内向外找监听函数</strong></p></li></ul><p><strong>举个栗子:</strong></p><p>我们向水里扔个石头，首先它会有个下降的过程、这个过程可以理解为捕获过程；之后会产生泡泡，然后漂流在水面上，这个过程相当于事件冒泡。</p><p><strong>代码验证:</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;father&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;son&quot;</span>&gt;</span>son<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> father = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.father&#x27;</span>)</span></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> son = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.son&#x27;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="comment">// 1. 捕获事件，addEventListener第三个参数为true，则处于捕获阶段</span></span></span><br><span class="line"><span class="javascript">  son.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    alert(<span class="string">&#x27;son&#x27;</span>)</span></span><br><span class="line"><span class="javascript">  &#125;, <span class="literal">true</span>)</span></span><br><span class="line"><span class="javascript">  father.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    alert(<span class="string">&#x27;father&#x27;</span>)</span></span><br><span class="line"><span class="javascript">  &#125;, <span class="literal">true</span>) <span class="comment">// 点击儿子，先弹出father，再弹出son</span></span></span><br><span class="line">    </span><br><span class="line"><span class="javascript">  <span class="comment">// 2.冒泡事件，addEventListener第三个参数为false或不写，则处于冒泡阶段</span></span></span><br><span class="line"><span class="javascript">  son.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    alert(<span class="string">&#x27;son&#x27;</span>)</span></span><br><span class="line"><span class="javascript">  &#125;, <span class="literal">false</span>)</span></span><br><span class="line"><span class="javascript">  father.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    alert(<span class="string">&#x27;father&#x27;</span>)</span></span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ul><li>目标元素（目标节点）鼠标去触发了事件的对象元素，不论该元素是否有该事件的对应处理函数</li><li>所有浏览器默认都为冒泡，ie只有冒泡，没有捕获</li><li>如果在一系列事件流中 既有捕获  又有冒泡  那么先捕获再冒泡</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  div.addEventListener(<span class="string">&#x27;click&#x27;</span>,<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;冒泡&#x27;</span>);</span><br><span class="line">  &#125;)   <span class="comment">// 冒泡</span></span><br><span class="line">  div.addEventListener(<span class="string">&#x27;click&#x27;</span>,<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;捕获&#x27;</span>);</span><br><span class="line">  &#125;,<span class="literal">true</span>)   <span class="comment">// 捕获</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 捕获 冒泡（谁先监听谁执行）</span></span><br></pre></td></tr></table></figure><h2 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">eventTarget.onclick = <span class="function"><span class="title">funciton</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line"><span class="comment">// 这个 event 就是事件对象，可以缩写为e</span></span><br><span class="line">&#125;</span><br><span class="line">eventTarget.addEventListener(<span class="string">&#x27;click&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line"><span class="comment">// 这个 event 就是事件对象，可以缩写为e</span></span><br><span class="line">&#125;)Copy</span><br></pre></td></tr></table></figure><p>这个 event 是个形参，系统会自动帮我们设定改为事件对象，不需要传递实参过去。</p><p>当我们注册事件时，event对象就会被系统自动创建，并依次传递给事件监听器（事件处理函数）</p><h3 id="e-target-和-e-currentTarget-的区别"><a href="#e-target-和-e-currentTarget-的区别" class="headerlink" title="e.target 和 e.currentTarget 的区别"></a>e.target 和 e.currentTarget 的区别</h3><ul><li><strong>e.target：</strong> 返回触发事件的对象。 <strong>即用户操作的对象</strong>。（假设：你点击了谁就是谁）</li><li><strong>e.currentTarget :</strong> 程序员监听的元素， <strong>即你绑定了谁就是谁</strong></li><li><strong>this就是e.currentTarget</strong></li></ul><p><strong>打印一下就知道：</strong></p><p><img src="/images/js/dom-event.png"></p><h3 id="阻止冒泡"><a href="#阻止冒泡" class="headerlink" title="阻止冒泡"></a>阻止冒泡</h3><p>方法是   事件对象的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params">ev</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> ev = ev || event;</span><br><span class="line">    alert(<span class="string">&#x27;div1&#x27;</span>);</span><br><span class="line">    <span class="comment">//ev.stopPropagation(); //标准浏览器</span></span><br><span class="line">    <span class="comment">//ev.cancelBubble = true;  //ie</span></span><br><span class="line">    ev.stopPropagation? ev.stopPropagation() : ev.cancelBubble = <span class="literal">true</span>;  <span class="comment">//取消冒泡的兼容写法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="阻止默认事件"><a href="#阻止默认事件" class="headerlink" title="阻止默认事件"></a>阻止默认事件</h3><ul><li><p>事件驱动时阻止默认事件  return false</p></li><li><p>事件绑定时阻止</p><ul><li><p>addEventListener –&gt; ev.preventDefault();</p></li><li><p>attachEvent –&gt; ev.returnValue = false;</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//事件驱动时</span></span><br><span class="line">oA.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//事件绑定时</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params">ev</span>)</span>&#123;</span><br><span class="line">ev.preventDefault? ev.preventDefault() : ev.returnValue = <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h2><p><strong>原理</strong>：<br>不是每个子节点单独设置事件监听器，而是事件监听器设置在其父节点上，然后利用冒泡原理影响设置每个子节点。</p><p><strong>举个场景：</strong><br>比如给ul列表注册点击事件，然后利用事件对象的target来找到当前点击的li，因为点击了li，事件就会冒泡到ul身上，又因为ul有注册事件，就会触发事件监听器。</p><p><strong>作用：</strong> 这样我们只操作了一次DOM， <strong>省内存、可以监听动态元素</strong></p><h3 id="如何监听一个不存在的元素？"><a href="#如何监听一个不存在的元素？" class="headerlink" title="如何监听一个不存在的元素？"></a>如何监听一个不存在的元素？</h3><p>可以利用事件委托，监听父元素即可。</p><p><strong>代码展示：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;test&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> testDiv = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;#test&#x27;</span>)</span></span><br><span class="line"><span class="javascript">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> btn = <span class="built_in">document</span>.createElement(<span class="string">&#x27;button&#x27;</span>)</span></span><br><span class="line"><span class="javascript">    btn.textContent = <span class="string">&#x27;click 1&#x27;</span></span></span><br><span class="line">    testDiv.appendChild(btn)</span><br><span class="line">  &#125;, 1000)</span><br><span class="line"></span><br><span class="line"><span class="javascript">  testDiv.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> t = e.target</span></span><br><span class="line"><span class="javascript">    <span class="keyword">if</span> (t.tagName.toLowerCase() === <span class="string">&#x27;button&#x27;</span>) &#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">&#x27;button 被点击了&#x27;</span>);</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="封装事件委托"><a href="#封装事件委托" class="headerlink" title="封装事件委托"></a>封装事件委托</h2><p><strong>要求：</strong><br>写出一个函数 <code>delegate(&#39;ul&#39;, &#39;click&#39;,&#39;li&#39;,fn)</code> 当用户点击<code>ul</code>的li元素时，调用fn函数。要求用事件委托。</p><h3 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">delegate</span>(<span class="params">element, eventType, selector, fn</span>) </span>&#123;</span><br><span class="line"> element.addEventListener(eventType, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(e.target.tagName.toLowerCase() === selector)&#123;</span><br><span class="line">         fn()</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看起来好像没什么问题，实际上是有bug的：</p><p><strong>如果用户点击的是 li 里面的 span，就没法触发 fn，这显然不对</strong></p><h3 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h3><p>点击 span 后，递归遍历 span 的祖先元素看其中有没有 ul 里面的 li。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">delegate</span>(<span class="params">element, eventType, selector, fn</span>) </span>&#123;</span><br><span class="line">    element.addEventListener(eventType, <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> el = e.target</span><br><span class="line">      <span class="keyword">while</span> (!el.matches(selector)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (element === el) &#123;</span><br><span class="line">          el = <span class="literal">null</span></span><br><span class="line">          <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        el = el.parentNode</span><br><span class="line">      &#125;</span><br><span class="line">      el &amp;&amp; fn.call(el, e, el)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> element</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> DOM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>几种经典的排序算法</title>
      <link href="2020/10/03/js-sort/"/>
      <url>2020/10/03/js-sort/</url>
      
        <content type="html"><![CDATA[<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><h3 id="冒泡排序实现思路"><a href="#冒泡排序实现思路" class="headerlink" title="冒泡排序实现思路"></a>冒泡排序实现思路</h3><p><strong>思路：</strong></p><ol><li>依次比较相邻的数字，如果前一个比后一个大，那么就交换。 即 小数放在前，大数放在后边。</li><li>然后比较第2个数和第3个数，小数在前，大数在后，依次类推则将最大的数滚动到最后边。</li><li>开始第二趟，将第二大的数移动至倒数第二位</li><li>依次类推…..</li></ol><p>最后需要 第 （n-1） 趟就能完成排序。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span> </span>&#123;</span><br><span class="line">  array = []</span><br><span class="line">  <span class="comment">// 用于插入数据</span></span><br><span class="line">  <span class="function"><span class="title">insert</span>(<span class="params">item</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.array.push(item)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">swap</span>(<span class="params">m,n</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> temp = <span class="built_in">this</span>.array[m]</span><br><span class="line">    <span class="built_in">this</span>.array[m] = <span class="built_in">this</span>.array[n]</span><br><span class="line">    <span class="built_in">this</span>.array[n] = temp</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 冒泡排序  （核心代码在这里）</span></span><br><span class="line">  <span class="function"><span class="title">bubblesSort</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.array === <span class="literal">null</span> || <span class="built_in">this</span>.array.length &lt; <span class="number">2</span>) &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">    <span class="comment">// 这里注意需要 length -1 。 原因是 如果是最后一个数会有bug，因为没有 第最后一个数+1的数</span></span><br><span class="line">    <span class="comment">// 也可以理解将 length -1 为 比较的次数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="built_in">this</span>.array.length - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; j; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.array[i] &gt; <span class="built_in">this</span>.array[i + <span class="number">1</span>]) &#123;</span><br><span class="line">          <span class="built_in">this</span>.swap(i, i + <span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> list = <span class="keyword">new</span> ArrayList()</span><br><span class="line">list.insert(<span class="number">12</span>)</span><br><span class="line">list.insert(<span class="number">2</span>)</span><br><span class="line">list.insert(<span class="number">45</span>)</span><br><span class="line">list.insert(<span class="number">123</span>)</span><br><span class="line">list.insert(<span class="number">481</span>)</span><br><span class="line">list.insert(<span class="number">56</span>)</span><br><span class="line"><span class="built_in">console</span>.log(list.array);   <span class="comment">// [ 12, 2, 45, 123, 481, 56 ]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用冒泡排序</span></span><br><span class="line">list.bubblesSort()</span><br><span class="line"><span class="built_in">console</span>.log(list.array);  <span class="comment">// [ 2, 12, 45, 56, 123, 481 ]Copy</span></span><br></pre></td></tr></table></figure><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><h3 id="选择排序实现思路"><a href="#选择排序实现思路" class="headerlink" title="选择排序实现思路"></a>选择排序实现思路</h3><p><strong>思路：</strong></p><p>从第一个数开始与后面的每个数进行比较，找出最小的（默认是升序），然后交换，以此类推，直到排序结束。</p><p><strong>代码实现步骤思路：</strong></p><ol><li>先取出第一个数的下标值为变量 <strong>min</strong> ， 循环遍历数组的长度</li><li>在循环中 用第一个数 分别比较每个数，最后将最小的数的下标值赋值给 <strong>min</strong></li><li>将俩个数交换。这样就实现了第一个数为最小值</li><li>最后在整体套个循环，循环上面的思路即可</li></ol><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span> </span>&#123;</span><br><span class="line">  array = [];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 用于插入数字</span></span><br><span class="line">  <span class="function"><span class="title">insert</span>(<span class="params">item</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.array.push(item);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 交换两个数字</span></span><br><span class="line">  <span class="function"><span class="title">swap</span>(<span class="params">m, n</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> temp = <span class="built_in">this</span>.array[m];</span><br><span class="line">    <span class="built_in">this</span>.array[m] = <span class="built_in">this</span>.array[n];</span><br><span class="line">    <span class="built_in">this</span>.array[n] = temp;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 选择排序</span></span><br><span class="line">  <span class="function"><span class="title">selectSort</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 外部的循环表示 : 从0的位置开始取出数据，直到倒数第二个数的位置，即 length - 2</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; <span class="built_in">this</span>.array.length - <span class="number">1</span>; j++) &#123;</span><br><span class="line">      <span class="keyword">let</span> min = j;</span><br><span class="line">      <span class="comment">// 内部的循环表示：从 min+1位置开始，和后面的数进行比较</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = min + <span class="number">1</span>; i &lt; <span class="built_in">this</span>.array.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.array[min] &gt; <span class="built_in">this</span>.array[i]) &#123;</span><br><span class="line">          min = i;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">this</span>.swap(min, j);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">list.insert(<span class="number">12</span>);</span><br><span class="line">list.insert(<span class="number">2</span>);</span><br><span class="line">list.insert(<span class="number">45</span>);</span><br><span class="line">list.insert(<span class="number">123</span>);</span><br><span class="line">list.insert(<span class="number">481</span>);</span><br><span class="line">list.insert(<span class="number">56</span>);</span><br><span class="line"><span class="built_in">console</span>.log(list.array); <span class="comment">// [ 12, 2, 45, 123, 481, 56 ]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用选择排序</span></span><br><span class="line">list.selectSort();</span><br><span class="line"><span class="built_in">console</span>.log(list.array); <span class="comment">// [ 2, 12, 45, 56, 123, 481 ]Copy</span></span><br></pre></td></tr></table></figure><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><h3 id="插入排序思路"><a href="#插入排序思路" class="headerlink" title="插入排序思路"></a>插入排序思路</h3><p>插入排序是简单排序中效率最好的一种</p><p>插入排序也是学习其他高级排序的基础，比如快速排序，</p><p>插入排序思想的核心 <strong>局部有序（部分有序）</strong></p><p><strong>思路:</strong></p><ul><li>从 i 等于 1 开始变量，拿到当前数 current，与前面的数进行比较</li><li>用while进行循环，如果前面的数大于当前的数，那么就进行交换。</li><li>最好在外部套个循环，直到未排序的数没有了，那么排序就结束。</li></ul><h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span> </span>&#123;</span><br><span class="line">  array = [];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 用于插入数字</span></span><br><span class="line">  <span class="function"><span class="title">insert</span>(<span class="params">item</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.array.push(item);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//  插入排序</span></span><br><span class="line">  <span class="function"><span class="title">insertSort</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; <span class="built_in">this</span>.array.length; i++) &#123;</span><br><span class="line">      <span class="keyword">let</span> j = i; <span class="comment">// 获取当前的下标值，存起来。</span></span><br><span class="line">      <span class="keyword">let</span> current = <span class="built_in">this</span>.array[i];  <span class="comment">// 获取当前的数，存起来</span></span><br><span class="line">    <span class="comment">// 由于不确定循环次数，所有用while</span></span><br><span class="line">      <span class="keyword">while</span> (<span class="built_in">this</span>.array[j - <span class="number">1</span>] &gt; current &amp;&amp; j &gt; <span class="number">0</span>) &#123; </span><br><span class="line">      <span class="comment">// 如果当前数的前一个比当前数大，就交换。</span></span><br><span class="line">        <span class="built_in">this</span>.array[j] = <span class="built_in">this</span>.array[j - <span class="number">1</span>];</span><br><span class="line">        j--;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 将j位置的数，放到当前位置。</span></span><br><span class="line">      <span class="built_in">this</span>.array[j] = current;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">list.insert(<span class="number">12</span>);</span><br><span class="line">list.insert(<span class="number">2</span>);</span><br><span class="line">list.insert(<span class="number">45</span>);</span><br><span class="line">list.insert(<span class="number">123</span>);</span><br><span class="line">list.insert(<span class="number">481</span>);</span><br><span class="line">list.insert(<span class="number">56</span>);</span><br><span class="line"><span class="built_in">console</span>.log(list.array);  <span class="comment">// [ 12, 2, 45, 123, 481, 56 ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用 插入排序</span></span><br><span class="line">list.insertSort();</span><br><span class="line"><span class="built_in">console</span>.log(list.array); <span class="comment">// [ 2, 12, 45, 56, 123, 481 ]Copy</span></span><br></pre></td></tr></table></figure><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><h3 id="快速排序思路"><a href="#快速排序思路" class="headerlink" title="快速排序思路"></a>快速排序思路</h3><p>思路核心: <strong>分而治之</strong>,即分成若个部分，逐个解决</p><p><strong>思路:</strong></p><ul><li>在数组中，选择一个数作为”基准”（pivot）。</li><li>将数组分成<strong>左右</strong>俩部分，小于 <code>基准</code> 的放在<strong>左部分</strong>，大于 <code>基准</code> 的放在<strong>右部分</strong>。</li><li>对”基准”左部分和右部分，不断重复第一步和第二步，直到所有部分只剩下一个元素为止。</li></ul><h3 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span> </span>&#123;</span><br><span class="line">  array = [];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 用于插入数字</span></span><br><span class="line">  <span class="function"><span class="title">insert</span>(<span class="params">item</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.array.push(item);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 快速排序</span></span><br><span class="line">  <span class="function"><span class="title">quickSort</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> quick = <span class="function">(<span class="params">array</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (array.length &lt;= <span class="number">1</span>) &#123;<span class="keyword">return</span> array;&#125;</span><br><span class="line">      <span class="keyword">let</span> pivotIndex = <span class="built_in">Math</span>.floor(array.length / <span class="number">2</span>);</span><br><span class="line">      <span class="keyword">let</span> pivot = array.splice(pivotIndex, <span class="number">1</span>)[<span class="number">0</span>];</span><br><span class="line">      <span class="keyword">let</span> left = [];</span><br><span class="line">      <span class="keyword">let</span> right = [];</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (array[i] &gt; pivot) &#123;</span><br><span class="line">          right.push(array[i]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          left.push(array[i]);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> quick(left).concat([pivot], quick(right));</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.array = quick(<span class="built_in">this</span>.array);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">list.insert(<span class="number">12</span>);</span><br><span class="line">list.insert(<span class="number">2</span>);</span><br><span class="line">list.insert(<span class="number">45</span>);</span><br><span class="line">list.insert(<span class="number">123</span>);</span><br><span class="line">list.insert(<span class="number">481</span>);</span><br><span class="line">list.insert(<span class="number">56</span>);</span><br><span class="line"><span class="built_in">console</span>.log(list.array);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用快速排序</span></span><br><span class="line">list.quickSort();</span><br><span class="line"><span class="built_in">console</span>.log(list.array);</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><h3 id="归并排序思路"><a href="#归并排序思路" class="headerlink" title="归并排序思路"></a>归并排序思路</h3><p>归并排序也是采用 <strong>分而治之</strong> 的思想</p><p>将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。</p><p><strong>思路:</strong><br><img src="/images/js/sort.png"></p><h3 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span> </span>&#123;</span><br><span class="line">  array = [];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 用于插入数字</span></span><br><span class="line">  <span class="function"><span class="title">insert</span>(<span class="params">item</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.array.push(item);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 归并排序</span></span><br><span class="line">  <span class="function"><span class="title">mergeSort</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> mergerSorts = <span class="function">(<span class="params">array</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (array.length === <span class="number">1</span>) &#123;<span class="keyword">return</span> array;&#125;</span><br><span class="line">      <span class="keyword">let</span> left = array.slice(<span class="number">0</span>, <span class="built_in">Math</span>.floor(array.length / <span class="number">2</span>));</span><br><span class="line">      <span class="keyword">let</span> right = array.slice(<span class="built_in">Math</span>.floor(array.length / <span class="number">2</span>));</span><br><span class="line">      <span class="keyword">const</span> merge = <span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (a.length === <span class="number">0</span>) <span class="keyword">return</span> b;</span><br><span class="line">        <span class="keyword">if</span> (b.length === <span class="number">0</span>) <span class="keyword">return</span> a;</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">0</span>] &lt; b[<span class="number">0</span>] ? [a[<span class="number">0</span>]].concat(merge(a.slice(<span class="number">1</span>), b)) : [b[<span class="number">0</span>]].concat(merge(a, b.slice(<span class="number">1</span>)));</span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="keyword">return</span> merge(mergerSorts(left), mergerSorts(right));</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.array = mergerSorts(<span class="built_in">this</span>.array);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">list.insert(<span class="number">12</span>);</span><br><span class="line">list.insert(<span class="number">2</span>);</span><br><span class="line">list.insert(<span class="number">45</span>);</span><br><span class="line">list.insert(<span class="number">123</span>);</span><br><span class="line">list.insert(<span class="number">481</span>);</span><br><span class="line">list.insert(<span class="number">56</span>);</span><br><span class="line"><span class="built_in">console</span>.log(list.array);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用归并排序</span></span><br><span class="line">list.mergeSort();</span><br><span class="line"><span class="built_in">console</span>.log(list.array);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数节流与函数防抖</title>
      <link href="2020/10/02/js-throttle-and-debounce/"/>
      <url>2020/10/02/js-throttle-and-debounce/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是函数节流与函数防抖"><a href="#什么是函数节流与函数防抖" class="headerlink" title="什么是函数节流与函数防抖"></a>什么是函数节流与函数防抖</h2><ul><li>函数节流：指定时间间隔内只会执行一次任务</li><li>函数防抖:   事件被触发n秒后，任务才会执行，如果n秒内再次被触发，则重新计时。</li></ul><p>举个🌰，我的理解中，节流就相当于技能冷却时间，每隔一段时间才能释放一次技能，冷却过程中不管多想放技能都无济于事；而防抖相当于外卖员等一段时间没有新的外卖，就将手上的外卖一起派送一次，期间如果来了新的外卖，就抛弃这次送外卖的想法，重新等待。</p><p>那么为什么需要节流与防抖呢？</p><p>总得来说就是要<strong>限制函数调用的频次，优化性能</strong>。</p><p>js中的一些事件如浏览器的resize、scroll，鼠标的mousemove、mouseover，input输入框的keypress等事件在触发时，会不断地调用绑定在事件上的回调函数，极大地浪费资源，降低前端性能。为了优化体验，就需要对这类事件进行调用次数的限制。</p><h2 id="简单实现"><a href="#简单实现" class="headerlink" title="简单实现"></a>简单实现</h2><h3 id="函数节流-throttle"><a href="#函数节流-throttle" class="headerlink" title="函数节流(throttle)"></a>函数节流(throttle)</h3><p>根据节流的理念，可以先梳理其实现逻辑：</p><p><img src="/images/js/throttle.png"></p><p>代码实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn, delay</span>)</span>&#123;</span><br><span class="line">     <span class="keyword">let</span> canRun = <span class="literal">true</span></span><br><span class="line">     <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(canRun)&#123;</span><br><span class="line">             fn.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>)</span><br><span class="line">             canRun= <span class="literal">false</span></span><br><span class="line">             <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>canRun = <span class="literal">true</span>, delay)</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">const</span> throttled = throttle(<span class="function">()=&gt;</span><span class="built_in">console</span>.log(<span class="string">&#x27;hi&#x27;</span>))</span><br><span class="line"> throttled()</span><br><span class="line"> throttled()</span><br></pre></td></tr></table></figure><h3 id="函数防抖-debounce"><a href="#函数防抖-debounce" class="headerlink" title="函数防抖(debounce)"></a>函数防抖(debounce)</h3><p>防抖的逻辑梳理如下：</p><p><img src="/images/js/debounce.png"></p><p>代码实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, delay</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timerId = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> context = <span class="built_in">this</span>  <span class="comment">// 取debounce执行作用域的this</span></span><br><span class="line">        <span class="keyword">if</span>(timerId)&#123;<span class="built_in">window</span>.clearTimeout(timerId)&#125;</span><br><span class="line">        timerId = <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">            fn.apply(context, <span class="built_in">arguments</span>)</span><br><span class="line">            timerId = <span class="literal">null</span></span><br><span class="line">        &#125;,delay)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> debounced = debounce(<span class="function">()=&gt;</span><span class="built_in">console</span>.log(<span class="string">&#x27;hi&#x27;</span>))</span><br><span class="line">debounced()</span><br><span class="line">debounced()</span><br></pre></td></tr></table></figure><h2 id="区别与应用场景"><a href="#区别与应用场景" class="headerlink" title="区别与应用场景"></a>区别与应用场景</h2><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ul><li>防抖侧重于一段时间内连续触发的事件，只在最后执行一次</li><li>节流侧重于每隔固定的一段时间只执行一次</li></ul><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>节流 throttle</p><ul><li>高频点击提交，表单重复提交</li><li>监听滚动事件，加载更多或滚到底部监听</li></ul><p>防抖 debounce</p><ul><li>搜索联想，只需等用户最后一次输入完再发送请求</li><li>手机、邮箱等验证时，进行输入检测</li><li>resize事件，等用户最后一次调整完浏览器大小再执行</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>函数节流与函数防抖的原理其实非常简单，巧妙地使用 <code>setTimeout</code> 来存放待执行的函数，这样可以很方便的利用 <code>clearTimeout</code> 在合适的时机来清除待执行的函数。</p><p>使用函数节流与函数防抖的目的，就是为了限制函数调用的频次，节约计算机资源。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/6844903669389885453#heading-7">https://juejin.cn/post/6844903669389885453#heading-7</a></p><p><a href="https://juejin.cn/post/6844903926798516237">https://juejin.cn/post/6844903926798516237</a></p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 性能优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>this的值是什么？</title>
      <link href="2020/09/30/js-this/"/>
      <url>2020/09/30/js-this/</url>
      
        <content type="html"><![CDATA[<h2 id="this是什么"><a href="#this是什么" class="headerlink" title="this是什么"></a>this是什么</h2><p>当声明一个函数时，函数会有一个this（指针），声明时this不指向任何对象。当函数被调用时，哪个对象调用了该函数，则该函数的this就指向该对象</p><ul><li><p>当事件驱动时，结果匿名函数的this就指向触发事件的对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">oDiv.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="comment">//this --&gt; oDiv</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>普通命名函数被调用时，函数的this指向全局对象window</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">&#125;</span><br><span class="line">fn(); <span class="comment">//window</span></span><br><span class="line"><span class="comment">// window 是js的全局对象</span></span><br></pre></td></tr></table></figure></li><li><p>对象中定义的函数的this就指向该对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj=&#123;</span><br><span class="line">name: <span class="string">&#x27;John&#x27;</span>,</span><br><span class="line">age:<span class="number">19</span>;</span><br><span class="line">eat:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.eat();<span class="comment">// object</span></span><br><span class="line"><span class="keyword">var</span> fnn = obj.eat;</span><br><span class="line">  fnn();<span class="comment">// this--&gt; window</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="this的值是什么？"><a href="#this的值是什么？" class="headerlink" title="this的值是什么？"></a>this的值是什么？</h2><p><strong>谁调用函数，函数的this就指向谁</strong></p><p><strong>就近原则</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">fn()</span><br><span class="line"><span class="built_in">this</span> =&gt; <span class="built_in">window</span>/<span class="built_in">global</span></span><br><span class="line">obj.fn()</span><br><span class="line"><span class="built_in">this</span> =&gt; obj</span><br><span class="line">fn.call(xx)</span><br><span class="line"><span class="built_in">this</span> =&gt; xx</span><br><span class="line">fn.apply(xx)</span><br><span class="line"><span class="built_in">this</span> =&gt; xx</span><br><span class="line">fn.bind(xx)</span><br><span class="line"><span class="built_in">this</span> =&gt; xx</span><br><span class="line"><span class="keyword">new</span> Fn()</span><br><span class="line"><span class="built_in">this</span> =&gt; 新的对象</span><br><span class="line">fn = <span class="function">()=&gt;</span> &#123;&#125;</span><br><span class="line"><span class="built_in">this</span> =&gt; 外面的 <span class="built_in">this</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> this </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何进行深拷贝?</title>
      <link href="2020/09/30/js-deep-clone/"/>
      <url>2020/09/30/js-deep-clone/</url>
      
        <content type="html"><![CDATA[<h2 id="深拷贝与浅拷贝"><a href="#深拷贝与浅拷贝" class="headerlink" title="深拷贝与浅拷贝"></a>深拷贝与浅拷贝</h2><ul><li><p>浅拷贝：<strong>拷贝引用地址</strong> (只复制指向某个对象的指针，而不复制对象本身，新旧对象共享一块内存)</p><p>由于引用类型(object,array,function)的数据在栈里储存的只是堆地址，所以当对引用类型进行直接赋值时，实际上只复制了地址，复制出来的变量和原来的变量最终都指向同一个对象。当改变其中一个对象的属性值时，两个对象都会发生改变</p></li><li><p>深拷贝：<strong>拷贝实例</strong>  (复制并创建一个一摸一样的对象，不共享内存，修改新对象，旧对象保持不变。)</p></li><li><p>当修改赋值的对象 会影响原对象；修改原对象也会影响赋值的对象</p></li><li><p>如果希望深拷贝，想到了使用for in的方式，但for in有自身的问题</p><ul><li><p>当for in 的键对应的值又是引用类型时，又会变为赋址操作；</p><p>解决：用递归</p></li><li><p>原型上的共享属性也会遍历</p><p>解决：使用hasOwnProperty来进行判断</p></li></ul></li></ul><h2 id="如何进行深拷贝"><a href="#如何进行深拷贝" class="headerlink" title="如何进行深拷贝"></a>如何进行深拷贝</h2><ul><li>原生js</li><li>JSON.parse(JSON.stringify(obj))</li><li>jq的$.extend方法：将一个或多个对象合并到目标对象</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">            name:<span class="string">&#x27;joth&#x27;</span>,</span><br><span class="line">            age:<span class="number">18</span>,</span><br><span class="line">            sex:<span class="string">&#x27;male&#x27;</span>,</span><br><span class="line">            arr:[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],</span><br><span class="line">            body:&#123;</span><br><span class="line">                weight:<span class="string">&#x27;70kg&#x27;</span>,</span><br><span class="line">                height:<span class="string">&#x27;176cm&#x27;</span>,</span><br><span class="line">                eyes:&#123;</span><br><span class="line">                    left:<span class="string">&#x27;2.0&#x27;</span>,</span><br><span class="line">                    right:<span class="string">&#x27;1.6&#x27;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            fn:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">&#x27;haha&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法一：原生js的深拷贝(递归)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">obj</span>)</span>&#123; <span class="comment">//obj 原对象</span></span><br><span class="line">    <span class="keyword">var</span> objClone = <span class="built_in">Array</span>.isArray(obj) ? [] : &#123;&#125;;<span class="comment">//在函数内 要拷贝的对象</span></span><br><span class="line">    <span class="keyword">if</span>(obj &amp;&amp; <span class="keyword">typeof</span> obj == <span class="string">&#x27;object&#x27;</span>);&#123; <span class="comment">//如果有obj 且obj是一个对象</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> obj)&#123; <span class="comment">//进行 for in循环</span></span><br><span class="line">            <span class="keyword">if</span>(obj.hasOwnProperty(key))&#123;<span class="comment">//判断该属性是否是构造函数上的属性（即不是原型上的共享属性）</span></span><br><span class="line">                <span class="keyword">if</span>(obj[key] &amp;&amp; <span class="keyword">typeof</span> obj[key] == <span class="string">&#x27;object&#x27;</span>)&#123;<span class="comment">//判断该属性对应的值是否为对象</span></span><br><span class="line">                    objClone[key] = deepClone(obj[key]);<span class="comment">//如果该属性对应的值是一个对象则再次调用该函数</span></span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    objClone[key] = obj[key];  <span class="comment">// 如果该属性对应的值不是对象，则是基本类型，直接赋值</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> objClone：</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法二：(不能复制函数)</span></span><br><span class="line"><span class="keyword">var</span> obj1 = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(obj))</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法三：jq的深浅拷贝</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//浅拷贝</span></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">    money: <span class="number">1000</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">    number: <span class="number">101</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj3 = $.extend(&#123;&#125;,obj1,obj2)</span><br><span class="line"></span><br><span class="line"><span class="comment">//深拷贝</span></span><br><span class="line"><span class="keyword">var</span> obj3 = $.extend(<span class="literal">true</span>,&#123;&#125;,obj1)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>call、apply、bind 的用法分别是什么？</title>
      <link href="2020/09/29/js-bind/"/>
      <url>2020/09/29/js-bind/</url>
      
        <content type="html"><![CDATA[<h2 id="它们最主要的作用是-改变this的指向"><a href="#它们最主要的作用是-改变this的指向" class="headerlink" title="它们最主要的作用是 改变this的指向"></a>它们最主要的作用是 改变this的指向</h2><h2 id="call"><a href="#call" class="headerlink" title="call()"></a>call()</h2><p>call() 写法 ： <code>function.call(thisArg, arg1, arg2, ...)</code></p><p>call()调用一个函数，第一个参数是指定的this值，其他参数分别是提供的参数，用逗号隔开。</p><p><strong>call()用法</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">a,b,c</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  fn 的this指向的是obj， 参数是 1，2，3</span></span><br><span class="line">fn.call(obj,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个fn 的this指向obj， 但它参数是 [1,2,3]  、 undefined 、 undefined</span></span><br><span class="line">fn.call(obj,[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])Copy</span><br></pre></td></tr></table></figure><h2 id="apply"><a href="#apply" class="headerlink" title="apply()"></a>apply()</h2><p>apply()写法： <code>func.apply(thisArg, [argsArray])</code></p><p>apply 只接收俩个参数， 第一个参数和call一样。 第二个参数，必须是数组或者类数组。</p><p><strong>apply() 和call() 使用上是一致的，唯一区别在于 call() 方法接受若干个参数，而apply()方法接受一个包含多个参数的数组</strong></p><h2 id="bind"><a href="#bind" class="headerlink" title="bind()"></a>bind()</h2><p>bind() 不同于 call() 和 apply() ， 它返回一个新的函数，该函数将this设置未我们赋给它的值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mdn demo</span></span><br><span class="line"><span class="built_in">this</span>.x = <span class="number">9</span>; <span class="comment">// 在浏览器中this指向全局的 window 对象</span></span><br><span class="line"><span class="keyword">var</span> <span class="built_in">module</span> = &#123;</span><br><span class="line">  x: <span class="number">81</span>,</span><br><span class="line">  getX: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="built_in">this</span>.x; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.getX(); <span class="comment">// 81</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> retrieveX = <span class="built_in">module</span>.getX;</span><br><span class="line">retrieveX();</span><br><span class="line"><span class="comment">// 返回9 - 因为函数是在全局作用域中调用的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个新函数，把this绑定都module对象上</span></span><br><span class="line"><span class="keyword">var</span> bondGetX = retrieveX.bind(<span class="built_in">module</span>);</span><br><span class="line">bondGetX(); <span class="comment">// 81</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>typeof 与 instanceof 区别</title>
      <link href="2020/09/28/js-typeof-vs-instanceof/"/>
      <url>2020/09/28/js-typeof-vs-instanceof/</url>
      
        <content type="html"><![CDATA[<h3 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h3><p>type ：“类型”</p><p>用于判断数据类型，返回值是6个不同的字符串：分别是：<strong>string</strong> <strong>number</strong> <strong>boolean</strong> <strong>undefined</strong> <strong>function</strong> <strong>object</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="string">&quot;1&quot;</span>);   <span class="comment">// string</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="number">1</span>);  <span class="comment">// number</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">false</span>);  <span class="comment">// boolean</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">undefined</span>);  <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;&#125;);   <span class="comment">// function</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> &#123;&#125;);   <span class="comment">// objectCopy</span></span><br></pre></td></tr></table></figure><p>除了以上之外，你会发现 typeof 判断 <strong>null</strong> <strong>Array</strong> <strong>构造函数的实例</strong>时， 会发现 永远得到是 <strong>object</strong></p><p>因此可知道 typeof 运算符 适用于检测除null的基础数据类型和函数类型</p><h3 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h3><p>instance ：“实例” 因此可以通过他的翻译知道这个含义了，就是 判断该对象是属于谁的实例。由于是实例，所以不得不牵扯到了对象的继承，即原型的知识了。而 <strong>instanceof</strong> 就是根据原型链进行搜寻的。</p><p>所以 instanceof 是检测对象之间的关联性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Number</span>() <span class="keyword">instanceof</span> <span class="built_in">Number</span>);  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">String</span>() <span class="keyword">instanceof</span> <span class="built_in">String</span>);  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] <span class="keyword">instanceof</span> <span class="built_in">Array</span>);  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(&#123; <span class="attr">name</span>: <span class="string">&quot;foo&quot;</span> &#125; <span class="keyword">instanceof</span> <span class="built_in">Object</span>);  <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;1&quot;</span> <span class="keyword">instanceof</span> <span class="built_in">String</span>);  <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span> <span class="keyword">instanceof</span> <span class="built_in">Number</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">false</span> <span class="keyword">instanceof</span> <span class="built_in">Boolean</span>);   <span class="comment">// falseCopy</span></span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><table><thead><tr><th></th><th>typeof</th><th>instanceof</th></tr></thead><tbody><tr><td>作用</td><td>检测数据类型</td><td>检测对象之间的关联性</td></tr><tr><td>返回值</td><td>小写的字母 字符串</td><td>布尔值</td></tr><tr><td>操作符</td><td>简单数据类型（没有null）、函数或者对象</td><td>左边必须是引用类型，右边必须是函数</td></tr><tr><td>操作数数量</td><td>1个</td><td>2个</td></tr></tbody></table><p><strong>typeof</strong> 中的 type 是类型的意思，所以他是用来检测数据类型的， 可以检测除了null以外的数据类型加上function，返回字符串</p><p><strong>instanceof</strong> 中的 instance是实例的意思， 所以他是用来检测这个实例是谁 <strong>new</strong> 出来的。返回布尔值</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>axios</title>
      <link href="2020/09/28/Vue-axios/"/>
      <url>2020/09/28/Vue-axios/</url>
      
        <content type="html"><![CDATA[<h2 id="axios"><a href="#axios" class="headerlink" title="axios"></a>axios</h2><blockquote><p>axios: ajax i/o system.</p></blockquote><ul><li><strong>功能特点</strong> ：<ul><li>在浏览器中发送 XMLHttpRequests 请求</li><li>在 node.js 中发送 http请求</li><li>支持 Promise API</li><li>拦截请求和响应</li><li>转换请求和响应数据</li></ul></li><li><strong>支持多种请求方式</strong><ul><li>axios(config)</li><li>axios.request(config)</li><li>axios.get(url[, config])</li><li>axios.delete(url[, config])</li><li>axios.head(url[, config])</li><li>axios.post(url[, data[, config]])</li><li>axios.put(url[, data[, config]])</li><li>axios.patch(url[, data[, config]])</li></ul></li></ul><h2 id="常用请求方式"><a href="#常用请求方式" class="headerlink" title="常用请求方式"></a>常用请求方式</h2><h3 id="get"><a href="#get" class="headerlink" title="get"></a>get</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">axios.get(<span class="string">&#x27;地址&#x27;</span>,配置对象).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123; res就是相应信息，res.data 才是真正的后端返回的内容 &#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123; 错误信息捕获 &#125;)</span><br></pre></td></tr></table></figure><p><strong>提交参数</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">axios.get(<span class="string">&#x27;地址?key=val&amp;key2=val2&#x27;</span>,配置对象)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">axios.get(<span class="string">&#x27;地址&#x27;</span>,&#123;</span><br><span class="line">  params:&#123;</span><br><span class="line">    key:val,</span><br><span class="line">    key2:val2</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="post"><a href="#post" class="headerlink" title="post"></a>post</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">axios.post(<span class="string">&#x27;地址&#x27;</span>,&#123; <span class="attr">key</span>:val, <span class="attr">key2</span>:val2 &#125;).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123; res就是相应信息，res.data 才是真正的后端返回的内容 &#125;)</span><br><span class="line"><span class="comment">// 有时候上述提交不可以</span></span><br></pre></td></tr></table></figure><p><strong>解决post提交问题</strong></p><ul><li>使用FormData</li><li>URLSearchParams转义</li><li>使用qs包</li></ul><h3 id="axios-1"><a href="#axios-1" class="headerlink" title="axios"></a>axios</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">axios(&#123;</span><br><span class="line">   url:<span class="string">&quot;请求地址&quot;</span>,</span><br><span class="line">   method:<span class="string">&quot;请求方式&quot;</span>,</span><br><span class="line">   data:&#123;  post提交参数&#125;,</span><br><span class="line">   params:&#123; get提交参数 &#125;</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123; res就是相应信息，res.data 才是真正的后端返回的内容 &#125;)</span><br></pre></td></tr></table></figure><h3 id="all-发送并发请求"><a href="#all-发送并发请求" class="headerlink" title="all 发送并发请求"></a>all 发送并发请求</h3><p>有时候, 我们可能需求同时发送两个请求</p><ul><li>使用<strong>axios.all,</strong> 可以放入多个请求的数组. res[0],res[1] 得出结果</li><li><strong>axios.all([]) 返回的结果是一个数组</strong>，使用 axios.spread 可将数组 [res1,res2] 展开为 res1, res2</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">axios.all([请求<span class="number">1</span>，请求<span class="number">2</span>,...]).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">           res是数组，数组每个元素都是请求返回的信息</span><br><span class="line">           <span class="comment">// 可使用axios.spread</span></span><br><span class="line">           axios.spread((res1, res2)) =&gt; &#123;</span><br><span class="line">           &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="create-创建-axios-实例"><a href="#create-创建-axios-实例" class="headerlink" title="create 创建 axios 实例"></a>create 创建 axios 实例</h3><h4 id="为什么要创建axios的实例呢"><a href="#为什么要创建axios的实例呢" class="headerlink" title="为什么要创建axios的实例呢?"></a>为什么要创建axios的实例呢?</h4><ul><li>当我们从axios模块中导入对象时, 使用的实例是默认的实例.</li><li>当给该实例设置一些默认配置时, 这些配置就被固定下来了.</li><li>但是后续开发中, 某些配置可能会不太一样.</li><li>比如某些请求需要使用特定的baseURL或者timeout或者content-Type等.</li><li>这个时候, 我们就可以创建新的实例, 并且传入属于该实例的配置信息.</li></ul><p><a href="https://img-blog.csdnimg.cn/20200926145610848.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Bmenp6eno=,size_16,color_FFFFFF,t_70#pic_center"><img src="https://img-blog.csdnimg.cn/20200926145610848.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Bmenp6eno=,size_16,color_FFFFFF,t_70#pic_center" alt="创建 axios 实例"></a></p><h2 id="全局配置"><a href="#全局配置" class="headerlink" title="全局配置"></a>全局配置</h2><blockquote><p>在开发中可能很多参数都是固定的，比如BaseURL</p><p>这个时候我们可以进行一些抽取, 也可以利用axiox的全局配置</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">axios.defaults.baseURL = <span class="string">&#x27;123.207.32.32:8000&#x27;</span></span><br><span class="line">axios.defaults.headers.post[<span class="string">&#x27;Content-Type&#x27;</span>] = <span class="string">&#x27;application/x-www-form-urlencoded&#x27;</span>;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">axios.all([</span><br><span class="line">  axios.get(<span class="string">&#x27;/category&#x27;</span>),</span><br><span class="line">  axios.get(<span class="string">&#x27;home/data&#x27;</span>, &#123;<span class="attr">params</span>: &#123;<span class="attr">type</span>: <span class="string">&#x27;sell&#x27;</span>, <span class="attr">page</span>: <span class="string">&#x27;1&#x27;</span>&#125;&#125;)</span><br><span class="line">]).then(axios.spread(<span class="function">(<span class="params">res1, res2</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res1);</span><br><span class="line">  <span class="built_in">console</span>.log(res2);</span><br><span class="line">&#125;))</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="axios-模块化封装"><a href="#axios-模块化封装" class="headerlink" title="axios 模块化封装"></a>axios 模块化封装</h2><blockquote><p>在实际开发过程中，需要对AJAX请求进行统一的封装，使其模块化，易于修改和操作。</p><p>所以，最好这样做，而不是直接在 组件内使用 axios 插件 ，那样后期修改整个 axios 时会及其麻烦</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&quot;axios&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">config</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//  1.配置基本信息   </span></span><br><span class="line">  <span class="keyword">const</span> instance = axios.create(&#123;</span><br><span class="line">    baseURL: <span class="string">&#x27;http://152.136.185.210:8000/api/z8&#x27;</span>,</span><br><span class="line">    timeout: <span class="number">5000</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">//  本身返回的就一个 Promise   不需要再次封装一个 Promise来使用</span></span><br><span class="line">  <span class="comment">// 3.发送真正的网络请求  ( 方式一)</span></span><br><span class="line">  <span class="keyword">return</span> instance(config)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"><span class="comment">//  使用 回调函数   ( 方式二)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// export function request(config, success, failure) &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//   const instance = axios.create(&#123;</span></span><br><span class="line"><span class="comment">//     baseURL: &#x27;http://152.136.185.210:8000/api/z8&#x27;,</span></span><br><span class="line"><span class="comment">//     timeout: 5000</span></span><br><span class="line"><span class="comment">//   &#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//   instance(config)</span></span><br><span class="line"><span class="comment">//     .then(res =&gt; &#123;</span></span><br><span class="line"><span class="comment">//       success(res)</span></span><br><span class="line"><span class="comment">//     &#125;)</span></span><br><span class="line"><span class="comment">//     .catch(err =&gt; &#123;</span></span><br><span class="line"><span class="comment">//       failure(err)</span></span><br><span class="line"><span class="comment">//     &#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 Promise      ( 方式三 )</span></span><br><span class="line"><span class="comment">// export function request(config) &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//   return new Promise((resolve, reject) =&gt; &#123;</span></span><br><span class="line"><span class="comment">//     const instance = axios.create(&#123;</span></span><br><span class="line"><span class="comment">//       baseURL: &#x27;http://152.136.185.210:8000/api/z8&#x27;,</span></span><br><span class="line"><span class="comment">//       timeout: 5000</span></span><br><span class="line"><span class="comment">//     &#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     instance(config)</span></span><br><span class="line"><span class="comment">//       .then(res =&gt; &#123;</span></span><br><span class="line"><span class="comment">//         resolve(res)</span></span><br><span class="line"><span class="comment">//       &#125;)</span></span><br><span class="line"><span class="comment">//       .catch(err =&gt; &#123;</span></span><br><span class="line"><span class="comment">//         reject(err)</span></span><br><span class="line"><span class="comment">//       &#125;)</span></span><br><span class="line"><span class="comment">//   &#125;)</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">//  在组件内 传入对象 进行网络请求</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式一和方式三（promise） ，</span></span><br><span class="line">request(&#123;</span><br><span class="line">    url:<span class="string">&#x27;/home/multidata&#x27;</span></span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式二 （使用的回调函数）:</span></span><br><span class="line">request(&#123;</span><br><span class="line">    url:<span class="string">&#x27;/home/multidata&#x27;</span></span><br><span class="line">&#125;,<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res) </span><br><span class="line">&#125;,<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err) </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="axios-拦截器"><a href="#axios-拦截器" class="headerlink" title="axios 拦截器"></a>axios 拦截器</h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>在请求发送之前或者响应消息之前，进行相应的梳理</p><ul><li>请求拦截器<ul><li>请求发起之前做某些事情</li><li>添加token</li></ul></li><li>响应拦截器<ul><li>响应消息到具体请求之前</li><li>做错误判断或者数据处理</li></ul></li></ul><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&quot;axios&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">config</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//  1.配置基本信息   （创建实例， 这样不是全局的）</span></span><br><span class="line">  <span class="keyword">const</span> instance = axios.create(&#123;</span><br><span class="line">    baseURL: <span class="string">&#x27;http://152.136.185.210:8000/api/z8&#x27;</span>,</span><br><span class="line">    timeout: <span class="number">5000</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// 2.axios 拦截器</span></span><br><span class="line">  <span class="comment">// 2.1请求拦截的作用： </span></span><br><span class="line">  instance.interceptors.request.use(<span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//  这里可以拦截一些：</span></span><br><span class="line">    <span class="comment">// 1. 比如config中的一些信息不符合服务器的要求  </span></span><br><span class="line">    <span class="comment">// 2. 比如每次发送网络请求时，都希望在页面中显示一个请求的图标</span></span><br><span class="line">    <span class="comment">// 3. 某些网络请求（比如登录需要的token，必须携带一些特殊的信息）</span></span><br><span class="line">    config.headers.token = <span class="string">&#x27;token秘钥&#x27;</span></span><br><span class="line">    <span class="comment">// 拦截后 要发出去  要不就收不到</span></span><br><span class="line">    <span class="keyword">return</span> config</span><br><span class="line">  &#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2.2 响应拦截 </span></span><br><span class="line">  instance.interceptors.response.use(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 响应的成功拦截中，主要是对数据进行过滤。</span></span><br><span class="line">    <span class="keyword">return</span> res.data <span class="comment">// 真正有用的东西是 data中的数据</span></span><br><span class="line">  &#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 响应的失败拦截中，可以根据status判断报错的错误码，跳转到不同的错误提示页面。</span></span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">//  本身返回的就一个 Promise   不需要再次封装一个 Promise来使用</span></span><br><span class="line">  <span class="comment">// 3.发送真正的网络请求</span></span><br><span class="line">  <span class="keyword">return</span> instance(config)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
          <category> Vue2 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> Vue2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue - vuex详解</title>
      <link href="2020/09/28/Vue-vuex/"/>
      <url>2020/09/28/Vue-vuex/</url>
      
        <content type="html"><![CDATA[<h2 id="vuex介绍"><a href="#vuex介绍" class="headerlink" title="vuex介绍"></a>vuex介绍</h2><ul><li>vuex是什么：Vuex 是一个专为 Vue.js 应用程序开发的<strong>状态管理模式</strong>。它采用<strong>集中式存储管理应用的所有组件的状态</strong>，并以相应的规则保证状态以一种可预测的方式发生变化。Vuex 也集成到 Vue 的官方调试工具 <a href="https://github.com/vuejs/vue-devtools">devtools extension</a>，提供了诸如零配置的 time-travel 调试、状态快照导入导出等高级调试功能。</li><li>vuex文档地址：<a href="https://vuex.vuejs.org/zh/">https://vuex.vuejs.org/zh/</a></li></ul><h2 id="vuex使用"><a href="#vuex使用" class="headerlink" title="vuex使用"></a>vuex使用</h2><ul><li><p>安装vuex</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i vuex --save</span><br></pre></td></tr></table></figure></li><li><p>创建仓库文件<code>src/store/index.js</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue  <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">&quot;vuex&quot;</span>;</span><br><span class="line"><span class="comment">// 安装插件</span></span><br><span class="line">Vue.use(Vuex);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例化一个仓库对象</span></span><br><span class="line"><span class="keyword">let</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">    state:&#123;&#125;,</span><br><span class="line">    getters:&#123;&#125;,</span><br><span class="line">    mutations:&#123;&#125;,</span><br><span class="line">    actions:&#123;&#125;,</span><br><span class="line">    modules:&#123;&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 暴露</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store;</span><br></pre></td></tr></table></figure></li><li><p>在main.js中引入</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&#x27;./App&#x27;</span></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">&#x27;./router&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入Store</span></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&quot;./store&quot;</span></span><br><span class="line"></span><br><span class="line">Vue.config.productionTip = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* eslint-disable no-new */</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  router,</span><br><span class="line">  store,    <span class="comment">// 挂载到vue实例上面去 </span></span><br><span class="line">  components: &#123; App &#125;,</span><br><span class="line">  template: <span class="string">&#x27;&lt;App/&gt;&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>一旦将vuex仓库实例挂载到vue实例上面，所有的组件的this里面都会出现一个$store,表示这个仓库实例对象</strong></p></li></ul><h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><h3 id="state"><a href="#state" class="headerlink" title="state"></a>state</h3><ul><li><p>作用： 类似于所有组件的data，所有组件都可以在这里读取数据，实现共享</p></li><li><p>使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">    state:&#123;</span><br><span class="line">    key:val,</span><br><span class="line">    key2:val2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>组件模板中</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; $store.state.key &#125;&#125;</span><br></pre></td></tr></table></figure></li><li><p>利用辅助函数 <strong><code>mapState</code></strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 组件中</span></span><br><span class="line"><span class="keyword">import</span> &#123; mapState &#125; <span class="keyword">from</span> <span class="string">&quot;vuex&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">   ...,</span><br><span class="line">  computed:&#123;</span><br><span class="line">     ...mapState([<span class="string">&#x27;key&#x27;</span>,<span class="string">&#x27;key2&#x27;</span>])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 组件模板中</span></span><br><span class="line">&#123;&#123;key&#125;&#125;</span><br><span class="line">&#123;&#123;key2&#125;&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="getters"><a href="#getters" class="headerlink" title="getters"></a>getters</h3><ul><li><p>作用：对仓库里面state数据进行一些加工处理。功能类似组件的computed。</p></li><li><p>实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">    state:&#123;</span><br><span class="line">    key:val,</span><br><span class="line">    key2:val2</span><br><span class="line">    &#125;,</span><br><span class="line">    getters:&#123;</span><br><span class="line">       <span class="function"><span class="title">newkey</span>(<span class="params">state</span>)</span>&#123;</span><br><span class="line">         <span class="keyword">return</span> state.key+<span class="string">&#x27;xxx处理&#x27;</span></span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>组件模板中</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;$store.getters.newkey&#125;&#125;</span><br></pre></td></tr></table></figure></li><li><p>利用辅助函数 <strong><code>mapGetters</code></strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 组件中</span></span><br><span class="line"><span class="keyword">import</span> &#123; mapGetters &#125; <span class="keyword">from</span> <span class="string">&quot;vuex&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">   ...,</span><br><span class="line">  computed:&#123;</span><br><span class="line">     ...mapGetters([<span class="string">&#x27;newkey&#x27;</span>])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 组件模板中</span></span><br><span class="line">&#123;&#123;newkey&#125;&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="mutations"><a href="#mutations" class="headerlink" title="mutations"></a>mutations</h3><ul><li><p>作用： <strong>vuex中唯一一个可以修改state里面数据的方法。切记不可以通过在组件中赋值state进行修改</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.$store.state.key = newval    <span class="comment">// 错误的写法</span></span><br></pre></td></tr></table></figure></li><li><p>使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">    state:&#123;</span><br><span class="line">    key:val,</span><br><span class="line">    key2:val2</span><br><span class="line">    &#125;,</span><br><span class="line">    mutations:&#123;</span><br><span class="line">       <span class="comment">// 形参1是state数据  形参2是调用该方法传入的实参 </span></span><br><span class="line">     <span class="function"><span class="title">FN</span>(<span class="params">state,data</span>)</span>&#123;</span><br><span class="line">          state.key = data</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>组件中实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$store.commit(&#39;FN&#39;,实参)</span><br></pre></td></tr></table></figure></li><li><p>利用辅助函数 <strong><code>mapMutations</code></strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 组件中</span></span><br><span class="line"><span class="keyword">import</span> &#123; mapMutations &#125; <span class="keyword">from</span> <span class="string">&quot;vuex&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">   ...,</span><br><span class="line">  methods:&#123;</span><br><span class="line">     ...mapMutations([<span class="string">&#x27;FN&#x27;</span>])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 组件模板中</span></span><br><span class="line">@click=<span class="string">&quot;FN(实参)&quot;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="actions"><a href="#actions" class="headerlink" title="actions"></a>actions</h3><ul><li><p>作用： 用来修改state。 但是确实间接修改， 他是通过触发mutations里面的方法去修改state 。 actions里面通常存放大量的异步逻辑请求代码。成功之后将数据给muations，然后mutations设置给state。</p></li><li><p>使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">    state:&#123;</span><br><span class="line">    key:val,</span><br><span class="line">    key2:val2</span><br><span class="line">    &#125;,</span><br><span class="line">    mutations:&#123;</span><br><span class="line">       <span class="comment">// 形参1是state数据  形参2是调用该方法传入的实参</span></span><br><span class="line">     <span class="function"><span class="title">FN</span>(<span class="params">state,data</span>)</span>&#123;</span><br><span class="line">          state.key = data</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  actions:&#123;</span><br><span class="line">      <span class="comment">// 形参1是store，就是这个仓库实例对象。 形参2是调用该方法传入的实参</span></span><br><span class="line">       <span class="function"><span class="title">fn</span>(<span class="params">store,info</span>)</span>&#123;</span><br><span class="line">          store.commit(<span class="string">&#x27;FN&#x27;</span>,info)</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>组件中实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$store.dispatch(&#39;fn&#39;,实参)</span><br></pre></td></tr></table></figure></li><li><p>利用辅助函数 <strong><code>mapActions</code></strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 组件中</span></span><br><span class="line"><span class="keyword">import</span> &#123; mapActions &#125; <span class="keyword">from</span> <span class="string">&quot;vuex&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">   ...,</span><br><span class="line">   methods:&#123;</span><br><span class="line">     ...mapActions([<span class="string">&#x27;fn&#x27;</span>])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 组件模板中</span></span><br><span class="line">@click=<span class="string">&quot;fn(实参)&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>注意：<strong>actions和mutations的区别</strong></p><ul><li>​    mutations 是唯一修改state的方法，且是同步修改</li><li>actions是间接修改state（通过触发mutations）, actions里面存放异步处理逻辑</li></ul></li></ul><h3 id="思路图"><a href="#思路图" class="headerlink" title="思路图"></a>思路图</h3><p><img src="/images/vue/gxt.png"></p><p><img src="https://vuex.vuejs.org/vuex.png"></p><h3 id="modules"><a href="#modules" class="headerlink" title="modules"></a>modules</h3><ul><li>针对于大型项目放在一个根模块，状态的维护困难。</li><li>对于不同项目不同模块的状态管理我们往往存放不同模块中，这样易于维护便于管理。</li></ul><h4 id="写法"><a href="#写法" class="headerlink" title="写法"></a>写法</h4><ul><li><p>结构</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// store/index.js文件</span></span><br><span class="line"><span class="keyword">let</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state:&#123; 根state &#125;,</span><br><span class="line">  getters:&#123; 根getters &#125;,</span><br><span class="line">  mutations:&#123; 根mutations &#125;,</span><br><span class="line">  actions:&#123;  根actions &#125;,</span><br><span class="line">  modules:&#123;</span><br><span class="line">     模块名<span class="number">1</span>:&#123;</span><br><span class="line">        namespaced:<span class="literal">false</span>/<span class="literal">true</span>,  <span class="comment">// 不写就是false</span></span><br><span class="line">        state:<span class="function">()=&gt;</span>(&#123;  模块state &#125;),   <span class="comment">// 注意模块的state是一个函数，且这个函数返回一个对象 </span></span><br><span class="line">        getters:&#123; 模块getters &#125;,</span><br><span class="line">        mutations:&#123; 模块mutations &#125;,</span><br><span class="line">        actions:&#123;  模块actions &#125;,</span><br><span class="line">        modules:&#123; 子模块 &#125;</span><br><span class="line">     &#125;,</span><br><span class="line">      模块名<span class="number">2</span>:&#123;</span><br><span class="line">          namespaced:<span class="literal">false</span>/<span class="literal">true</span>,  <span class="comment">// 不写就是false</span></span><br><span class="line">          state:<span class="function">()=&gt;</span>(&#123;  模块state &#125;),</span><br><span class="line">          getters:&#123; 模块getters &#125;,</span><br><span class="line">          mutations:&#123; 模块mutations &#125;,</span><br><span class="line">          actions:&#123;  模块actions &#125;,</span><br><span class="line">          modules:&#123; 子模块 &#125;</span><br><span class="line">       &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>真实结构：</p><ul><li><p>store目录</p><ul><li><p>index.js    仓库对象   【文件】</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入根配置</span></span><br><span class="line"><span class="keyword">import</span> state <span class="keyword">from</span>  <span class="string">&quot;./state&quot;</span></span><br><span class="line"><span class="keyword">import</span> getters <span class="keyword">from</span>  <span class="string">&quot;./getters&quot;</span></span><br><span class="line"><span class="keyword">import</span> mutations <span class="keyword">from</span>  <span class="string">&quot;./mutations&quot;</span></span><br><span class="line"><span class="keyword">import</span> actions <span class="keyword">from</span>  <span class="string">&quot;./actions&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入模块</span></span><br><span class="line"><span class="keyword">import</span> 模块<span class="number">1</span> <span class="keyword">from</span> <span class="string">&quot;./模块名1&quot;</span></span><br><span class="line"><span class="keyword">import</span> 模块<span class="number">2</span> <span class="keyword">from</span> <span class="string">&quot;./模块名2&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state:state,</span><br><span class="line">  getters:getters,</span><br><span class="line">  mutations:mutations,</span><br><span class="line">  actions:actions,</span><br><span class="line">  modules:&#123;</span><br><span class="line">     模块名<span class="number">1</span>:模块<span class="number">1</span>,</span><br><span class="line">      模块名<span class="number">2</span>:模块<span class="number">2</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>state.js   【文件】</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  根state</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">key:val</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>getters.js    【文件】</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根getters</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="function"><span class="title">newkey</span>(<span class="params">state</span>)</span>&#123;   <span class="comment">// state 根state    state.模块名1  模块1的所有state    state.模块名2    模块2的所有state </span></span><br><span class="line">       <span class="keyword">return</span> state.key</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="function"><span class="title">newkey</span>(<span class="params">state</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> state.模块名<span class="number">1.</span>key</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="title">newkey2</span>(<span class="params">state</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> state.模块名<span class="number">2.</span>key</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>mutations.js  【文件】</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根mutations</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line"><span class="comment">// 自己的state, 和调用该方法传入的实参</span></span><br><span class="line"><span class="function"><span class="title">FN</span>(<span class="params">state,data</span>)</span>&#123;</span><br><span class="line"> state.key = data;</span><br><span class="line">&#125;,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>actions.js  【文件】</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根actions</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line"><span class="comment">// store就是仓库实例对象 , 和调用该方法传入的实参</span></span><br><span class="line"><span class="function"><span class="title">fn</span>(<span class="params">store,info</span>)</span>&#123;</span><br><span class="line"> store.commit(<span class="string">&#x27;FN&#x27;</span>,info)</span><br><span class="line">&#125;,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>modules  【文件夹】</p><ul><li><p>模块名1.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">state:<span class="function">()=&gt;</span>(&#123;  模块state &#125;),</span><br><span class="line">      getters:&#123; 模块getters &#125;,</span><br><span class="line">      mutations:&#123; 模块mutations &#125;,</span><br><span class="line">      actions:&#123;  模块actions &#125;,</span><br><span class="line">      modules:&#123; 子模块 &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>模块名2.js</p></li></ul></li></ul></li></ul></li></ul><h4 id="获取数据"><a href="#获取数据" class="headerlink" title="获取数据"></a>获取数据</h4><ul><li><p>获取state</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;$store.state.key&#125;&#125;    <span class="comment">// 去根state里面的数据</span></span><br><span class="line">&#123;&#123;$store.state.模块名.key&#125;&#125;    <span class="comment">// 去某个模块state里面的数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// state结构</span></span><br><span class="line">state:&#123;</span><br><span class="line">  key:val,</span><br><span class="line">    key2:val2,</span><br><span class="line">    模块名:&#123;</span><br><span class="line">       key:val,</span><br><span class="line">       key2:val2</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>获取getters</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;$store.getters.key&#125;&#125;    <span class="comment">// 去根getters里面的数据</span></span><br><span class="line">&#123;&#123;$store.getters.key2&#125;&#125;    <span class="comment">// 去某个模块里面getter的数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有的getters 都会被挂载到根getters上面 </span></span><br></pre></td></tr></table></figure></li></ul><h4 id="namespaced-false"><a href="#namespaced-false" class="headerlink" title="namespaced:false"></a>namespaced:false</h4><ul><li><p>命名空间没有。没有命名空间的时候，所有的actions最后都是在根actions上面了。所有的mutations都到根mutations上面了。</p></li><li><p>组件中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">...mapState(&#123;</span><br><span class="line">key:<span class="string">&#x27;key&#x27;</span>,   <span class="comment">// 根的，取根state里面的key </span></span><br><span class="line">key2:<span class="function"><span class="params">state</span>=&gt;</span>state.模块名.key2     <span class="comment">// 取模块的， 去模块state里面的key2</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">...mapGetters([&#39;key1&#39;,&#39;key2&#39;])   &#x2F;&#x2F; key1是根getters里面，key2是模块getters里面key2</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$store.commit(<span class="string">&#x27;任意模块的mutations里面的方法&#x27;</span>，实参)</span><br><span class="line"></span><br><span class="line">...mapMutations([<span class="string">&#x27;FN1&#x27;</span>,<span class="string">&#x27;FN2&#x27;</span>])   <span class="comment">// FN1是根mutations里面的方法， FN2是模块里面的mutations里面的方法</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$store.dispatch(<span class="string">&#x27;任意模块的actions里面的方法&#x27;</span>，实参)</span><br><span class="line"></span><br><span class="line">...mapActions([<span class="string">&#x27;fn1&#x27;</span>,<span class="string">&#x27;fn2&#x27;</span>])   <span class="comment">// fn1是根actions里面的方法， fn2是模块里面的actions里面的方法</span></span><br></pre></td></tr></table></figure></li><li><p>模块中(actions里面方法里)调用其他模块的mutations或actions里面的方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A模块</span></span><br><span class="line">&#123;</span><br><span class="line">  ...,</span><br><span class="line">  mutations:&#123;</span><br><span class="line"><span class="function"><span class="title">FN</span>(<span class="params">state,data</span>)</span>&#123;</span><br><span class="line">        state.key = data</span><br><span class="line">      &#125;</span><br><span class="line">&#125;,</span><br><span class="line">  actions:&#123;</span><br><span class="line">     <span class="function"><span class="title">fn</span>(<span class="params">store,info</span>)</span>&#123;</span><br><span class="line">        store.commit(<span class="string">&#x27;FN&#x27;</span>,info)  <span class="comment">// 触发自己的mutations里面的方法</span></span><br><span class="line">          store.dispatch(<span class="string">&#x27;fn2&#x27;</span>)    <span class="comment">// 触发自己的actions里面的其他方法</span></span><br><span class="line">       </span><br><span class="line">       <span class="comment">// A模块触发B模块里面的方法    缺点： 无法区分调用的方法是哪个模块的 对于大型项目而言，非常的混乱 </span></span><br><span class="line">          store.commit(<span class="string">&#x27;FN3&#x27;</span>,info)</span><br><span class="line">          store.dispatch(<span class="string">&#x27;fn3&#x27;</span>,info)</span><br><span class="line">       </span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="title">fn2</span>(<span class="params">store,info</span>)</span>&#123;...&#125;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//B模块</span></span><br><span class="line">&#123;</span><br><span class="line">  ...,</span><br><span class="line">  mutations:&#123;</span><br><span class="line"><span class="function"><span class="title">FN3</span>(<span class="params">state,data</span>)</span>&#123;</span><br><span class="line">        state.key = data</span><br><span class="line">      &#125;</span><br><span class="line">&#125;,</span><br><span class="line">  actions:&#123;</span><br><span class="line">     <span class="function"><span class="title">fn3</span>(<span class="params">store,info</span>)</span>&#123;</span><br><span class="line">        store.commit(<span class="string">&#x27;FN3&#x27;</span>,info)  <span class="comment">// 触发自己的mutations里面的方法FN3</span></span><br><span class="line">          store.dispatch(<span class="string">&#x27;fn4&#x27;</span>)    <span class="comment">// 触发自己的actions里面的其他方法fn4</span></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="title">fn4</span>(<span class="params">store,info</span>)</span>&#123;...&#125;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="namespaced-true"><a href="#namespaced-true" class="headerlink" title="namespaced:true"></a>namespaced:true</h4><ul><li><p>命名空间有</p></li><li><p>组件中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">...mapState(&#123;</span><br><span class="line">key:<span class="string">&#x27;key&#x27;</span>,   <span class="comment">// 根的，取根state里面的key </span></span><br><span class="line">key2:<span class="function"><span class="params">state</span>=&gt;</span>state.模块名.key2     <span class="comment">// 取模块的， 去模块state里面的key2</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">...mapGetters(&#123;</span><br><span class="line">key1:<span class="string">&#x27;key1&#x27;</span>  <span class="comment">// key1是根getters里面</span></span><br><span class="line">key2:<span class="string">&#x27;模块名/key2&#x27;</span>   <span class="comment">// key2是模块getters里面key2</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$store.commit(<span class="string">&#x27;模块名/该模块mutations里面的方法&#x27;</span>，实参)</span><br><span class="line"></span><br><span class="line">...mapMutations(&#123;</span><br><span class="line">  FN1:<span class="string">&#x27;FN1&#x27;</span>,   <span class="comment">// FN1是根mutations里面的方法</span></span><br><span class="line">  FN2:<span class="string">&#x27;模块名/FN2&#x27;</span>  <span class="comment">//  FN2是模块里面的mutations里面的方法</span></span><br><span class="line">&#125;) </span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$store.dispatch(<span class="string">&#x27;模块名/该模块actions里面的方法&#x27;</span>，实参)</span><br><span class="line"></span><br><span class="line">...mapActions(&#123;</span><br><span class="line">  fn1:<span class="string">&#x27;fn1&#x27;</span>,   <span class="comment">// fn1是根actions里面的方法</span></span><br><span class="line">  fn2:<span class="string">&#x27;模块名/fn2&#x27;</span>  <span class="comment">//  fn2是模块里面的actions里面的方法</span></span><br><span class="line">&#125;) </span><br></pre></td></tr></table></figure></li><li><p>模块中(actions里面方法里)调用其他模块的mutations或actions里面的方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A模块</span></span><br><span class="line">&#123;</span><br><span class="line">  ...,</span><br><span class="line">  mutations:&#123;</span><br><span class="line"><span class="function"><span class="title">FN</span>(<span class="params">state,data</span>)</span>&#123;</span><br><span class="line">        state.key = data</span><br><span class="line">      &#125;</span><br><span class="line">&#125;,</span><br><span class="line">  actions:&#123;</span><br><span class="line">     <span class="function"><span class="title">fn</span>(<span class="params">store,info</span>)</span>&#123;</span><br><span class="line">        store.commit(<span class="string">&#x27;FN&#x27;</span>,info)  <span class="comment">// 触发自己的mutations里面的方法</span></span><br><span class="line">          store.dispatch(<span class="string">&#x27;fn2&#x27;</span>)    <span class="comment">// 触发自己的actions里面的其他方法</span></span><br><span class="line">       </span><br><span class="line">       <span class="comment">// A模块触发B模块里面的方法    </span></span><br><span class="line">          store.commit(<span class="string">&#x27;模块名/FN3&#x27;</span>,info,&#123;<span class="attr">root</span>:<span class="literal">true</span>&#125;)</span><br><span class="line">          store.dispatch(<span class="string">&#x27;模块名/fn3&#x27;</span>,info,&#123;<span class="attr">root</span>:<span class="literal">true</span>&#125;) </span><br><span class="line">       </span><br><span class="line">       <span class="comment">// store相关信息</span></span><br><span class="line">        <span class="comment">// store.state  当前模块的state</span></span><br><span class="line">            <span class="comment">// store.getters  当前模块的getters</span></span><br><span class="line">            <span class="comment">// store.commit   调用任意模块的muations,注意模块名，root:true</span></span><br><span class="line">            <span class="comment">// store.dispatch   调用任意模块的actions,注意模块名，root:true</span></span><br><span class="line">          <span class="comment">// store.rootState  根state</span></span><br><span class="line">            <span class="comment">// store.rootGetters  根getters</span></span><br><span class="line">       </span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="title">fn2</span>(<span class="params">store,info</span>)</span>&#123;...&#125;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//B模块</span></span><br><span class="line">&#123;</span><br><span class="line">  ...,</span><br><span class="line">  mutations:&#123;</span><br><span class="line"><span class="function"><span class="title">FN3</span>(<span class="params">state,data</span>)</span>&#123;</span><br><span class="line">        state.key = data</span><br><span class="line">      &#125;</span><br><span class="line">&#125;,</span><br><span class="line">  actions:&#123;</span><br><span class="line">     <span class="function"><span class="title">fn3</span>(<span class="params">store,info</span>)</span>&#123;</span><br><span class="line">        store.commit(<span class="string">&#x27;FN3&#x27;</span>,info)  <span class="comment">// 触发自己的mutations里面的方法FN3</span></span><br><span class="line">          store.dispatch(<span class="string">&#x27;fn4&#x27;</span>)    <span class="comment">// 触发自己的actions里面的其他方法fn4</span></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="title">fn4</span>(<span class="params">store,info</span>)</span>&#123;...&#125;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
          <category> Vue2 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> Vue2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue - 路由基础</title>
      <link href="2020/09/27/Vue-router/"/>
      <url>2020/09/27/Vue-router/</url>
      
        <content type="html"><![CDATA[<h2 id="路由基础"><a href="#路由基础" class="headerlink" title="路由基础"></a>路由基础</h2><h3 id="路由含义"><a href="#路由含义" class="headerlink" title="路由含义"></a>路由含义</h3><ul><li><p>服务器端的路由： <strong>一个地址指向一个资源页面</strong></p></li><li><p>前端的路由：框架式开发都是单页面（SPA）应用</p><ul><li>single page application   单页面应用<ul><li>优点：体验感好，组件化开发</li><li>缺点：不利于seo，首页加载慢</li></ul></li><li>multiple page appliction 多页面应用<ul><li>优点：seo友好</li><li>缺点：复用不好</li></ul></li></ul></li></ul><h4 id="简单实现路由："><a href="#简单实现路由：" class="headerlink" title="简单实现路由："></a>简单实现路由：</h4><ul><li><p>hash</p><p>hash（#）是URL 的锚点，代表的是网页中的一个位置，单单改变#后的部分，浏览器只会滚动到相应位置，不会重新加载网页，也就是说hash 出现在 URL 中，但不会被包含在 http 请求中，对后端完全没有影响，因此改变 hash 不会重新加载页面；同时每一次改变#后的部分，都会在浏览器的访问历史中增加一个记录，使用”后退”按钮，就可以回到上一个位置；</p></li><li><p>Hash模式：通过锚点值的改变，根据不同的值，渲染指定DOM位置的不同数据。</p></li><li><p>监听<code>hashchange</code>变化，修改动态组件的内容</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=<span class="string">&quot;app&quot;</span>&gt;</span><br><span class="line">      &lt;component :newURL=<span class="string">&quot;cur&quot;</span>&gt;&lt;/component&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">import</span>  index <span class="keyword">from</span> <span class="string">&quot;@/pages/index&quot;</span></span><br><span class="line"><span class="keyword">import</span>  car <span class="keyword">from</span> <span class="string">&quot;@/pages/car&quot;</span></span><br><span class="line"><span class="keyword">import</span>  user <span class="keyword">from</span> <span class="string">&quot;@/pages/user&quot;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  name: <span class="string">&#x27;App&#x27;</span>,</span><br><span class="line">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">       cur:<span class="string">&quot;index&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    index,user,car</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> _this = <span class="built_in">this</span>;</span><br><span class="line">      <span class="built_in">window</span>.addEventListener(<span class="string">&quot;hashchange&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(e)</span><br><span class="line">        <span class="keyword">let</span> url = e.newURL.split(<span class="string">&quot;#&quot;</span>)[<span class="number">1</span>].slice(<span class="number">1</span>)</span><br><span class="line">          <span class="keyword">if</span>(url)&#123;</span><br><span class="line">            _this.cur = url;</span><br><span class="line">          &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            _this.cur = <span class="string">&#x27;index&#x27;</span></span><br><span class="line">          &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">*&#123;</span><br><span class="line">  margin: <span class="number">0</span>;</span><br><span class="line">  padding: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></li></ul><h3 id="vue-router"><a href="#vue-router" class="headerlink" title="vue-router"></a>vue-router</h3><ul><li><p>WebApp的链接路径管理系统， 是vue生态圈里非常重要的内容</p></li><li><p>文档地址：<a href="https://router.vuejs.org/zh/">https://router.vuejs.org/zh/</a></p></li><li><p>使用：</p><ul><li><p>安装vue-router</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i vue-router --save</span><br></pre></td></tr></table></figure></li><li><p>在src下面创建router文件夹，下面创建index.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> VueRouter <span class="keyword">from</span> <span class="string">&quot;vue-router&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Vue.use(插件名)   安装插件</span></span><br><span class="line">Vue.use(VueRouter);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入页面组件</span></span><br><span class="line"><span class="keyword">import</span> 组件A <span class="keyword">from</span> <span class="string">&quot;@/pages/组件A&quot;</span></span><br><span class="line"><span class="keyword">import</span> 组件B <span class="keyword">from</span> <span class="string">&quot;@/pages/组件B&quot;</span></span><br><span class="line"><span class="keyword">import</span> 组件C <span class="keyword">from</span> <span class="string">&quot;@/pages/组件C&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例化一个路由对象</span></span><br><span class="line"><span class="keyword">let</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">   routes:[</span><br><span class="line">     &#123; <span class="attr">path</span>:<span class="string">&quot;/a&quot;</span>,<span class="attr">component</span>:组件A &#125;,</span><br><span class="line">     &#123; <span class="attr">path</span>:<span class="string">&quot;/b&quot;</span>,<span class="attr">component</span>:组件B &#125;,</span><br><span class="line">     &#123; <span class="attr">path</span>:<span class="string">&quot;/c&quot;</span>,<span class="attr">component</span>:组件C &#125;,</span><br><span class="line">   ]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>在App.vue 模板里面写入<code>router-view</code>标签，路由地址切换之后对应的组件内容展示在这里</p></li><li><p>使用<code>router-link</code>实现a标签。 to的值就是 路由映射配置里面的path内容</p></li></ul></li><li><p><strong>在脚手架初始项目的时候就选择安装vue-router,自动设计好所有配置</strong></p></li></ul><h3 id="404配置"><a href="#404配置" class="headerlink" title="404配置"></a>404配置</h3><ul><li><p>默认情况下，访问一个没有被定义的路由地址， 页面是不会渲染任何内容。我们可以给他指定到404页面</p></li><li><p>实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">routes:[</span><br><span class="line">   &#123; <span class="attr">path</span>:<span class="string">&quot;*&quot;</span>,<span class="attr">component</span>:<span class="number">404</span>组件 &#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h3 id="激活class"><a href="#激活class" class="headerlink" title="激活class"></a>激活class</h3><ul><li><p>需要设置激活的class， 当前的路由地址和a标签一致的时候，a标签就应该激活</p></li><li><p>实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  linkActiveClass:<span class="string">&#x27;自定义class名&#x27;</span>,   <span class="comment">// 非严格模式  但是可以在某个router-link上面加上exact属性，变成严格模式</span></span><br><span class="line">  linkExactActiveClass:<span class="string">&#x27;自定义class名&#x27;</span>   <span class="comment">// 严格模式</span></span><br><span class="line">routes:[</span><br><span class="line">   &#123; <span class="attr">path</span>:<span class="string">&quot;*&quot;</span>,<span class="attr">component</span>:<span class="number">404</span>组件 &#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">routes:[</span><br><span class="line">&#123; <span class="attr">path</span>:<span class="string">&quot;/地址A&quot;</span>,<span class="attr">redirect</span>:<span class="string">&quot;/地址B&quot;</span> &#125;   <span class="comment">// 访问地址A的时候跳转到地址B</span></span><br><span class="line">]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="命名路由"><a href="#命名路由" class="headerlink" title="命名路由"></a>命名路由</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">routes:[</span><br><span class="line">     &#123; <span class="attr">path</span>:<span class="string">&quot;/地址A&quot;</span>,<span class="attr">component</span>:组件A,  <span class="attr">name</span>:<span class="string">&quot;名称A&quot;</span> &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/地址A&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-link :to&#x3D;&quot;&#123;name:&#39;名称A&#39;&#125;&quot;&gt;&lt;&#x2F;router-link&gt;</span><br></pre></td></tr></table></figure><h3 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h3><ul><li><p>使用场景：</p><ul><li>   新闻列表 到新闻详情     详情需要知道新闻id。</li><li>   新闻分类 到新闻列表    新闻列表需要知道新闻分类id</li><li>   愿望： 实现页面之间的传递参数吗</li></ul></li><li><p>使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  routes:[</span><br><span class="line">   &#123; <span class="attr">path</span>:<span class="string">&quot;/地址A/:标识符&quot;</span>,<span class="attr">component</span>:组件A &#125;,</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/地址A/数据&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 组件A里面</span></span><br><span class="line"><span class="built_in">this</span>.$route.params.标识符</span><br></pre></td></tr></table></figure><p><strong>实现了两个页面之间的传参</strong></p></li><li><p>注意：</p><p>当我们在main.js中将路由挂载到vue实例上面去之后， 所有的组件对象里面都会多两个属性，一个<code>$router</code>,<code>$route</code></p><ul><li><code>$router</code>表示这个路由实例对象</li><li><code>$route</code> 表示当前页面的路由信息<ul><li>this.$route.params   动态路由数据</li><li>this.$route.name   路由名称</li><li>this.$route.meta   元数据</li><li>this.$route.query   search参数</li><li>this.$route.matched   路径信息</li></ul></li></ul></li></ul><h4 id="如何实现页面之间传参"><a href="#如何实现页面之间传参" class="headerlink" title="如何实现页面之间传参"></a>如何实现页面之间传参</h4><ul><li><p>动态路由</p></li><li><p>query传参</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/地址B?key=val&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.$route.query.key</span><br></pre></td></tr></table></figure></li><li><p>本地存储</p><ul><li>localStorage.setItem(“key”,val)</li><li>localStorage.getItem(“key”)</li></ul></li></ul><h2 id="路由升级"><a href="#路由升级" class="headerlink" title="路由升级"></a>路由升级</h2><h3 id="编程式导航"><a href="#编程式导航" class="headerlink" title="编程式导航"></a>编程式导航</h3><ul><li><p>原生JS实现页面跳转方式：</p><ul><li>a   href</li><li>JS    编程式导航<ul><li>location.href   assign   replace</li><li>history.back   forward  go</li></ul></li></ul></li><li><p><strong>$router</strong></p><ul><li><p>push</p></li><li><p>replace</p></li><li><p>go</p></li><li><p>back</p></li><li><p>forward</p></li></ul></li></ul><h3 id="嵌套路由"><a href="#嵌套路由" class="headerlink" title="嵌套路由"></a>嵌套路由</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">routes:[</span><br><span class="line">&#123;</span><br><span class="line">  path:<span class="string">&quot;/地址A&quot;</span>,    <span class="comment">//一级路由</span></span><br><span class="line">  component:组件A,   </span><br><span class="line">  children:[   <span class="comment">// 二级路由， 二级路由的组件 (组件aa，组件bb,组件cc都展示在组件A的模板里面的router-view里面，而不是顶级的router-view)</span></span><br><span class="line">  &#123; <span class="attr">path</span>:<span class="string">&quot;/地址A/aa&quot;</span>,<span class="attr">component</span>:组件aa &#125;,</span><br><span class="line">  &#123; <span class="attr">path</span>:<span class="string">&quot;/地址A/bb&quot;</span>,<span class="attr">component</span>:组件bb &#125;,</span><br><span class="line">  &#123; <span class="attr">path</span>:<span class="string">&quot;/地址A/cc&quot;</span>,<span class="attr">component</span>:组件cc &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 组件A里面一定要有一个router-view</span></span><br><span class="line">(组件aa，组件bb,组件cc都展示在组件A的模板里面的router-view里面，而不是顶级的router-view)</span><br></pre></td></tr></table></figure><h3 id="命名视图"><a href="#命名视图" class="headerlink" title="命名视图"></a>命名视图</h3><ul><li><p>视图就是<code>router-view</code></p></li><li><p>默认情况下： 一个路由只能渲染一个组件到一个指定的位置</p></li><li><p>如果我们希望访问一个路由的时候，同时渲染多个组件到不同位置，这个时候就可以使用命名视图</p></li><li><p>实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">routes:[</span><br><span class="line">&#123;</span><br><span class="line">  path:&quot;&#x2F;地址A&quot;,    &#x2F;&#x2F;一级路由</span><br><span class="line">  components:&#123;</span><br><span class="line">  default:组件A,</span><br><span class="line">  x:组件X,</span><br><span class="line">  y:组件y</span><br><span class="line">  &#125;,   </span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-view</span> <span class="attr">name</span>=<span class="string">&#x27;default&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span>   默认视图，可以不要name属性</span><br><span class="line"><span class="tag">&lt;<span class="name">router-view</span> <span class="attr">name</span>=<span class="string">&#x27;x&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span>   组件x渲染在这</span><br><span class="line"><span class="tag">&lt;<span class="name">router-view</span> <span class="attr">name</span>=<span class="string">&#x27;y&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span>   组件y渲染在这</span><br></pre></td></tr></table></figure></li></ul><h3 id="元信息"><a href="#元信息" class="headerlink" title="元信息"></a>元信息</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">routes:[</span><br><span class="line">&#123; </span><br><span class="line">path:<span class="string">&quot;/地址&quot;</span>,</span><br><span class="line">component:<span class="string">&quot;组件&quot;</span></span><br><span class="line">meta:&#123;  <span class="attr">key</span>:val &#125;   <span class="comment">// 元信息，表示给这个路由设置一些自定义属性</span></span><br><span class="line">&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.$route.meta.key    <span class="comment">// 可以获取数据</span></span><br></pre></td></tr></table></figure><h3 id="导航守卫"><a href="#导航守卫" class="headerlink" title="导航守卫"></a>导航守卫</h3><h4 id="什么是导航守卫"><a href="#什么是导航守卫" class="headerlink" title="什么是导航守卫"></a>什么是导航守卫</h4><p>进入路由、离开路由、更新路由的时候自动执行的函数。 又称之<strong>路由钩子函数</strong></p><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><ul><li>全局守卫<ul><li><strong>前置守卫    路由进入之前会执行的函数  beforeEach</strong><ul><li>设置标题</li><li>权限判断</li></ul></li><li>后置守卫    路由离开后执行的函数   afterEach</li></ul></li><li>局部守卫<ul><li>前置守卫</li><li>更新守卫</li><li>后置守卫</li></ul></li></ul><h3 id="路由懒加载"><a href="#路由懒加载" class="headerlink" title="路由懒加载"></a>路由懒加载</h3><ul><li><p>原来的路由配置文件里面都是通过import 导入所有的组件。这样做，应用开始的时候就会导入这些所有的组件，增加了负担</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Index <span class="keyword">from</span> <span class="string">&quot;@/pages/Index&quot;</span></span><br><span class="line"><span class="keyword">import</span> About <span class="keyword">from</span> <span class="string">&quot;@/pages/About&quot;</span></span><br><span class="line"><span class="keyword">import</span> New <span class="keyword">from</span> <span class="string">&quot;@/pages/New&quot;</span></span><br><span class="line"><span class="keyword">import</span> NewInfo <span class="keyword">from</span> <span class="string">&quot;@/pages/NewInfo&quot;</span></span><br><span class="line"><span class="keyword">import</span> User <span class="keyword">from</span> <span class="string">&quot;@/pages/User&quot;</span></span><br><span class="line"><span class="keyword">import</span> UserOrder <span class="keyword">from</span> <span class="string">&quot;@/pages/UserOrder&quot;</span></span><br><span class="line"><span class="keyword">import</span> UserClass <span class="keyword">from</span> <span class="string">&quot;@/pages/UserClass&quot;</span></span><br><span class="line"><span class="keyword">import</span> UserSet <span class="keyword">from</span> <span class="string">&quot;@/pages/UserSet&quot;</span></span><br><span class="line"><span class="keyword">import</span> UserIndex <span class="keyword">from</span> <span class="string">&quot;@/pages/UserIndex&quot;</span></span><br><span class="line"><span class="keyword">import</span> NotFound <span class="keyword">from</span> <span class="string">&quot;@/pages/NotFound&quot;</span></span><br><span class="line"><span class="keyword">import</span> Adv <span class="keyword">from</span> <span class="string">&quot;@/components/Adv&quot;</span></span><br><span class="line"><span class="keyword">import</span> Login <span class="keyword">from</span> <span class="string">&quot;@/pages/Login&quot;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>希望打开哪个路由地址的时候就再去加载对应的路由组件。 这就是路由懒加载</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> 组件名 <span class="keyword">from</span> <span class="string">&quot;@/pages/组件名&quot;</span></span><br><span class="line">&#123;</span><br><span class="line">  path:<span class="string">&quot;/地址&quot;</span>,</span><br><span class="line">  component:组件名</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> path:<span class="string">&quot;/地址&quot;</span>,</span><br><span class="line"> component:<span class="function">()=&gt;</span><span class="keyword">import</span>(<span class="string">&quot;@/pages/组件名&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
          <category> Vue2 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> Vue2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue - 组件通信</title>
      <link href="2020/09/27/Vue-components-communication/"/>
      <url>2020/09/27/Vue-components-communication/</url>
      
        <content type="html"><![CDATA[<h2 id="父子通信"><a href="#父子通信" class="headerlink" title="父子通信"></a>父子通信</h2><h3 id="实现：-自定义属性"><a href="#实现：-自定义属性" class="headerlink" title="实现： 自定义属性"></a>实现： 自定义属性</h3><ul><li><p>使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 子组件里面</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  props:[<span class="string">&#x27;属性名1&#x27;</span>,<span class="string">&#x27;属性名2&#x27;</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子模板里面</span></span><br><span class="line">&#123;&#123;属性名<span class="number">1</span>&#125;&#125;   &#123;&#123;属性名<span class="number">2</span>&#125;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--父组件里面--&gt;</span></span><br><span class="line">&lt;子组件  属性名1=&quot;值&quot;   :属性名2=&quot;变量&quot; /&gt;</span><br></pre></td></tr></table></figure><p><img src="/images/vue-components/img1.png"></p></li></ul><p><strong>为了保证组件内部数据的统一性，我们要对组件的自定义属性，进行类型的验证！</strong></p><h3 id="props验证"><a href="#props验证" class="headerlink" title="props验证"></a>props验证</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">props:[<span class="string">&#x27;属性名&#x27;</span>]    <span class="comment">// 尽量不要使用数组模式</span></span><br><span class="line"></span><br><span class="line">props:&#123;  <span class="comment">// 对象模式</span></span><br><span class="line">  属性名:类型,</span><br><span class="line">  属性名:[类型<span class="number">1</span>,类型<span class="number">2</span>],  </span><br><span class="line">  属性名:&#123;</span><br><span class="line">     type:类型,  <span class="comment">// 单类型       // 类型校验</span></span><br><span class="line">     type:[类型<span class="number">1</span>,类型<span class="number">2</span>],  <span class="comment">// 多类型</span></span><br><span class="line">     <span class="keyword">default</span>:默认值    <span class="comment">// 默认值</span></span><br><span class="line">     <span class="function"><span class="title">default</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> 对象/数组</span><br><span class="line">     &#125;,</span><br><span class="line">     required:<span class="literal">true</span>/<span class="literal">false</span>,  <span class="comment">// 是否必须</span></span><br><span class="line">     <span class="function"><span class="title">validator</span>(<span class="params">val</span>)</span>&#123;     <span class="comment">// 自定义校验函数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>/<span class="literal">false</span></span><br><span class="line">     &#125;  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>哪些类型？</strong></p><ul><li><code>String</code></li><li><code>Number</code></li><li><code>Boolean</code></li><li><code>Array</code></li><li><code>Object</code></li><li><code>Date</code></li><li><code>Function</code></li><li><code>Symbol</code></li></ul><h4 id="单向数据流"><a href="#单向数据流" class="headerlink" title="单向数据流"></a>单向数据流</h4><p>所有的 prop 都使得其父子 prop 之间形成了一个<strong>单向下行绑定</strong>：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。这样会<strong>防止从子组件意外变更父级组件的状态，从而导致你的应用的数据流向难以理解。</strong></p><p><strong>修改props，不是真的修改</strong></p><ul><li><p><strong>props 用来传递一个初始值赋给组件的data</strong></p></li><li><p><strong>props 赋给计算属性</strong></p></li><li><p>传入一个对象的所有property</p><p>如果你想要将一个对象的所有 property 都作为 prop 传入，你可以使用不带参数的 <code>v-bind</code> (取代 <code>v-bind:prop-name</code>)。例如，对于一个给定的对象 <code>post</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">post: &#123;</span><br><span class="line">  id: <span class="number">1</span>,</span><br><span class="line">  title: <span class="string">&#x27;My Journey with Vue&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面的模板：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">blog-post</span> <span class="attr">v-bind</span>=<span class="string">&quot;post&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br></pre></td></tr></table></figure><p>等价于：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;blog-post</span><br><span class="line">  v-bind:id=&quot;post.id&quot;</span><br><span class="line">  v-bind:title=&quot;post.title&quot;</span><br><span class="line">&gt;<span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>总结：</strong></p><ul><li>props的使用</li><li>props验证</li><li>单项数据流</li></ul></li></ul><h2 id="子父通信"><a href="#子父通信" class="headerlink" title="子父通信"></a>子父通信</h2><h3 id="实现：-自定义事件"><a href="#实现：-自定义事件" class="headerlink" title="实现： 自定义事件"></a>实现： 自定义事件</h3><ul><li><p>使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父的模板里面</span></span><br><span class="line">&lt;子组件名 @自定义事件名=<span class="string">&quot;父的事件函数&quot;</span> /&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父的JS里面</span></span><br><span class="line">methods:&#123;</span><br><span class="line">父的事件函数(形参)&#123;</span><br><span class="line">     ....</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.$emit(<span class="string">&quot;自定义事件名&quot;</span>,实参)    <span class="comment">// 本质调用了，父的事件函数</span></span><br></pre></td></tr></table></figure><p><img src="/images/vue-components/img2.png"></p><p><img src="/images/vue-components/img3.png"></p></li></ul><h2 id="祖先后代通信"><a href="#祖先后代通信" class="headerlink" title="祖先后代通信"></a>祖先后代通信</h2><ul><li><p>目的： 实现祖先的数据，后代都可以使用（一般用于全局变量）</p></li><li><p>实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 祖先组件</span></span><br><span class="line">provide:&#123;</span><br><span class="line">key1:val1,</span><br><span class="line">key2:val2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 后代任意组件中</span></span><br><span class="line">inject:[key1,key2]      </span><br><span class="line">inject:&#123;</span><br><span class="line">  newkey:&#123;</span><br><span class="line">     <span class="keyword">from</span>:key1,</span><br><span class="line">     <span class="keyword">default</span>:<span class="string">&quot;默认值&quot;</span>  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;&#123;key1&#125;&#125;    &#123;&#123;key2&#125;&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="非父子通信"><a href="#非父子通信" class="headerlink" title="非父子通信"></a>非父子通信</h2><ul><li><p>实现任意两个组件之间的通信！</p></li><li><p>核心：<strong>利用vue里面的$emit 和 $on 实现 组件的监听事件和触发事件</strong></p></li><li><p>实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js中</span></span><br><span class="line"><span class="keyword">let</span> bus = <span class="keyword">new</span> Vue();</span><br><span class="line"><span class="comment">// 在Vue的原型上面添加数据，所有的组件里都可以获取到</span></span><br><span class="line">Vue.prototype.$bus = bus</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 任意组件中  事件订阅</span></span><br><span class="line"><span class="function"><span class="title">created</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="built_in">this</span>.$bus.$on(<span class="string">&#x27;自定义事件名&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">形参</span>)</span>&#123;</span><br><span class="line">       ...</span><br><span class="line">   &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 任意其他组件中  事件发布</span></span><br><span class="line"><span class="built_in">this</span>.$bus.$emit(<span class="string">&#x27;自定义事件名&#x27;</span>,实参)</span><br></pre></td></tr></table></figure></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>父子通信<ul><li>自定义属性（props）、自定义事件（$emit）</li></ul></li><li>祖先后代<ul><li>provide （祖先）</li><li>inject (后代)</li></ul></li><li>非父子<ul><li>$on  和  $emit     自定义事件</li></ul></li><li>本地存储</li><li>父子关系<ul><li>$parent</li><li>$children、$refs</li></ul></li><li>vuex</li></ul>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
          <category> Vue2 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> Vue2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue - computed和watch的区别</title>
      <link href="2020/09/27/Vue-computed-vs-watch/"/>
      <url>2020/09/27/Vue-computed-vs-watch/</url>
      
        <content type="html"><![CDATA[<h2 id="computed-计算属性"><a href="#computed-计算属性" class="headerlink" title="computed 计算属性"></a>computed 计算属性</h2><blockquote><p>计算属性 ，用来计算出一个值，这个值在调用的时候会根据依赖的数据显示新的计算结果并自动缓存。 如果依赖不变，computed中的值就不会重新计算。</p></blockquote><h3 id="什么是计算属性，为什么要使用"><a href="#什么是计算属性，为什么要使用" class="headerlink" title="什么是计算属性，为什么要使用"></a>什么是计算属性，为什么要使用</h3><ul><li>计算属性含义： <strong>本质还是属性，用来在模板中展示</strong> </li><li>计算属性其实和data的地位相同，都是vue实例的属性，都可以在模板中使用</li><li>出现的原因：一般在模板语法内使用表达式非常方便，模板也只是用于简单的运算，当表达式过于复杂时，在模板中放入太多逻辑会让模板过重且难以维护。为此，Vue提供了计算属性computed。</li></ul><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">computed:&#123;</span><br><span class="line">  属性名:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"> <span class="keyword">return</span> 值</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;&#123;属性名&#125;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; msg.split(<span class="string">&quot;&quot;</span>).reverse().join(<span class="string">&quot;&quot;</span>) &#125;&#125;     <span class="comment">// 模板过重且难以维护</span></span><br><span class="line"></span><br><span class="line">&#123;&#123; haha &#125;&#125;</span><br><span class="line"></span><br><span class="line">computed:&#123;</span><br><span class="line">  haha:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;      </span><br><span class="line">     <span class="keyword">return</span> <span class="built_in">this</span>.msg.split(<span class="string">&quot;&quot;</span>).reverse().join(<span class="string">&quot;&quot;</span>)</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="修改计算属性"><a href="#修改计算属性" class="headerlink" title="修改计算属性"></a>修改计算属性</h3><ul><li>计算属性默认只有 <code>getter</code>，不可修改</li><li>如果需要修改，可以提供一个 <code>setter</code></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">computed:&#123;</span><br><span class="line">    fullName: &#123;</span><br><span class="line">    <span class="comment">// getter</span></span><br><span class="line">    get: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.firstName + <span class="string">&#x27; &#x27;</span> + <span class="built_in">this</span>.lastName</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// setter</span></span><br><span class="line">    set: <span class="function"><span class="keyword">function</span> (<span class="params">newValue</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> names = newValue.split(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">      <span class="built_in">this</span>.firstName = names[<span class="number">0</span>]</span><br><span class="line">      <span class="built_in">this</span>.lastName = names[names.length - <span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再运行 <code>vm.fullName = &#39;John Doe&#39;</code> 时，setter 会被调用，<code>vm.firstName</code> 和 <code>vm.lastName</code> 也会相应地被更新。</p><h2 id="watch-侦听器"><a href="#watch-侦听器" class="headerlink" title="watch 侦听器"></a>watch 侦听器</h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>对data里面的数据进行监听处理。</p><h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><p>一个对象，键是需要观察的表达式（<strong>data内的数据</strong>），值是对应回调函数。值也可以是方法名，或者包含选项的对象。</p><p>当数据发生改变时，会执行一个回调，它有两个参数， newVal 和 oldVal</p><p>watch 有两个属性：</p><ul><li><code>immediate</code> 是否在第一次渲染时执行这个函数，会在监听开始之后就立即本调用。</li><li><code>deep</code> 是否要看这个对象里面的属性变化。</li></ul><h4 id="浅监听"><a href="#浅监听" class="headerlink" title="浅监听"></a>浅监听</h4><p> 监听基础数据类型</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">watch:&#123;</span><br><span class="line">变量名(newval,oldval)&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="深监听"><a href="#深监听" class="headerlink" title="深监听"></a>深监听</h4><p>监听引用数据类型</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">watch:&#123;</span><br><span class="line">  变量名:&#123;</span><br><span class="line">    deep:<span class="literal">true</span>,</span><br><span class="line">    handler:<span class="function"><span class="keyword">function</span>(<span class="params">newval</span>)</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="computed-和-methods-的区别"><a href="#computed-和-methods-的区别" class="headerlink" title="computed 和 methods 的区别"></a>computed 和 methods 的区别</h2><ul><li>计算属性是基于他们的响应式依赖进行缓存的，只在相关响应式依赖发生改变时，才会重新求值（也就是说，计算属性会把数据进行缓存）</li><li>而方法不会把数据进行缓存， 每次都会执行，所以用计算属性效率会更高点</li></ul><p><strong>所以，对于任何复杂逻辑，都应该使用计算属性</strong></p><p>在某些情况，我们可能需要对数据进行一些转化后再显示，或者需要将多个数据结合起来进行显示</p><ul><li><p>比如我们有firstName和lastName两个变量，我们需要显示完整的名称。</p></li><li><p>但是如果多个地方都需要显示完整的名称，我们就需要写多个</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;firstName + &#x27; &#x27; + lastName&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;firstName&#125;&#125; &#123;&#123;lastName&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;getFullName()&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;fullName&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../js/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line"><span class="javascript">      firstName: <span class="string">&#x27;Lron&#x27;</span>,</span></span><br><span class="line"><span class="javascript">      lastName: <span class="string">&#x27;Man&#x27;</span></span></span><br><span class="line">    &#125;,</span><br><span class="line"><span class="javascript">    <span class="comment">// 推荐使用计算属性来操作，因为它会将这些数据进行缓存， 无论打印多少次，它只会调用一次</span></span></span><br><span class="line">    computed: &#123;</span><br><span class="line"><span class="javascript">    <span class="comment">//  计算属性   注意 : 计算的是 属性, </span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 所以这里面的属性 看成一个 对象(用名词形式来表达), 调用时候不用加小括号</span></span></span><br><span class="line"><span class="javascript">      fullName: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> <span class="built_in">this</span>.firstName + <span class="string">&#x27; &#x27;</span> + <span class="built_in">this</span>.lastName</span></span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line"><span class="javascript">      <span class="comment">//  不会缓存， 所以有多少次就调用多少次，  没有 computed 划算</span></span></span><br><span class="line"><span class="javascript">      getFullName: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> <span class="built_in">this</span>.firstName + <span class="string">&#x27; &#x27;</span> + <span class="built_in">this</span>.lastName</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="computed-和-watch-的区别"><a href="#computed-和-watch-的区别" class="headerlink" title="computed 和 watch 的区别"></a>computed 和 watch 的区别</h2><ul><li><p><code>computed</code> 是为了简化模板里面的操作，对数据处理后进行展示：由data中的已知值，得到的一个新值；</p><p><code>watch</code>目的是监听data中已知值的变化，执行响应的逻辑处理。</p></li><li><p><code>computed</code>擅长处理的场景：一个数据受多个数据影响；</p><p><code>watch</code>擅长处理的场景：一个数据影响多个数据</p></li></ul><p>如果有一些数据需要随着其它数据变动而变动时， <code>watch</code>就会显得非常冗余，官方文档给出了如下的示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#demo&#x27;</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    firstName: <span class="string">&#x27;Foo&#x27;</span>,</span><br><span class="line">    lastName: <span class="string">&#x27;Bar&#x27;</span>,</span><br><span class="line">    fullName: <span class="string">&#x27;Foo Bar&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  watch: &#123;</span><br><span class="line">    firstName: <span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.fullName = val + <span class="string">&#x27; &#x27;</span> + <span class="built_in">this</span>.lastName</span><br><span class="line">    &#125;,</span><br><span class="line">    lastName: <span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.fullName = <span class="built_in">this</span>.firstName + <span class="string">&#x27; &#x27;</span> + val</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#demo&#x27;</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    firstName: <span class="string">&#x27;Foo&#x27;</span>,</span><br><span class="line">    lastName: <span class="string">&#x27;Bar&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    fullName: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.firstName + <span class="string">&#x27; &#x27;</span> + <span class="built_in">this</span>.lastName</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><p>如果一个数据需要经过复杂计算就用 <code>computed</code></p></li><li><p>如果一个数据需要在发生变化时做一些逻辑就用 <code>watch</code></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
          <category> Vue2 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> Vue2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES6知识点总结</title>
      <link href="2020/09/26/es6-notes/"/>
      <url>2020/09/26/es6-notes/</url>
      
        <content type="html"><![CDATA[<h2 id="let、const和var的作用和区别"><a href="#let、const和var的作用和区别" class="headerlink" title="let、const和var的作用和区别"></a>let、const和var的作用和区别</h2><h3 id="var"><a href="#var" class="headerlink" title="var"></a>var</h3><ul><li>声明变量 ，声明的变量可以重复声明，同一作用域下，后声明的会覆盖前声明的，</li><li>有变量提升的特点</li></ul><h3 id="let"><a href="#let" class="headerlink" title="let"></a>let</h3><ul><li><p>没有变量提升，必须先声明再使用，</p></li><li><p>同一作用域下不能重复声明同一个变量名，会报错。可以重新赋值。</p></li><li><p>let声明的变量产生一个块级作用域。</p><ul><li>块级作用域：在js中成每个花括号之间的叫代码块 –{   代码块   }，{}的区域叫块级作用域，在每一个{}内let声明出来的变量只能在这个{}中访问到。</li></ul></li><li><p><strong>暂时性死区</strong></p><ul><li>简而言之：在代码块内，使用<code>let</code>命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”</li><li>当程序的控制流程在新的作用域进行实例化时，在此作用域中用let/const声明的变量会先在作用域中被创建出来。但因这时还未进行词法绑定，所以是不能访问的，如果访问就会报错。因此，在这运行流程进入作用域创建变量，到变量可以被访问之间的这一段时间，就称之为暂时性死区</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a) <span class="comment">//会报错，因为该代码块内有一个let，所以使该块区形成了一个封闭的作用域，a在使用let声明前不能被调用</span></span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">30</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><ul><li>没有变量提升，必须声明在使用</li><li>用于声明常量，初始化时一定要赋值，声明之后不能再重复声明也不能再赋值。<ul><li>注意用const声明引用类型时（对象、数组）：对象和数组内部的项可以修改。也不能直接给对象、数组的变量名重新赋值  –不能 obj= 10</li></ul></li><li>会产生块级作用域，暂时性死区。</li></ul><h3 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h3><ul><li><p>局部作用域又叫（函数作用域），全局作用域和局部作用域都是相对函数内外而定义的。</p></li><li><p>console.time()   ……… console.timeEnd()可以控制台打印中间代码执行的时间。</p></li><li><p>循环变量时循环内部的处理函数，拿到的都是循环结束之后的最终变量值</p><ul><li>解决：<ul><li> 闭包：可以将闭包内部变量不会直接垃圾回收，而会存储在内存中，这样使用的时候就是上次存的变量值，而不是循环结束之后最终的变量值。</li><li> let：而let本身就  有块级作用域的特点，所以相当于闭包，在块级作用域使用的时候也会把值存到内存中。  </li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//let的应用场景</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i) <span class="comment">//打印5个5</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i) <span class="comment">// 0-4</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//注：若用var声明循环变量，还可用匿名函数自执行的方式解决</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">    ;(<span class="function"><span class="keyword">function</span>(<span class="params">i</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(i) <span class="comment">// 0-4</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)(i)<span class="comment">//将i值传到匿名函数中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="变量的解构赋值"><a href="#变量的解构赋值" class="headerlink" title="变量的解构赋值"></a>变量的解构赋值</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul><li>ES6 允许按照<strong>一定模式</strong>，从<strong>数组</strong>和<strong>对象</strong>中提取值，对变量进行赋值，这被称为解构—–要求*<strong>模式匹配</strong></li></ul><h3 id="数组解构赋值"><a href="#数组解构赋值" class="headerlink" title="数组解构赋值"></a>数组解构赋值</h3><p>有序— 按位置对应</p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li><p>完全解构：值与变量对应</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a,b,c] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br></pre></td></tr></table></figure></li><li><p>不完全解构：值比变量多</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a]=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]  --- a = <span class="number">1</span></span><br><span class="line"><span class="comment">//缺省</span></span><br><span class="line"><span class="keyword">let</span> [,,a]= [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] --- a=<span class="number">3</span></span><br></pre></td></tr></table></figure></li><li><p>解构失败：变量比值多</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a,b,c] = [<span class="number">1</span>] </span><br><span class="line">返回值：a=<span class="number">1</span>,b=undefind,c=undefind</span><br></pre></td></tr></table></figure></li><li><p><strong>拓展默认值</strong></p><ul><li>—解构失败的情况下，变量如果有默认值的情况下就显示默认值，有值的时候显示值</li><li>赋值为undefined时默认值生效，赋值为null时默认值不生效</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a=<span class="number">1</span>,b=<span class="number">2</span>,c=<span class="number">3</span>] = [<span class="number">10</span>]<span class="comment">// 返回 a=10,b=2,c=3；</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [a=<span class="number">1</span>,b=<span class="number">2</span>,c=<span class="number">3</span>] = [<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>] <span class="comment">//返回a=10,b=20,c=30；</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [a=<span class="number">1</span>,b=<span class="number">2</span>,c=<span class="number">3</span>]=[<span class="number">10</span>,<span class="literal">undefined</span>,<span class="literal">undefined</span>] <span class="comment">//返回a=10,b=2,c=3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [a=<span class="number">1</span>,b=<span class="number">2</span>,c=<span class="number">3</span>]=[<span class="number">10</span>,<span class="literal">null</span>,<span class="literal">null</span>] <span class="comment">//返回a=10,b=null,c=null</span></span><br></pre></td></tr></table></figure><ul><li>默认值可以引用解构赋值的其他变量，但该变量必须已经声明</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [x = <span class="number">1</span>, y = x] = []; <span class="comment">// x=1;y=1</span></span><br><span class="line"><span class="keyword">let</span> [x = <span class="number">1</span>, y = x] = [<span class="number">2</span>]; <span class="comment">//x=2;y=2</span></span><br><span class="line"><span class="keyword">let</span> [x = <span class="number">1</span>, y = x] = [<span class="number">1</span>,<span class="number">2</span>]; <span class="comment">//x=1;y=2</span></span><br><span class="line"><span class="keyword">let</span> [x = y, y = <span class="number">1</span>] = [];<span class="comment">//ReferenceError: y is not defined </span></span><br><span class="line"><span class="comment">//最后一个表达式之所以会报错，是因为x用y做默认值时，y还没有声明</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h4><ul><li><p>数组的解构赋值，可以做数据交换</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">10</span> ;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">20</span> ;</span><br><span class="line">[a,b] = [b ,a]</span><br></pre></td></tr></table></figure></li></ul><h3 id="对象解构赋值"><a href="#对象解构赋值" class="headerlink" title="对象解构赋值"></a>对象解构赋值</h3><p><strong>无序 – 匹配属性名</strong></p><h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><ul><li>无序集合，必须按照属性 名匹配 ，所以解构中也没有缺省的情况。</li><li>完全解构，不完全解构、默认值和数组一样</li></ul><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><ul><li><p><strong>对象解构的作用</strong>：适用于取值，和函数的参数适用 </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">let</span> data = &#123;</span><br><span class="line">    username: <span class="string">&quot;xiaoming&quot;</span>,</span><br><span class="line">    age: <span class="number">18</span>,</span><br><span class="line">    address: <span class="string">&quot;长沙&quot;</span>,</span><br><span class="line">    sex: <span class="string">&quot;man&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> &#123;</span><br><span class="line">    username,</span><br><span class="line">    age</span><br><span class="line">&#125; = data;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(username, age)  <span class="comment">//xiaoming 18</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h4 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h4><ul><li><p>如果要将一个已经声明的变量用于解构赋值，必须非常小心</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误的写法</span></span><br><span class="line"><span class="keyword">let</span> x;</span><br><span class="line">&#123;x&#125; = &#123;<span class="attr">x</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="comment">// SyntaxError: syntax error</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>报错的原因：JavaScript引擎会将{x}理解成一个代码块，从而发生语法错误。只有不将大括号写在行首，避免JS将其解释为代码块，才能解决这个问题</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x;</span><br><span class="line">(&#123;x&#125; = &#123;<span class="attr">x</span>: <span class="number">1</span>&#125;)</span><br></pre></td></tr></table></figure></li></ul><h3 id="拓展-函数参数的解构赋值"><a href="#拓展-函数参数的解构赋值" class="headerlink" title="拓展 函数参数的解构赋值"></a>拓展 函数参数的解构赋值</h3><ul><li><p>函数的参数也可以适用解构赋值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">[x,y]</span>)</span>&#123;<span class="comment">//</span></span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line">add([<span class="number">1</span>,<span class="number">2</span>]);<span class="comment">//传入参数的那一刻，数组参数就被解构成x和y。对于函数内部的代码来说，参数就是x和y</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h2><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><p>``两个反 引号，变量用${  变量  }包裹  ，</p><h4 id="优点"><a href="#优点" class="headerlink" title="优点:"></a>优点:</h4><ul><li>换行不需要使用换行符，可以直接写html结构，</li><li>不需要考虑单双引号嵌套问题</li><li>${}里面也可以自己写js语句；</li><li>方便简洁不容易出错</li></ul><h2 id="对象的扩展"><a href="#对象的扩展" class="headerlink" title="对象的扩展"></a>对象的扩展</h2><h3 id="对象的简写"><a href="#对象的简写" class="headerlink" title="对象的简写"></a>对象的简写</h3><h4 id="对象属性的简写"><a href="#对象属性的简写" class="headerlink" title="对象属性的简写"></a>对象属性的简写</h4><ul><li><p>属性名和属性值的变量名相同的情况下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> username = <span class="string">&quot;xiaoming&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> age = <span class="number">18</span>;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    username,</span><br><span class="line">    age</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(obj)</span><br></pre></td></tr></table></figure></li></ul><h4 id="对象方法的简写"><a href="#对象方法的简写" class="headerlink" title="对象方法的简写"></a>对象方法的简写</h4><ul><li><p>省略冒号和function</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="function"><span class="title">eat</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;红烧肉&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.eat()</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h4 id="对象表达式"><a href="#对象表达式" class="headerlink" title="对象表达式"></a>对象表达式</h4><ul><li><p>一般情况下：[]使用的是变量，表达式，属性为数字时也使用[]</p></li><li><p>obj[]—[]里面放的是变量不是属性名，如果使用[]要获取属性名，[]里就要加字符串，也就是变量需要加引号，  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> username = <span class="string">&quot;hello&quot;</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    username: <span class="string">&quot;a&quot;</span>,</span><br><span class="line">    [username]: <span class="string">&quot;b&quot;</span>,</span><br><span class="line">    <span class="number">10</span>: <span class="string">&quot;world&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(obj) <span class="comment">// &#123;10: &quot;world&quot;, username: &quot;a&quot;, hello: &quot;b&quot;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.username)  <span class="comment">//a</span></span><br><span class="line"><span class="built_in">console</span>.log(obj[<span class="string">&#x27;username&#x27;</span>]) <span class="comment">//a</span></span><br><span class="line"><span class="built_in">console</span>.log(obj[username]) <span class="comment">//b</span></span><br><span class="line">obj[<span class="string">&quot;a&quot;</span> + <span class="string">&quot;b&quot;</span>] = <span class="string">&quot;ab&quot;</span>; <span class="comment">//添加了一个属性名为ab的属性</span></span><br><span class="line"><span class="built_in">console</span>.log(obj)  <span class="comment">// &#123;10: &quot;world&quot;, username: &quot;a&quot;, hello: &quot;b&quot;, ab: &quot;ab&quot;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj[<span class="number">10</span>])  <span class="comment">//world</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h3 id="对象的方法"><a href="#对象的方法" class="headerlink" title="对象的方法"></a>对象的方法</h3><ul><li><p>数组的拼接：cancat()</p></li><li><p>对象拼接Object.assign(): 可以实现对象的浅拷贝</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一个参数是目标对象,从第二个参数开始就要拼接的对象</span></span><br><span class="line"><span class="keyword">let</span> o1 = &#123;</span><br><span class="line">    a: <span class="number">10</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> o2 = &#123;</span><br><span class="line">    b: <span class="number">20</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Object</span>.assign(o1, o2, &#123;</span><br><span class="line">    c: <span class="number">30</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(o1)<span class="comment">//&#123;a: 10, b: 20, c: 30&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>Object.keys() 返回的是一个数组,数组里面是对象所有的属性名</p></li><li><p>Object.values() 返回的是一个数组,数组里面是对象所有的值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> o = &#123;</span><br><span class="line">    a: <span class="number">10</span>,</span><br><span class="line">    b: <span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.keys(o)) <span class="comment">//[&quot;a&quot;, &quot;b&quot;]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.values(o))  <span class="comment">//[10, 20]</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="对象属性的设置"><a href="#对象属性的设置" class="headerlink" title="对象属性的设置"></a>对象属性的设置</h3><ul><li><p>获取对象中某个属性的描述对象；</p></li><li><p>设置对象中的某一个属性的特性：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数据劫持 vue</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    a: <span class="number">10</span>,</span><br><span class="line">    b: <span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取对象中的某个属性的设置</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, <span class="string">&quot;a&quot;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">&quot;a&quot;</span>, &#123;</span><br><span class="line">    writable: <span class="literal">false</span>, <span class="comment">// 值是否可以重写</span></span><br><span class="line">    enumerable: <span class="literal">false</span>, <span class="comment">// 是否可以循环遍历</span></span><br><span class="line">    value: <span class="string">&quot;world&quot;</span>,</span><br><span class="line">    configurable: <span class="literal">false</span> <span class="comment">// 是否可以重新修改属性的设置</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">obj.a = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="函数拓展"><a href="#函数拓展" class="headerlink" title="函数拓展"></a>函数拓展</h2><h3 id="函数默认值"><a href="#函数默认值" class="headerlink" title="函数默认值"></a>函数默认值</h3><ul><li><p>直接在形参上进行赋值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">x = <span class="string">&quot;hello&quot;</span></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn(<span class="number">10</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>特点</p><ul><li>不传实参，默认值生效</li><li>传递undefined，默认值生效</li><li>传递null，默认值不生效</li></ul></li><li><p>注意参数的位置</p><p>在参数传递过程中，要注意位置问题；</p><p>如果是最后一个参数的话，可以忽略不传递实参；</p><p>但是其他位置的话，要用undefined；</p><ul><li>解决方法1：有默认值的参数放到最后</li><li>解决方法2：形参和实参都以对象的形式（对象解构赋值）</li></ul></li></ul><h3 id="rest剩余参数"><a href="#rest剩余参数" class="headerlink" title="rest剩余参数"></a>rest剩余参数</h3><ul><li><p>语法：…变量名</p><ul><li>返回的是一个数组，接收的是没有形参接收的值</li><li>剩余参数必须写在形参的最后。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">x, y, ...rest</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(rest)  <span class="comment">//[3,4,5]</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">Array</span>.isArray(rest))  <span class="comment">//true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure></li></ul><h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数*"></a>箭头函数*</h3><h4 id="语法："><a href="#语法：" class="headerlink" title="语法："></a>语法：</h4><ul><li><p>箭头左边（参数）</p><ul><li>一个参数的情况（）括号可以省略</li></ul></li><li><p>箭头右边（函数的执行代码）</p><ul><li>执行代码只有一句话的时候{}和return可以省略，但是对象要注意，加上（）避免代码歧义。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="params">v</span> =&gt;</span> v;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> (<span class="params">v</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> v;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f = <span class="function">() =&gt;</span> <span class="number">5</span>;<span class="comment">//不需要参数或需要多个参数，就使用一个圆括号代表参数部分。</span></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="number">5</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sum = <span class="function">(<span class="params">num1, num2</span>) =&gt;</span> num1 + num2;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">var</span> sum = <span class="function"><span class="keyword">function</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号，否则会报错。</span></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">let</span> getTempItem = <span class="function"><span class="params">id</span> =&gt;</span> &#123; <span class="attr">id</span>: id, <span class="attr">name</span>: <span class="string">&quot;Temp&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不报错</span></span><br><span class="line"><span class="keyword">let</span> getTempItem = <span class="function"><span class="params">id</span> =&gt;</span> (&#123; <span class="attr">id</span>: id, <span class="attr">name</span>: <span class="string">&quot;Temp&quot;</span> &#125;);</span><br></pre></td></tr></table></figure></li></ul><h4 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h4><ul><li><p>this指向的是定义<strong>this</strong>所在的对象，并且call、apply、bind是无法改变this的指向，</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="function"><span class="title">fn</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    f1: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>) <span class="comment">// window</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.fn() <span class="comment">//this</span></span><br><span class="line">obj.f1() <span class="comment">// window</span></span><br></pre></td></tr></table></figure><ul><li>this是固定的=&gt;有利于封装回调函数；</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将DOM事件的回调函数封装在一个对象里</span></span><br><span class="line"><span class="keyword">var</span> handler = &#123;</span><br><span class="line">  id: <span class="string">&#x27;123456&#x27;</span>,</span><br><span class="line"></span><br><span class="line">  init: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">document</span>.addEventListener(<span class="string">&#x27;click&#x27;</span>,</span><br><span class="line">      event =&gt; <span class="built_in">this</span>.doSomething(event.type), <span class="literal">false</span>);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  doSomething: <span class="function"><span class="keyword">function</span>(<span class="params">type</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Handling &#x27;</span> + type  + <span class="string">&#x27; for &#x27;</span> + <span class="built_in">this</span>.id);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//使用了箭头函数，导致这个箭头函数里面的this，总是指向handler对象。否则，回调函数运行时，this.doSomething这一行会报错，因为此时this指向document对象</span></span><br></pre></td></tr></table></figure></li><li><p>箭头函数不能当做构造函数使用，不能使用<strong>new</strong>命令</p></li><li><p>箭头函数没有<strong>prototype</strong>显示原型；</p></li><li><p>箭头函数不能使用<strong>arguments</strong>，在遇到不定参的情况使用剩余参数代替（…变量名）；</p></li></ul><h4 id="不适用场景"><a href="#不适用场景" class="headerlink" title="不适用场景"></a>不适用场景</h4><ul><li><p>对象中方法的简写不要使用箭头函数</p></li><li><p>事件绑定函数，要谨慎使用箭头函数</p></li></ul><h3 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h3><ul><li><p>关键字   use strict ;    必须放在第一行</p></li><li><p>规则</p><ul><li> 变量先声明再使用</li><li> 不允许指向全局对象，返回的是undefined</li><li>对arguments的限制：<ul><li>不允许重新赋值</li><li>不再追踪参数的变化</li><li>arguments.callee返回的是函数的本身，但是在严格模式下，不允许使用；</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// arguments=10;</span></span><br><span class="line">    num++;</span><br><span class="line">    <span class="built_in">console</span>.log(num)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>对于只读属性重新赋值是会报错的</p></li></ul><h2 id="数组拓展"><a href="#数组拓展" class="headerlink" title="数组拓展"></a>数组拓展</h2><h3 id="拓展运算符…"><a href="#拓展运算符…" class="headerlink" title="拓展运算符…"></a>拓展运算符…</h3><h4 id="…"><a href="#…" class="headerlink" title="…"></a>…</h4><ul><li><p>拓展运算符是三个点(…)</p></li><li><p>剩余参数的逆运用，将数组转换为参数序列</p></li></ul><h4 id="数组运用"><a href="#数组运用" class="headerlink" title="数组运用"></a>数组运用</h4><ul><li><p>数组去重</p></li><li><p>拉平多维数组(推荐使用flat())</p></li><li><p>实现浅拷贝</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数组去重</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>];</span><br><span class="line"><span class="built_in">console</span>.log([...new <span class="built_in">Set</span>(arr)])</span><br><span class="line"></span><br><span class="line"><span class="comment">//拉平多维数组</span></span><br><span class="line"><span class="keyword">let</span> arr = [</span><br><span class="line">    [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">    [<span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">];</span><br><span class="line"><span class="keyword">let</span> newArr = []</span><br><span class="line">arr.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">    newArr.push(...item)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(newArr)</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现浅拷贝</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> arr2 = [...arr];</span><br><span class="line">arr[<span class="number">0</span>] = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(arr, arr2)</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h4 id="对象运用"><a href="#对象运用" class="headerlink" title="对象运用"></a>对象运用</h4><ul><li><p>对象浅拷贝</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">let</span> obj = &#123;</span><br><span class="line">    a: <span class="number">10</span>,</span><br><span class="line">    b: <span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj2 = &#123;...obj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>模拟vuex</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> mapState = &#123;</span><br><span class="line">userInfo: &#123;</span><br><span class="line">    username: <span class="string">&quot;xiaoming&quot;</span>,</span><br><span class="line">    age: <span class="number">18</span></span><br><span class="line">&#125;,</span><br><span class="line">admin: &#123;</span><br><span class="line">    username: <span class="string">&quot;guanliyuan&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> mapMutations = &#123;</span><br><span class="line"><span class="function"><span class="title">run</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;xiaoming 正在跑&quot;</span>)</span><br><span class="line">&#125;,</span><br><span class="line"><span class="function"><span class="title">eat</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;排骨&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> vm = &#123;</span><br><span class="line">data: &#123;</span><br><span class="line">    ...mapState <span class="comment">//浅拷贝mapState，这样在mapState中可以随需求添加数据</span></span><br><span class="line">&#125;,</span><br><span class="line">methods: &#123;</span><br><span class="line">    ...mapMutations</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(vm)</span><br></pre></td></tr></table></figure></li></ul><h3 id="数组方法的扩展"><a href="#数组方法的扩展" class="headerlink" title="数组方法的扩展"></a>数组方法的扩展</h3><ul><li><p>Array.of()  将参数内的数据转为数组，弥补new Array()的不足</p></li><li><p>find()和findIndex()</p><ul><li>find  返回符合条件的第一个成员</li><li>findIndex  返回符合条件的第一个成员的下标索引</li></ul></li><li><p>Includes()   判断是否含有某一个成员（在字符串中也可以使用）；返回的是一个布尔值；</p></li><li><p>Array.from()    伪数组转真数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">5</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr)  <span class="comment">//(5) [empty × 5]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr2 = <span class="built_in">Array</span>.of(<span class="number">5</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr2)  <span class="comment">//[5]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr3 = <span class="built_in">Array</span>.of(<span class="literal">true</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr3)  <span class="comment">//[true]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr4 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> index = arr4.findIndex(<span class="function">(<span class="params">item, index, obj</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> item &gt; <span class="number">3</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(index)  <span class="comment">//3  (第一个满足条件的下标是3)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> x = arr4.find(<span class="function">(<span class="params">item, index, obj</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> item &gt; <span class="number">3</span> </span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(x) <span class="comment">//4  (第一个满足条件的是4)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr5 = [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr5.includes(<span class="string">&quot;hello&quot;</span>))   <span class="comment">//false</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="Symbol（）"><a href="#Symbol（）" class="headerlink" title="Symbol（）"></a>Symbol（）</h2><h3 id="概念和作用"><a href="#概念和作用" class="headerlink" title="概念和作用"></a>概念和作用</h3><ul><li><p>ES6新增了Symbol数据类型(是基础数据类型)，它用来<strong>生成一个独一无二的值</strong></p></li><li><p>Symbol数据常用来<strong>给对象属性赋值</strong>，让对象属性具备唯一性，不容易被覆盖。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">obj&#123;</span><br><span class="line">    a: <span class="number">10</span>,</span><br><span class="line">    a: <span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(obj)</span><br><span class="line"><span class="comment">//因为obj中属性名a冲突了，所以打印出来的结果会是</span></span><br><span class="line"><span class="comment">//  obj&#123; a: 20&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//因此，为了避免这种情况，可以用symbol当作属性名</span></span><br><span class="line"></span><br><span class="line">obj&#123;</span><br><span class="line">    [<span class="built_in">Symbol</span>()]:<span class="number">10</span>,</span><br><span class="line">    [<span class="built_in">Symbol</span>()]:<span class="number">20</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>注：括号内可以加字符串，但只是对该Symbol进行解释说明（字符串相同时，两个symbol也不相等）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>(<span class="string">&#x27;s1&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">Symbol</span>(<span class="string">&#x27;s2&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(s1, s2)  <span class="comment">//Symbol(s1) Symbol(s2)</span></span><br><span class="line"><span class="built_in">console</span>.log(s1.description)  <span class="comment">//s1</span></span><br><span class="line"><span class="built_in">console</span>.log(s1 === s2)   <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> s3 = <span class="built_in">Symbol</span>(<span class="string">&quot;s3&quot;</span>)</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    [<span class="built_in">Symbol</span>()]: <span class="number">10</span>,</span><br><span class="line">    [<span class="built_in">Symbol</span>()]: <span class="number">20</span>,</span><br><span class="line">    [s3]: <span class="number">30</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(obj)<span class="comment">//&#123;Symbol(): 10, Symbol(): 20, Symbol(s3): 30&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>以 Symbol 值作为键名，不会被常规方法遍历得到（见7.3拓展）。我们可以利用这个特性，为对象定义一些非私有的、但又希望只用于内部的方法。</p></li></ul><h4 id="实例-消除魔术字符串"><a href="#实例-消除魔术字符串" class="headerlink" title="实例: 消除魔术字符串"></a>实例: 消除魔术字符串</h4><ul><li><p>魔术字符串  在代码之中多次出现、与代码形成强耦合的某一个具体的字符串或数值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getArea</span>(<span class="params">shape, options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> area = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (shape) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;Triangle&#x27;</span>: <span class="comment">// 魔术字符串</span></span><br><span class="line">      area = <span class="number">.5</span> * options.width * options.height;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">/* ... more code ... */</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> area;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getArea(<span class="string">&#x27;Triangle&#x27;</span>, &#123; <span class="attr">width</span>: <span class="number">100</span>, <span class="attr">height</span>: <span class="number">100</span> &#125;); <span class="comment">// 魔术字符串</span></span><br></pre></td></tr></table></figure><p>上面代码中，字符串<code>Triangle</code>就是一个魔术字符串。它多次出现，与代码形成“强耦合”，不利于将来的修改和维护。</p></li><li><p>用Symbol值解决</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> shapeType = &#123;</span><br><span class="line">  triangle: <span class="built_in">Symbol</span>()</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getArea</span>(<span class="params">shape, options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> area = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">switch</span> (shape) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="built_in">Symbol</span>():</span><br><span class="line">      area = <span class="number">.5</span> * options.width * options.height;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> area;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getArea(<span class="built_in">Symbol</span>(), &#123; <span class="attr">width</span>: <span class="number">100</span>, <span class="attr">height</span>: <span class="number">100</span> &#125;);</span><br></pre></td></tr></table></figure></li></ul><h3 id="Symbol的方法"><a href="#Symbol的方法" class="headerlink" title="Symbol的方法"></a>Symbol的方法</h3><h4 id="s-description"><a href="#s-description" class="headerlink" title="s.description"></a>s.description</h4><p>获取Symbol()字符串的值</p><h4 id="Symbol-for"><a href="#Symbol-for" class="headerlink" title="Symbol.for()"></a>Symbol.for()</h4><ul><li><p>Symbol.for(‘’)  搜索是否有以该参数为名称的Symbol值</p><ul><li>有则返回这个Symbol值，否则新建一个以该字符串为名称的Symbol值，并将其注册到全局</li><li>如果里面的字符串的内容相同，Symbol也是相同</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>.for(<span class="string">&quot;s1&quot;</span>)</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">Symbol</span>.for(<span class="string">&quot;s1&quot;</span>)</span><br><span class="line"><span class="keyword">let</span> s3 = <span class="built_in">Symbol</span>.for(<span class="string">&#x27;s4&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(s1)  <span class="comment">//Symbol(s1)</span></span><br><span class="line"><span class="built_in">console</span>.log(s2)  <span class="comment">//Symbol(s1)</span></span><br><span class="line"><span class="built_in">console</span>.log(s3)  <span class="comment">//Symbol(s4)</span></span><br><span class="line"><span class="built_in">console</span>.log(s1 === s2)    <span class="comment">//true</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p><code>Symbol.for()</code>与<code>Symbol()</code>这两种写法，都会生成新的 Symbol。它们的区别是，</p><ul><li>前者会被登记在全局环境中供搜索，后者不会</li><li><code>Symbol.for()</code>不会每次调用就返回一个新的 Symbol 类型的值，而是会先检查给定的<code>key</code>是否已经存在，如果不存在才会新建一个值</li><li>比如，如果你调用<code>Symbol.for(&quot;cat&quot;)</code>30 次，每次都会返回同一个 Symbol 值，但是调用<code>Symbol(&quot;cat&quot;)</code>30 次，会返回 30 个不同的 Symbol 值。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Symbol</span>.for(<span class="string">&quot;bar&quot;</span>) === <span class="built_in">Symbol</span>.for(<span class="string">&quot;bar&quot;</span>)</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Symbol</span>(<span class="string">&quot;bar&quot;</span>) === <span class="built_in">Symbol</span>(<span class="string">&quot;bar&quot;</span>)</span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Symbol()写法没有登记机制，所以每次调用都会返回一个不同的值</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="Symbol-keyFor"><a href="#Symbol-keyFor" class="headerlink" title="Symbol.keyFor()"></a>Symbol.keyFor()</h4><ul><li><p>返回一个已登记的 Symbol 类型值的key</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>.for(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line"><span class="built_in">Symbol</span>.keyFor(s1) <span class="comment">// &quot;foo&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">Symbol</span>(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line"><span class="built_in">Symbol</span>.keyFor(s2) <span class="comment">// undefined</span></span><br><span class="line"><span class="comment">//s2属于未登记的Symbol值</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="拓展-属性名的遍历"><a href="#拓展-属性名的遍历" class="headerlink" title="拓展 属性名的遍历"></a>拓展 属性名的遍历</h3><ul><li><p>Symbol 作为属性名，遍历对象的时候，该属性不会出现在<code>for...in</code>、<code>for...of</code>循环中，也不会被<code>Object.keys()</code>、<code>Object.getOwnPropertyNames()</code>、<code>JSON.stringify()</code>返回。</p></li><li><p><code>Object.getOwnPropertySymbols()</code>方法，可以获取指定对象的所有 Symbol 属性名。该方法返回一个数组，成员是当前对象的所有用作属性名的 Symbol 值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> obj1 = &#123;<span class="string">&#x27;a&#x27;</span>:<span class="number">10</span>, <span class="string">&#x27;b&#x27;</span>:<span class="number">20</span>&#125;</span><br><span class="line"><span class="keyword">let</span> a = <span class="built_in">Symbol</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> b = <span class="built_in">Symbol</span>(<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line"></span><br><span class="line">obj[a] = <span class="string">&#x27;Hello&#x27;</span>;</span><br><span class="line">obj[b] = <span class="string">&#x27;World&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> obj)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key)  <span class="comment">//无输出</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> obj1)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key)  <span class="comment">//a  b</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> objectSymbols = <span class="built_in">Object</span>.getOwnPropertySymbols(obj);</span><br><span class="line"><span class="built_in">console</span>.log(objectSymbols)<span class="comment">// [Symbol(a), Symbol(b)]</span></span><br><span class="line"><span class="keyword">const</span> objNames = <span class="built_in">Object</span>.getOwnPropertyNames(obj);</span><br><span class="line"><span class="built_in">console</span>.log(objNames)  <span class="comment">//[]</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="set和map"><a href="#set和map" class="headerlink" title="set和map"></a>set和map</h2><h4 id="set"><a href="#set" class="headerlink" title="set"></a>set</h4><ul><li><p>Set()本身是一个构造函数，用来实例化Set数据类型（类似于数组的数据结构，特点：不允许有重复项。</p></li><li><p>set实例的操作方法—用来操作数据</p><p>let s = new Set（）；</p><ul><li><p>s.size : 返回长度</p></li><li><p>s.add()  : 添加某个值，返回set结构本身</p></li><li><p>s.delete() : 删除值，删除成功返回true，否则返回false</p></li><li><p>s.has() ： 判断是否是set的成员，返回布尔值</p></li><li><p>s.clear() : 清除所有的成员，没有返回值。</p></li></ul></li><li><p>set实例的遍历方法—-遍历成员</p></li></ul><h4 id="map"><a href="#map" class="headerlink" title="map"></a>map</h4><ul><li><p>Map对象保存键值对。是类似对象的数据解构。任何值(对象或者原始值) 都可以作为一个键或一个值</p></li><li><p>常用方法：</p><ul><li>m.size 成员的个数</li><li>m.set([1, 2, 3], “content3”)  添加一个内容</li><li>m.get(属性) 获取对应的值</li><li>m.has(属性) 判断属性是否存在</li><li>m.delete(属性) 删除属性</li><li>m.clear()  删除所有的属性</li></ul></li><li><p>Map和Object的区别</p><ul><li>一个Object 的键只能是字符串或者 Symbols，但一个Map 的键可以是任意值。</li><li>Map中的键值是有序的（FIFO 原则），而添加到对象中的键则不是。</li><li>Map的键值对个数可以从 size 属性获取，而 Object 的键值对个数只能手动计算。</li><li>Object 都有自己的原型，原型链上的键名有可能和你自己在对象上的设置的键名产生冲突。</li></ul></li></ul><h2 id="promise"><a href="#promise" class="headerlink" title="promise"></a>promise</h2><h3 id="promise概念，then、catch方法"><a href="#promise概念，then、catch方法" class="headerlink" title="promise概念，then、catch方法"></a>promise概念，then、catch方法</h3><ul><li><p>概念和理解：</p><ul><li>是ES6<strong>解决异步回调问题</strong>的一种解决方案</li></ul><p>由于js是单线程，很多异步操作都是依靠回调方法实现的，这种做法在逻辑比较复杂的回调嵌套中会相当复杂，也叫做回调地狱；</p><ul><li>Promise对象可以理解为一次执行的异步操作，使用Promise对象之后，使用一种链式调用的方式来组织代码，让程序更具备可读性，可维护性</li></ul><p>=&gt;可以<strong>将异步操作以同步的操作的流程表达出来</strong>，避免了层层嵌套的回调函数</p><ul><li>promise和回调函数一样，都是要<strong>解决数据的传递和消息发送问题</strong>，promise中的then一般对应成功后的数据处理，catch一般对应失败后的数据处理。</li></ul></li><li><p>语法：</p><p>promise是一个构造函数，使用时一般都需要new 一个实例对象。</p><p>接受一个函数作为参数，函数中也有两个参数（resolve，reject），resolve将异步操作成功状态下的结果返回。reject将异步操作失败状态写的结果返回。</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">           <span class="keyword">if</span>(ture)&#123;</span><br><span class="line">               resolve(<span class="string">&#x27;成功&#x27;</span>)</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               reject(<span class="string">&#x27;失败&#x27;</span>)</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);<span class="comment">//p就是实例化的promise对象</span></span><br></pre></td></tr></table></figure><ul><li>then方法：接受两个回调函数作为参数，第一个回调函数是promise状态为resolve状态下调用，第二个时reject状态下调用。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">p.then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;<span class="comment">//第一个回调函数res是个参数,接收resolve括号里返回的结果</span></span><br><span class="line">    <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;,<span class="function"><span class="params">err</span>=&gt;</span>&#123;<span class="comment">//第二个回调函数，res是个参数,接收resolve括号里返回的结果</span></span><br><span class="line">    <span class="built_in">console</span>.log(err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>catch方法：promise失败状态调用。 同时也可以捕获到一些编写错误的代码，让错误以字符串的形式体现，不报错影响后续代码执行。 </li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p.catch(<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="Promise特点"><a href="#Promise特点" class="headerlink" title="Promise特点"></a>Promise特点</h3><ul><li><p>对象的状态不受外界影响</p><ul><li><p>三 个状态：进行中pending，已成功fulfilled，已失败rejected</p><p>pending表示程序正在执行但未得到结果，即异步操作没有执行完毕，fulfilled表示程序执行完毕，且执行成功，rejected表示执行完毕但失败；</p><p>这里的成功和失败都是逻辑意义上的；并非是要报错</p></li><li><p>只有异步操作的结果可以决定当前是哪一种状态，任何其他操作都无法改变这个状态</p></li><li><p>一旦创建就会立即执行 ，处于进行中，内部直接执行的为同步，</p></li><li><p>resolve，reject—进行中转为了成功或失败，再使用then方法调用的是属于异步。   </p></li><li><p>没有调用resolve，reject时处理进行中状态，进行中下没有状态返回。</p></li></ul></li><li><p>一旦状态改变，就不会再变，任何时候都可以得到这个结果</p><ul><li>Promise状态改变只有两种可能:  pending =&gt;fulfilled    pending=&gt;rejected</li><li>一旦这两种情况发生，状态就凝固了，会一直保持这个结果，如果改变已经发生，再对Promise对象添加回调函数，也会立即得到这个结果</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;&#125;);</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    resolve(p1)</span><br><span class="line">&#125;)</span><br><span class="line">p2.then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res)<span class="comment">//此时没有结果，因为p1没有resolve或者reject调用此时是进行中的状态，没有返回值，所有p2返会p1时也没有东西。</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li><p>Promise里面同步和异步的判定</p><ul><li>里面是一个同步任务(状态为pending)</li><li>调用resolve/reject方法，状态就会发生改变</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;promise&quot;</span>) <span class="comment">//同步任务  =&gt; 进行中</span></span><br><span class="line">    resolve(<span class="string">&quot;成功&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line">p.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">123</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(res) <span class="comment">// 异步任务 （微任务）</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line"><span class="comment">//输出顺序  1   promise  2  123  成功</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h3 id="promise的链式操作"><a href="#promise的链式操作" class="headerlink" title="promise的链式操作"></a>promise的链式操作</h3><ul><li>必须在前一个then有return返回值，如果return是一个Promise对象，then 就接收的是promise对象中成功状态下的值。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;  </span><br><span class="line">         <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">             resolve(n)</span><br><span class="line">         &#125;, <span class="number">1000</span>)</span><br><span class="line">     &#125;)</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> fn(<span class="number">5</span>).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">     <span class="built_in">console</span>.log(res)</span><br><span class="line">     <span class="keyword">return</span> fn(++res)</span><br><span class="line"> &#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">     <span class="built_in">console</span>.log(res)</span><br><span class="line">     <span class="keyword">return</span> fn(++res)</span><br><span class="line"> &#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">     <span class="built_in">console</span>.log(res)</span><br><span class="line"> &#125;)</span><br></pre></td></tr></table></figure><h3 id="Promise-all-和Promise-race"><a href="#Promise-all-和Promise-race" class="headerlink" title="Promise.all()和Promise.race()"></a>Promise.all()和Promise.race()</h3><ul><li> Promise.all()  处理并发 ，所有值就一起返回</li><li> Promise.race()  返回请求完成最快的—–(一般用于设置请求超时提示）</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个请求如果超过500ms，返回请求超时提示信息</span></span><br><span class="line">        <span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                resolve(<span class="string">&quot;我是正确的请求&quot;</span>)</span><br><span class="line">            &#125;, <span class="number">300</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                resolve(<span class="string">&quot;请求超时&quot;</span>)</span><br><span class="line">            &#125;, <span class="number">500</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="built_in">Promise</span>.race([p1, p2]).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(res)</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure><ul><li>错误信息的处理<ul><li>直接在promise.all().catch(),只能返回错误信息，其他正确的信息无法返回。</li><li>谁报错谁自己处理，其他信息可以正确返回。</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                resolve(<span class="string">&quot;p1&quot;</span>)</span><br><span class="line">            &#125;, <span class="number">500</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                resolve(<span class="string">&quot;p2&quot;</span>)</span><br><span class="line">            &#125;, <span class="number">3500</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">let</span> p3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                reject(<span class="string">&quot;p3&quot;</span>)</span><br><span class="line">            &#125;, <span class="number">1000</span>)</span><br><span class="line">        &#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(err)</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 要求所有的值是一起返回的</span></span><br><span class="line">        <span class="built_in">Promise</span>.all([p1, p2, p3]).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(res)</span><br><span class="line">            &#125;)</span><br><span class="line">            .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(err)</span><br></pre></td></tr></table></figure><h2 id="iterator和for…of循环"><a href="#iterator和for…of循环" class="headerlink" title="iterator和for…of循环"></a>iterator和for…of循环</h2><h3 id="概念和作用-1"><a href="#概念和作用-1" class="headerlink" title="概念和作用"></a>概念和作用</h3><ul><li>概念：</li></ul><p>在集合的数据结构中，数组，对象，set，map 需要统一接口，来进行处理。Iterator就是这个机制，为不同的数据结构提供统一的接口，任何的数据结构，只要部署了iterator就可以进行循环遍历。</p><ul><li><strong>作用</strong><ul><li>1.为各种数据结构提供统一的、简便的访问接口，</li><li>2.使数据结构的成员能够按某种次序排列，</li><li>3.为for…of…提供消费</li></ul></li><li>Iterator的原理<ul><li>（1）创建一个指针对象，指向当前数据结构的起始位置。也就是说，遍历器对象本质上，就是一个指针对象。</li><li>（2）第一次调用指针对象的next方法，可以将指针指向数据结构的第一个成员。</li><li>（3）第二次调用指针对象的next方法，指针就指向数据结构的第二个成员。</li><li>（4）不断调用指针对象的next方法，直到它指向数据结构的结束位置。</li></ul></li></ul><p>每一次调用next方法，都会返回数据结构的当前成员的信息。具体来说，就是返回一个包含value和done两个属性的对象。其中，value属性是当前成员的值，done属性是一个布尔值，表示遍历是否结束，值为true的时候表示遍历结束</p><ul><li><p>模拟Iterator</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myIterator</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="function"><span class="title">next</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> index &lt; arr.length?&#123;</span><br><span class="line">                value:arr[index++],<span class="comment">//因为闭包了，所以index++会储存在这个函数的作用域中</span></span><br><span class="line">                done:<span class="literal">false</span></span><br><span class="line">            &#125;:&#123;</span><br><span class="line">                value:<span class="literal">undefined</span>,</span><br><span class="line">                done:<span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> arr_iter = myIterator(arr);</span><br><span class="line"><span class="built_in">console</span>.log(arr_iter.next())   <span class="comment">//&#123;value: 1, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(arr_iter.next())   <span class="comment">//&#123;value: 2, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(arr_iter.next())   <span class="comment">//review.html:28 &#123;value: 3, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(arr_iter.next())   <span class="comment">//review.html:29 &#123;value: undefined, done: true&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h3 id="部署Iterator接口"><a href="#部署Iterator接口" class="headerlink" title="部署Iterator接口"></a>部署Iterator接口</h3><ul><li><p><strong>Symbol.iterator属性(默认Iterator接口)</strong></p><p>在数据结构上部署iterator接口表现形式为，<strong>给对象或数组等集合增加</strong>Symbol.iterator<strong>属性</strong>，属性的内容是一个根据iterator接口规范自行实现的方法</p><p>=&gt; 一个数据结构只要有了Symbol.iterator属性，即是“可遍历的”</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> arr_iterator = arr[<span class="built_in">Symbol</span>.iterator]();</span><br><span class="line"><span class="built_in">console</span>.log(arr_iter.next())   <span class="comment">//&#123;value: 1, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(arr_iter.next())   <span class="comment">//&#123;value: 2, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(arr_iter.next())   <span class="comment">//review.html:28 &#123;value: 3, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(arr_iter.next())   <span class="comment">//review.html:29 &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>原生具备Iterator接口的数据结构</p><p>Array<br>Map<br>Set<br>String<br>TypedArray<br>函数的 arguments 对象<br>NodeList 对象</p><p>调用这个属性，就能得到遍历器对象</p></li><li><p>对象部署Iterator</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">obj[<span class="built_in">Symbol</span>.iterator] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        next: <span class="function">() =&gt;</span>&#123; <span class="comment">//如果是用function()则this输出的是next方法</span></span><br><span class="line">            <span class="comment">// console.log(this); //对象本身</span></span><br><span class="line">            <span class="comment">// console.log(Object.keys(this)) //对象的所有属性 =&gt; 数组</span></span><br><span class="line">            <span class="comment">// console.log(Object.keys(this)[index]) // 获取数组中对应索引下标的值</span></span><br><span class="line">            <span class="comment">// console.log(obj[Object.keys(this)[index]]) //获取对应的属性名的值 </span></span><br><span class="line">            <span class="keyword">if</span>(index &lt; <span class="built_in">Object</span>.keys(<span class="built_in">this</span>).length)&#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> &#123;<span class="attr">value</span>: obj[<span class="built_in">Object</span>.keys(<span class="built_in">this</span>)[index++]],</span><br><span class="line">                done: <span class="literal">false</span>&#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;<span class="attr">value</span>: <span class="literal">undefined</span>,</span><br><span class="line">                done: <span class="literal">true</span>&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> y = obj[<span class="built_in">Symbol</span>.iterator]()</span><br><span class="line"><span class="built_in">console</span>.log(y.next())</span><br><span class="line"><span class="built_in">console</span>.log(y.next())</span><br><span class="line"><span class="built_in">console</span>.log(y.next())</span><br></pre></td></tr></table></figure></li></ul><h3 id="for…in-和-for…of循环"><a href="#for…in-和-for…of循环" class="headerlink" title="for…in 和 for…of循环"></a>for…in 和 for…of循环</h3><h4 id="for…of"><a href="#for…of" class="headerlink" title="for…of"></a>for…of</h4><ul><li><p>一个数据结构只要部署了Symbol.iterator属性，就被视为具有 iterator 接口，就可以用for…of循环遍历它的成员。</p></li><li><p>也就是说，for…of循环内部调用的是数据结构的Symbol.iterator方法。</p></li></ul><h4 id="for…of-和-for…in的区别"><a href="#for…of-和-for…in的区别" class="headerlink" title="for…of  和  for…in的区别"></a>for…of  和  for…in的区别</h4><ul><li><p>for…in</p><ul><li>返回的是<strong>索引值</strong>，是以字符串的形式</li><li>不一定是按照一定的顺序返回的</li><li>不仅可以遍历本身的方法和属性，还可以遍历原型上的方法和属性</li></ul></li><li><p>for…of</p><ul><li>返回的是<strong>值</strong></li><li>是按照一定的顺序进行遍历</li><li>只能遍历本身的属性和方法</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123;<span class="attr">name</span>:<span class="string">&#x27;zhangsan&#x27;</span>,<span class="attr">age</span>:<span class="number">100</span>&#125;;</span><br><span class="line"><span class="built_in">Object</span>.prototype.sayHello = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Hello&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.prototype.str = <span class="string">&#x27;World&#x27;</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> myObject)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key)  <span class="comment">//name age sayHello str</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>];</span><br><span class="line">arr.foo = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> arr) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i); <span class="comment">// &quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;foo&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> arr) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i); <span class="comment">//  &quot;3&quot;, &quot;5&quot;, &quot;7&quot; </span></span><br><span class="line">  <span class="comment">//for...of方法不会返回arr的foo属性</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="generator"><a href="#generator" class="headerlink" title="generator"></a>generator</h2><h3 id="概念和语法"><a href="#概念和语法" class="headerlink" title="概念和语法"></a>概念和语法</h3><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><ul><li>语法上，首先可以把它理解成，Generator 函数是一个<strong>状态机</strong>，封装了多个内部状态。</li><li>执行Generator函数会<strong>返回一个遍历器对象</strong> =&gt; 是个遍历器对象生成函数。<br>返回的遍历器对象，可以依次遍历Generator函数内部的每一个状态</li><li>形式上：Generator是一个普通函数</li></ul><h4 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h4><ul><li><p>function关键字与函数名之间有一个星号；</p></li><li><p>函数体内部使用yield表达式，定义不同的内部状态（yield在英语里的意思就是“产出”）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">helloWorldGenerator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;world&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;ending&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> hw = helloWorldGenerator();</span><br></pre></td></tr></table></figure></li><li><p>调用该函数返回的是一个遍历器对象(指针指向内部对象)，必须调用遍历器对象的next的方法，指针才能移向下一个对象；<br>每调用一次next方法，内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个yield表达式(或return语句）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">        <span class="keyword">yield</span> <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">        <span class="keyword">yield</span> <span class="string">&#x27;world&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;ending&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> f_i = fn();</span><br><span class="line">    <span class="built_in">console</span>.log((f_i).next())  <span class="comment">// a  b   &#123;value:&quot;hello&quot;,done:false&#125;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="Yield表达式"><a href="#Yield表达式" class="headerlink" title="Yield表达式"></a>Yield表达式</h3><ul><li><p><strong>暂停执行函数的关键字</strong></p><p>由于 Generator 函数返回的遍历器对象，只有调用next方法才会遍历下一个内部状态，所以其实提供了一种可以暂停执行的函数。</p><p>yield表达式就是暂停标志。</p></li><li><p>运行逻辑（案例详见11.3的拓展题）</p><ul><li>（1）遇到<code>yield</code>表达式，就暂停执行后面的操作，并将紧跟在<code>yield</code>后面的那个表达式的值，作为返回的对象的value属性值。</li><li>（2）下一次调用<code>next</code>方法时，再继续往下执行，直到遇到下一个<code>yield</code>表达式。</li><li>（3）如果没有再遇到新的<code>yield</code>表达式，就一直运行到函数结束，直到return语句为止，并将<code>return</code>语句后面的表达式的值，作为返回的对象的value属性值。</li><li>（4）如果该函数没有<code>return</code>语句，则返回的对象的value属性值为undefined。</li></ul><p>不用yield表达式时，就变成了一个单纯的暂缓执行函数(调用next方法才能执行)</p></li></ul><h3 id="next方法的参数"><a href="#next方法的参数" class="headerlink" title="next方法的参数"></a>next方法的参数</h3><ul><li><p>yield表达式本身没有返回值，或者说总是返回undefined</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>*<span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">yield</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> fn_i = fn();</span><br><span class="line"><span class="built_in">console</span>.log(fn_i.next());  <span class="comment">//&#123;value: undefined, done: false&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>next方法可以带一个参数，该参数就会被当作<strong>上一个yield表达式的返回值</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="keyword">yield</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> f_i = fn();</span><br><span class="line"><span class="built_in">console</span>.log(f_i.next())  <span class="comment">//&#123;value: &quot;hello&quot;, done: false&#125;</span></span><br><span class="line">f_i.next(<span class="number">10</span>)   <span class="comment">//10</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>拓展题</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">function</span>* <span class="title">fn1</span>(<span class="params">x</span>) </span>&#123;<span class="comment">//行1</span></span><br><span class="line">    <span class="keyword">let</span> y = <span class="number">20</span> / (<span class="keyword">yield</span> x + <span class="number">100</span>)<span class="comment">//行2</span></span><br><span class="line">        <span class="built_in">console</span>.log(y)  <span class="comment">//5//行3</span></span><br><span class="line">    <span class="keyword">let</span> z = <span class="keyword">yield</span> y / <span class="number">2</span><span class="comment">//行4</span></span><br><span class="line">        <span class="built_in">console</span>.log(z)  <span class="comment">//6//行5</span></span><br><span class="line">    <span class="keyword">return</span> x + y + z<span class="comment">//行6</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> f_i = fn1(<span class="number">5</span>)</span><br><span class="line"><span class="built_in">console</span>.log(f_i.next());  <span class="comment">//&#123;value: 105, done: false&#125;  </span></span><br><span class="line"><span class="comment">//第一次调用next，返回第一个yield（行2）后面的表达式结果(一个遍历器对象)  &#123;value: 5+100, done: false&#125;  </span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(f_i.next(<span class="number">4</span>));  <span class="comment">//&#123;value: 2.5, done: false&#125; </span></span><br><span class="line"><span class="comment">//第二次调用next，继续执行行3，此时由于next的参数4传给了上一个yield表达式(行2)的返回值，因此 y = 20 / 4 = 5。而console.log(f_i.next(4))打印的是行4中yield的返回值  &#123;value: 5/2, done: false&#125; </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(f_i.next(<span class="number">6</span>)); <span class="comment">//&#123;value: 16, done: true&#125;  </span></span><br><span class="line"><span class="comment">//第三次调用next，同理继续执行 行5，此时由于next的参数是6，传给了行4中yield后的返回值，因此 z = 6；而console.log(f_i.next(6))打印的是最后return的遍历器对象 value = x+y+z = 5+5+6 = 16</span></span><br></pre></td></tr></table></figure></li><li><p>作用：可以在 Generator 函数运行的不同阶段，从外部向内部注入不同的值，从而调整函数行为。</p></li></ul><h2 id="async函数-async…await"><a href="#async函数-async…await" class="headerlink" title="async函数  async…await"></a>async函数  async…await</h2><h3 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h3><ul><li>async函数是 Generator 函数的语法糖</li><li>将generator函数的*换成了<code> async</code>，将<code>yield</code> 替换成  <code>await</code></li><li>async函数返回的是一个Promise对象,可以 使用promise对象的方法。可以看作多个异步操作，包装成的一个 Promise 对象</li></ul><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><ul><li><p>async函数返回的是一个Promise对象,可以 使用promise对象的方法</p><ul><li>使用then方法添加回调函数获取return后面的值</li><li>使用catch 来捕获错误信息</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(fn());  <span class="comment">//Promise &#123;&lt;resolved&gt;: &quot;hello&quot;&#125;  //返回的是一个Promise对象</span></span><br><span class="line">fn().then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res) <span class="comment">//&quot;hellp&quot;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//捕获错误信息</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line">    obj.run()</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn().then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err)<span class="comment">//TypeError: obj.run is not a function</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><h4 id="await-方法：一般情况下是结合promise对象使用。"><a href="#await-方法：一般情况下是结合promise对象使用。" class="headerlink" title="await()方法：一般情况下是结合promise对象使用。"></a>await()方法：一般情况下是结合promise对象使用。</h4><ul><li><p>只能在async函数中使用；</p></li><li><p>函数外面访问不到await及后面的表达式，如果需要在函数外部获取就需要在await前面加return。</p></li><li><p>await后面如果接的是promise对象，它拿到的是promise成功状态下的值(不需要再使用then），如果接的是其他类型就直接返回。 </p><ul><li><p><code>await</code>命令就是内部<code>then</code>命令的语法糖。</p></li><li><p>必须等待内部所有<code>await</code>命令后面的Promise对象执行完，才会发生状态改变，才会执行<code>then</code>方法指定的回调函数</p></li><li><p>任何一个<code>await</code>语句后面的 Promise 对象变为<code>reject</code>状态，那么整个<code>async</code>函数都会中断执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="built_in">Promise</span>.reject(<span class="string">&#x27;出错了&#x27;</span>);</span><br><span class="line">  <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="string">&#x27;hello world&#x27;</span>); <span class="comment">// 不会执行</span></span><br><span class="line">&#125;</span><br><span class="line">f().then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;<span class="built_in">console</span>.log(res)&#125;).catch(<span class="function"><span class="params">err</span>=&gt;</span>&#123;<span class="built_in">console</span>.log(err);&#125;)  <span class="comment">//出错了</span></span><br></pre></td></tr></table></figure></li><li><p>如果希望即使前一个异步操作失败，也不要中断后面的异步操作。这时可以将第一个<code>await</code>放在<code>try...catch</code>结构里面，这样不管这个异步操作是否成功，第二个<code>await</code>都会执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="built_in">Promise</span>.reject(<span class="string">&#x27;出错了&#x27;</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span>(er) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="string">&#x27;hello world&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f().then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res))</span><br><span class="line"><span class="comment">// hello world</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>async函数内部代码时同步执行的，执行时如果碰到await，就会先返回；等待await后面的表达式出结果之后再继续执行函数体内后面的语句，但是await不会阻塞async函数外的代码，await等待过程中函数外的代码正常向下同步执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        resolve(<span class="string">&quot;promise&quot;</span>)</span><br><span class="line">    &#125;, <span class="number">2000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;async 开始&quot;</span>)</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">let</span> a = <span class="keyword">await</span> p;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn().next(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;async 结束&quot;</span>)</span><br><span class="line"><span class="comment">//async 开始</span></span><br><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="comment">//async 结束</span></span><br><span class="line"><span class="comment">//（两秒后）promise</span></span><br><span class="line"><span class="comment">//2</span></span><br><span class="line"><span class="comment">//3 </span></span><br></pre></td></tr></table></figure></li></ul><h3 id="实例-解决回调地狱-按顺序完成异步操作"><a href="#实例-解决回调地狱-按顺序完成异步操作" class="headerlink" title="实例: 解决回调地狱(按顺序完成异步操作)"></a>实例: 解决回调地狱(按顺序完成异步操作)</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">http</span>(<span class="params">&#123;</span></span></span><br><span class="line"><span class="function"><span class="params">    type = <span class="string">&quot;get&quot;</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    url,</span></span></span><br><span class="line"><span class="function"><span class="params">    data = &#123;&#125;</span></span></span><br><span class="line"><span class="function"><span class="params">&#125;</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        $.ajax(&#123;</span><br><span class="line">            type,</span><br><span class="line">            url,</span><br><span class="line">            data,</span><br><span class="line">            success: <span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">                resolve(response)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">demo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res1 = <span class="keyword">await</span> http(&#123;</span><br><span class="line">        url: <span class="string">&quot;http://106.13.114.114:5000/api/firstCategory&quot;</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">let</span> firstId = res1.list[<span class="number">0</span>][<span class="number">2</span>].firstId;</span><br><span class="line">    <span class="keyword">let</span> res2 = <span class="keyword">await</span> http(&#123;</span><br><span class="line">        url: <span class="string">&quot;http://106.13.114.114:5000/api/secondCategory&quot;</span>,</span><br><span class="line">        data: &#123;</span><br><span class="line">            firstId</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="built_in">console</span>.log(res2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">demo()</span><br></pre></td></tr></table></figure><h2 id="class类"><a href="#class类" class="headerlink" title="class类"></a>class类</h2><h3 id="概念和语法-1"><a href="#概念和语法-1" class="headerlink" title="概念和语法"></a>概念和语法</h3><h4 id="概念-3"><a href="#概念-3" class="headerlink" title="概念"></a>概念</h4><ul><li><p>类和对象：</p><p>类：对象的类型模板，确定对象中共有的属性和行为</p><p>对象：类创建的实例，具体的某一个事物，一切皆为对象</p></li><li><p>ES6引入了Class(类)这个概念，通过<code>class</code>关键字，可以定义类</p></li><li><p>一个语法糖，让对象原型的写法更加清晰、更像面向对象编程的语法</p></li></ul><h4 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h4><ul><li><p>class关键字</p><ul><li>构造函数本身方法或者是属性要写在constructor方法里面</li><li>原型上的方法或者是属性直接写在class里面即可</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Class Person&#123;<span class="comment">//定义类的构造函数</span></span><br><span class="line">    <span class="function"><span class="title">construtor</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//定义一般的方法</span></span><br><span class="line">    <span class="function"><span class="title">eat</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;吃饭饭&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> P = <span class="keyword">new</span> Person(<span class="string">&#x27;xx&#x27;</span>,<span class="string">&#x27;18&#x27;</span>);</span><br><span class="line">p.eat()</span><br></pre></td></tr></table></figure></li><li><p>constructor方法</p><ul><li>是类的默认方法，通过new命令生成对象实例时，自动调用该方法</li><li>一个类必须有constructor方法，如果没有显式定义，一个空的constructor方法会被默认添加</li><li>默认返回实例对象(即this)</li></ul></li><li><p>事实上，类的所有方法都定义在类的prototype属性上面。</p></li><li><p>取值函数（getter）和存值函数（setter）（了解）</p><p>与 ES5 一样，在“类”的内部可以使用<code>get</code>和<code>set</code>关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">prop</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;getter&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">set</span> <span class="title">prop</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;setter: &#x27;</span>+value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> inst = <span class="keyword">new</span> MyClass();</span><br><span class="line"></span><br><span class="line">inst.prop = <span class="number">123</span>;</span><br><span class="line"><span class="comment">// setter: 123</span></span><br><span class="line"></span><br><span class="line">inst.prop</span><br><span class="line"><span class="comment">// &#x27;getter&#x27;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><ul><li><p>实例化方法和属性：（成员）</p><p>类相当于实例的原型(实例化对象的__proto__指向类的prototype原型)，所有在类中定义的方法，都会被实例继承</p><pre><code>    必须**通过实例化对象进行调用**</code></pre></li><li><p>静态方法和静态属性：</p><p>在方法和属性前面加关键字static，表示该方法不会被实例继承，直接<strong>通过类进行调用</strong></p><p>对于一些通用性的属性或方法，可以考虑设置为静态</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">classMethod</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo.classMethod() <span class="comment">// &#x27;hello&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = <span class="keyword">new</span> Foo();</span><br><span class="line">foo.classMethod()</span><br><span class="line"><span class="comment">// TypeError: foo.classMethod is not a function</span></span><br></pre></td></tr></table></figure></li><li><p><strong>注意</strong>：如果静态方法包含<code>this</code>关键字，这个<code>this</code>指的是类，而不是实例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">bar</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.baz();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">baz</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">baz</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;world&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo.bar() <span class="comment">// hello</span></span><br><span class="line"><span class="comment">//静态方法bar调用了this.baz,  这里的this指的是Foo类，而不是Foo的实例；等同于调用Foo.baz</span></span><br><span class="line"><span class="comment">//静态方法可以与非静态方法重名</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><h4 id="语法-3"><a href="#语法-3" class="headerlink" title="语法"></a>语法</h4><ul><li><p><code>extends</code> 关键字</p></li><li><p>子类里，如果不写constructor是可以，默认可以添加，但是如果写入constructor函数就必须要加入super();super调用父类的constructor；super必须写constructor的第一行；</p></li><li><p>不但可以继承实例化的方法和属性，静态的方法和属性也是可以继承；</p></li><li><p><code>super</code></p><p>一种是方法，一种是对象;</p><ul><li>作为方法是调用父类的constructor；</li><li>作为对象来说，就是在子类的方法里面调用父类的方法；</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name,age</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Me</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name,age,sex</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name,age) <span class="comment">// 调用父类的constructor</span></span><br><span class="line">        <span class="built_in">this</span>.sex = sex</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> Parent(<span class="string">&quot;rose&quot;</span>,<span class="number">40</span>)</span><br><span class="line"><span class="keyword">let</span> m = <span class="keyword">new</span> Me(<span class="string">&quot;joth&quot;</span>,<span class="number">18</span>,<span class="string">&#x27;male&#x27;</span>);</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">Parent</span> </span>&#123;            </span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span>  &#123;                </span><br><span class="line">        <span class="built_in">this</span>.x  = <span class="number">1</span>;            </span><br><span class="line">    &#125;            </span><br><span class="line">    <span class="function"><span class="title">print</span>(<span class="params"></span>)</span>  &#123;                </span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.x);            </span><br><span class="line">    &#125;        </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">Me</span>  <span class="keyword">extends</span>  <span class="title">Parent</span>  </span>&#123;            </span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span>  &#123;                </span><br><span class="line">        <span class="built_in">super</span>();                </span><br><span class="line">        <span class="built_in">this</span>.x  = <span class="number">2</span>;            </span><br><span class="line">    &#125;            </span><br><span class="line">    <span class="function"><span class="title">m</span>(<span class="params"></span>)</span>  &#123;   </span><br><span class="line">        <span class="built_in">super</span>.print();<span class="comment">//在子类的方法里调用父类的方法            </span></span><br><span class="line">    &#125;        </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span>  b  =  <span class="keyword">new</span>  Me();        </span><br><span class="line">b.m()  <span class="comment">//2</span></span><br></pre></td></tr></table></figure></li><li><p>父类的静态方法，可以被子类继承</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">classMethod</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> <span class="keyword">extends</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Bar.classMethod() <span class="comment">// &#x27;hello&#x27;</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="拓展-类的prototype属性和-proto-属性"><a href="#拓展-类的prototype属性和-proto-属性" class="headerlink" title="拓展:类的prototype属性和__proto__属性"></a>拓展:类的prototype属性和<code>__proto__</code>属性</h4><ul><li><p>大多数浏览器的 ES5 实现之中，每一个对象都有<code>__proto__</code>属性，指向对应的构造函数的<code>prototype</code>属性。Class 作为构造函数的语法糖，同时有<code>prototype</code>属性和<code>__proto__</code>属性，因此同时存在两条继承链。</p><ul><li>子类的<code>__proto__</code>属性，表示构造函数的继承，总是指向父类。</li><li>子类<code>prototype</code>属性的<code>__proto__</code>属性，表示方法的继承，总是指向父类的<code>prototype</code>属性。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">B.__proto__ === A <span class="comment">// true  //作为一个对象，子类(B)的原型(__proto__属性)是父类(A)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(B.prototype) <span class="comment">//A &#123;constructor: ƒ&#125;</span></span><br><span class="line">B.prototype.__proto__ === A.prototype <span class="comment">// true  //作为一个构造函数，子类（B）的原型对象（prototype属性）是父类的原型对象（prototype属性）的实例。</span></span><br></pre></td></tr></table></figure></li><li><p>实例的<code>__proto__</code>属性</p><p>子类实例的<code>__proto__</code>属性的<code>__proto__</code>属性，指向父类实例的<code>__proto__</code>属性。也就是说，子类的原型的原型，是父类的原型。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name,age</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Me</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name,age,sex</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name,age) <span class="comment">// 调用父类的constructor</span></span><br><span class="line">        <span class="built_in">this</span>.sex = sex</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> Parent(<span class="string">&quot;rose&quot;</span>,<span class="number">40</span>)</span><br><span class="line"><span class="keyword">let</span> m = <span class="keyword">new</span> Me(<span class="string">&quot;joth&quot;</span>,<span class="number">18</span>,<span class="string">&#x27;male&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(m.__proto__);<span class="comment">//Parent &#123;constructor: ƒ&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(m.__proto__ === Me.prototype); <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(m.__proto__.__proto__ === p.__proto__); <span class="comment">//true</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> ES6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ES6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>async/await的用法及其异常捕获</title>
      <link href="2020/09/24/es6-async-await/"/>
      <url>2020/09/24/es6-async-await/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是async-await"><a href="#什么是async-await" class="headerlink" title="什么是async/await"></a>什么是async/await</h2><p>我们一般用<code>Promise</code>解决回调地狱的问题，用<code>Promise.then</code>来获取成功状态，但当多个相互依赖的请求时，代码可能会变成这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p1.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    p2.then(<span class="function"><span class="params">res1</span> =&gt;</span> )</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>显然不太好读。因此就有了<code>async/await</code>:</p><ul><li><code>async</code>函数返回一个Promise对象,可以使用promise对象的方法。可以看作多个异步操作，包装成的一个 Promise 对象</li><li><code>await</code>后面如果接的是promise对象，当<code>Promise</code>对象状态变化的时候，就会得到返回值，可以看作<code>then</code>的语法糖</li></ul><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><h3 id="async函数"><a href="#async函数" class="headerlink" title="async函数"></a>async函数</h3><ul><li><p>async函数返回的是一个Promise对象，如果函数中有返回值。则通过<code>Promise.resole()</code>封装成<code>Promise</code>对象</p><ul><li>使用then方法添加回调函数获取return后面的值</li><li>使用catch 来捕获错误信息</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(fn());  <span class="comment">//Promise &#123;&lt;resolved&gt;: &quot;hello&quot;&#125;  //返回的是一个Promise对象</span></span><br><span class="line">fn().then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res) <span class="comment">//&quot;hellp&quot;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//捕获错误信息</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line">    obj.run()</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn().then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err)<span class="comment">//TypeError: obj.run is not a function</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><h3 id="await-方法"><a href="#await-方法" class="headerlink" title="await()方法"></a>await()方法</h3><ul><li><p>只能在async函数中使用；</p></li><li><p>函数外面访问不到await及后面的表达式，如果需要在函数外部获取就需要在await前面加return。</p></li><li><p>await后面如果接的是promise对象，当<code>Promise</code>对象状态变化的时候，得到返回值，如果接的是其他类型就直接返回。 </p><ul><li><p><code>await</code>命令就是内部<code>then</code>命令的语法糖。</p></li><li><p>必须等待内部所有<code>await</code>命令后面的Promise对象执行完，才会发生状态改变，才会执行<code>then</code>方法指定的回调函数</p></li><li><p>任何一个<code>await</code>语句后面的 Promise 对象变为<code>reject</code>状态，那么整个<code>async</code>函数都会中断执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="built_in">Promise</span>.reject(<span class="string">&#x27;出错了&#x27;</span>);</span><br><span class="line">  <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="string">&#x27;hello world&#x27;</span>); <span class="comment">// 不会执行</span></span><br><span class="line">&#125;</span><br><span class="line">f().then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;<span class="built_in">console</span>.log(res)&#125;).catch(<span class="function"><span class="params">err</span>=&gt;</span>&#123;<span class="built_in">console</span>.log(err);&#125;)  <span class="comment">//出错了</span></span><br></pre></td></tr></table></figure></li><li><p>如果希望即使前一个异步操作失败，也不要中断后面的异步操作。这时可以将第一个<code>await</code>放在<code>try...catch</code>结构里面，这样不管这个异步操作是否成功，第二个<code>await</code>都会执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="built_in">Promise</span>.reject(<span class="string">&#x27;出错了&#x27;</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span>(er) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="string">&#x27;hello world&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f().then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res))</span><br><span class="line"><span class="comment">// hello world</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>async函数内部代码是同步执行的</strong>，执行时如果碰到await，就会先返回；等待await后面的表达式出结果之后再继续执行函数体内后面的语句，但是await不会阻塞async函数外的代码，await等待过程中函数外的代码正常向下同步执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        resolve(<span class="string">&quot;promise&quot;</span>)</span><br><span class="line">    &#125;, <span class="number">2000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;async 开始&quot;</span>)</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">let</span> a = <span class="keyword">await</span> p;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn().next(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;async 结束&quot;</span>)</span><br><span class="line"><span class="comment">//async 开始</span></span><br><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="comment">//async 结束</span></span><br><span class="line"><span class="comment">//（两秒后）promise</span></span><br><span class="line"><span class="comment">//2</span></span><br><span class="line"><span class="comment">//3 </span></span><br></pre></td></tr></table></figure></li></ul><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">http</span>(<span class="params">&#123;</span></span></span><br><span class="line"><span class="function"><span class="params">    type = <span class="string">&quot;get&quot;</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    url,</span></span></span><br><span class="line"><span class="function"><span class="params">    data = &#123;&#125;</span></span></span><br><span class="line"><span class="function"><span class="params">&#125;</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        $.ajax(&#123;</span><br><span class="line">            type,</span><br><span class="line">            url,</span><br><span class="line">            data,</span><br><span class="line">            success: <span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">                resolve(response)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">demo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res1 = <span class="keyword">await</span> http(&#123;</span><br><span class="line">        url: <span class="string">&quot;http://106.13.114.114:5000/api/firstCategory&quot;</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">let</span> firstId = res1.list[<span class="number">0</span>][<span class="number">2</span>].firstId;</span><br><span class="line">    <span class="keyword">let</span> res2 = <span class="keyword">await</span> http(&#123;</span><br><span class="line">        url: <span class="string">&quot;http://106.13.114.114:5000/api/secondCategory&quot;</span>,</span><br><span class="line">        data: &#123;</span><br><span class="line">            firstId</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="built_in">console</span>.log(res2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">demo()</span><br></pre></td></tr></table></figure><h2 id="异常捕获"><a href="#异常捕获" class="headerlink" title="异常捕获"></a>异常捕获</h2><p>如果<code>await</code>后面的异步操作出错，那么等同于async函数返回的 <code>Promise</code> 对象被<code>reject</code>。</p><p>防止出错的方法就是我们将其放在<code>try/catch</code>代码块中。并且能够捕获异常。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> a = <span class="keyword">await</span> <span class="built_in">Promise</span>.reject(<span class="string">&#x27;error&#x27;</span>)</span><br><span class="line">    &#125;<span class="keyword">catch</span>(error)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(error)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="异常捕获的封装"><a href="#异常捕获的封装" class="headerlink" title="异常捕获的封装"></a>异常捕获的封装</h3><p>如果不想每次需要捕获异常的时候都写很多<code>try/catch</code>，也可以对异常捕获进行封装：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">to</span>(<span class="params">promise</span>)</span>&#123;</span><br><span class="line">   <span class="keyword">return</span> promise.then(<span class="function"><span class="params">res</span>=&gt;</span>[<span class="literal">null</span>,res]).catch(<span class="function"><span class="params">err</span>=&gt;</span>[err,<span class="literal">undefined</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用举例</span></span><br><span class="line"><span class="keyword">let</span> firstRequest = <span class="keyword">async</span> (index = <span class="number">0</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> [err, res] = <span class="keyword">await</span> to(ajax())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ES6async概念 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ES6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Promise的认识和使用</title>
      <link href="2020/09/24/es6-promise-base/"/>
      <url>2020/09/24/es6-promise-base/</url>
      
        <content type="html"><![CDATA[<h2 id="Promise概念，then、catch方法"><a href="#Promise概念，then、catch方法" class="headerlink" title="Promise概念，then、catch方法"></a>Promise概念，then、catch方法</h2><ul><li><p>概念和理解：</p><ul><li><p><strong>一个异步操作返回的对象，用来传递异步操作的消息</strong></p></li><li><p>是ES6<strong>解决异步回调问题</strong>的一种解决方案</p></li></ul><p>由于js是单线程，很多异步操作都是依靠回调方法实现的，这种做法在逻辑比较复杂的回调嵌套中会相当复杂，也叫做回调地狱；</p><ul><li>Promise对象可以理解为一次执行的异步操作，使用Promise对象之后，使用一种链式调用的方式来组织代码，让程序更具备可读性，可维护性</li></ul><p>=&gt;可以<strong>将异步操作以同步的操作的流程表达出来</strong>，避免了层层嵌套的回调函数</p><ul><li>promise和回调函数一样，都是要<strong>解决数据的传递和消息发送问题</strong>，promise中的then一般对应成功后的数据处理，catch一般对应失败后的数据处理。</li></ul></li><li><p>语法：</p><p>promise是一个构造函数，使用时一般都需要new 一个实例对象。</p><p>接受一个函数作为参数，函数中也有两个参数（resolve，reject），resolve将异步操作成功状态下的结果返回。reject将异步操作失败状态写的结果返回。</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">           <span class="keyword">if</span>(ture)&#123;</span><br><span class="line">               resolve(<span class="string">&#x27;成功&#x27;</span>)</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               reject(<span class="string">&#x27;失败&#x27;</span>)</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);<span class="comment">//p就是实例化的promise对象</span></span><br></pre></td></tr></table></figure><ul><li>then方法：接受两个回调函数作为参数，第一个回调函数是promise状态为resolve状态下调用，第二个时reject状态下调用。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">p.then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;<span class="comment">//第一个回调函数res是个参数,接收resolve括号里返回的结果</span></span><br><span class="line">    <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;,<span class="function"><span class="params">err</span>=&gt;</span>&#123;<span class="comment">//第二个回调函数，res是个参数,接收resolve括号里返回的结果</span></span><br><span class="line">    <span class="built_in">console</span>.log(err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>catch方法：promise失败状态调用。 同时也可以捕获到一些编写错误的代码，让错误以字符串的形式体现，不报错影响后续代码执行。 </li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p.catch(<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="Promise特点"><a href="#Promise特点" class="headerlink" title="Promise特点"></a>Promise特点</h2><ul><li><p>对象的状态不受外界影响</p><ul><li><p>三 个状态：进行中pending，已成功fulfilled，已失败rejected</p><p>pending表示程序正在执行但未得到结果，即异步操作没有执行完毕，fulfilled表示程序执行完毕，且执行成功，rejected表示执行完毕但失败；</p><p>这里的成功和失败都是逻辑意义上的；并非是要报错</p></li><li><p>只有异步操作的结果可以决定当前是哪一种状态，任何其他操作都无法改变这个状态</p></li><li><p>一旦创建就会立即执行 ，处于进行中，内部直接执行的为同步，</p></li><li><p>resolve，reject—进行中转为了成功或失败，再使用then方法调用的是属于异步。   </p></li><li><p>没有调用resolve，reject时处理进行中状态，进行中下没有状态返回。</p></li></ul></li><li><p>一旦状态改变，就不会再变，任何时候都可以得到这个结果</p><ul><li>Promise状态改变只有两种可能:  pending =&gt;fulfilled    pending=&gt;rejected</li><li>一旦这两种情况发生，状态就凝固了，会一直保持这个结果，如果改变已经发生，再对Promise对象添加回调函数，也会立即得到这个结果</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;&#125;);</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    resolve(p1)</span><br><span class="line">&#125;)</span><br><span class="line">p2.then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res)<span class="comment">//此时没有结果，因为p1没有resolve或者reject调用此时是进行中的状态，没有返回值，所有p2返会p1时也没有东西。</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li><p>Promise里面同步和异步的判定</p><ul><li>里面是一个同步任务(状态为pending)</li><li>调用resolve/reject方法，状态就会发生改变</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;promise&quot;</span>) <span class="comment">//同步任务  =&gt; 进行中</span></span><br><span class="line">    resolve(<span class="string">&quot;成功&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line">p.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">123</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(res) <span class="comment">// 异步任务 （微任务）</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line"><span class="comment">//输出顺序  1   promise  2  123  成功</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h2 id="promise的链式操作"><a href="#promise的链式操作" class="headerlink" title="promise的链式操作"></a>promise的链式操作</h2><ul><li>必须在前一个then有return返回值，如果return是一个Promise对象，then 就接收的是promise对象中成功状态下的值。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;  </span><br><span class="line">         <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">             resolve(n)</span><br><span class="line">         &#125;, <span class="number">1000</span>)</span><br><span class="line">     &#125;)</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> fn(<span class="number">5</span>).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">     <span class="built_in">console</span>.log(res)</span><br><span class="line">     <span class="keyword">return</span> fn(++res)</span><br><span class="line"> &#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">     <span class="built_in">console</span>.log(res)</span><br><span class="line">     <span class="keyword">return</span> fn(++res)</span><br><span class="line"> &#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">     <span class="built_in">console</span>.log(res)</span><br><span class="line"> &#125;)</span><br></pre></td></tr></table></figure><h2 id="Promise-all-和Promise-race"><a href="#Promise-all-和Promise-race" class="headerlink" title="Promise.all()和Promise.race()"></a>Promise.all()和Promise.race()</h2><ul><li> Promise.all()  处理并发 ，所有值就一起返回</li><li> Promise.race()  返回请求完成最快的—–(一般用于设置请求超时提示）</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个请求如果超过500ms，返回请求超时提示信息</span></span><br><span class="line">        <span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                resolve(<span class="string">&quot;我是正确的请求&quot;</span>)</span><br><span class="line">            &#125;, <span class="number">300</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                resolve(<span class="string">&quot;请求超时&quot;</span>)</span><br><span class="line">            &#125;, <span class="number">500</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="built_in">Promise</span>.race([p1, p2]).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(res)</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure><ul><li>错误信息的处理<ul><li>直接在promise.all().catch(),只能返回错误信息，其他正确的信息无法返回。</li><li>谁报错谁自己处理，其他信息可以正确返回。</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                resolve(<span class="string">&quot;p1&quot;</span>)</span><br><span class="line">            &#125;, <span class="number">500</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                resolve(<span class="string">&quot;p2&quot;</span>)</span><br><span class="line">            &#125;, <span class="number">3500</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">let</span> p3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                reject(<span class="string">&quot;p3&quot;</span>)</span><br><span class="line">            &#125;, <span class="number">1000</span>)</span><br><span class="line">        &#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(err)</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 要求所有的值是一起返回的</span></span><br><span class="line">        <span class="built_in">Promise</span>.all([p1, p2, p3]).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(res)</span><br><span class="line">            &#125;)</span><br><span class="line">            .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(err)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ES6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ES6 </tag>
            
            <tag> Promise </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git总结</title>
      <link href="2020/09/22/git-notes/"/>
      <url>2020/09/22/git-notes/</url>
      
        <content type="html"><![CDATA[<h2 id="git的架构"><a href="#git的架构" class="headerlink" title="git的架构"></a>git的架构</h2><ul><li>版本库：项目中，git init之后会有一个.git的目录，这个目录不属于工作区，而是git的版本库，管理git的所有内容</li><li>暂存区：版本库中的一个临时存储的区域，保存提交的文件</li><li>分支：版本库中包括若干个分支，从暂存区提交出去的文件会在分支中形成 一个版本(提交点)</li></ul><h2 id="仓库（版本库）"><a href="#仓库（版本库）" class="headerlink" title="仓库（版本库）"></a>仓库（版本库）</h2><p>仓库就是一个目录，这个目录内的文件被git所管理起来</p><h3 id="新建一个仓库"><a href="#新建一个仓库" class="headerlink" title="新建一个仓库"></a>新建一个仓库</h3><p>在一个目录下，运行</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init </span><br></pre></td></tr></table></figure><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><ol><li><p>查看仓库状态</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure></li><li><p>将有修改的文件提交到暂存区</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br></pre></td></tr></table></figure></li><li><p>将暂存区的文件提交到分支，形成一个版本(提交点)</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m <span class="string">&quot;这一次提交的信息&quot;</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h2><p>刚才我们所说的仓库其实是本地仓库，在多人开发中，每个人都会有一个自己的本地仓库，同时，更重要的，为了让多人可以共享代码，应该有一个远程仓库</p><h3 id="“远程仓库”的选择"><a href="#“远程仓库”的选择" class="headerlink" title="“远程仓库”的选择"></a>“远程仓库”的选择</h3><ul><li>github</li><li>码云</li><li>公司内部构建的远程仓库</li></ul><h3 id="远程仓库的操作"><a href="#远程仓库的操作" class="headerlink" title="远程仓库的操作"></a>远程仓库的操作</h3><ol><li><p>注册github账号</p></li><li><p>创建一个空的仓库</p></li><li><p>将需要提交到远程仓库的目录进行如下操作</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 初始化目录</span></span><br><span class="line">git init</span><br><span class="line"><span class="comment"># 查看当前状态</span></span><br><span class="line">git status</span><br><span class="line"><span class="comment"># 提交到暂存区</span></span><br><span class="line">git add .</span><br><span class="line"><span class="comment"># 提交成一个版本</span></span><br><span class="line">git commit -m <span class="string">&#x27;first commit&#x27;</span></span><br><span class="line"><span class="comment"># 在远程创建一个地址</span></span><br><span class="line">git remote add origin github仓库地址</span><br><span class="line"><span class="comment"># 将当前版本提交到远程地址的master分支</span></span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure></li></ol><h4 id="远程仓库的共享和克隆"><a href="#远程仓库的共享和克隆" class="headerlink" title="远程仓库的共享和克隆"></a>远程仓库的共享和克隆</h4><p>此时我们已经有了一个自己的远程仓库，同时仓库内的master分支上已经有我们刚才提交的文件。此时如果有其他人员需要下载这个项目，需要进行克隆操作</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> 仓库地址</span><br></pre></td></tr></table></figure><h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><h3 id="撤回提交-git-reset"><a href="#撤回提交-git-reset" class="headerlink" title="撤回提交 git reset"></a>撤回提交 git reset</h3><p><a href="https://blog.csdn.net/w958796636/article/details/53611133">参考来源</a></p><h4 id="–soft"><a href="#–soft" class="headerlink" title="–soft"></a>–soft</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 撤回上一次提交</span></span><br><span class="line">git reset --soft HEAD^</span><br><span class="line">git reset --soft HEAD~1</span><br><span class="line"><span class="comment"># 撤回2次提交</span></span><br><span class="line">git reset --soft HEAD~2</span><br><span class="line"><span class="comment"># 按提交记录撤回</span></span><br><span class="line">git <span class="built_in">log</span> <span class="comment"># 查看提交记录</span></span><br><span class="line">git reset --soft 某次记录编号 <span class="comment"># 撤回某次记录</span></span><br></pre></td></tr></table></figure><h4 id="–mixed"><a href="#–mixed" class="headerlink" title="–mixed"></a>–mixed</h4><p>意思是：不删除工作空间改动代码，撤销commit，并且撤销git add . 操作<br>这个为默认参数,<code>git reset --mixed HEAD^ </code>和 <code>git reset HEAD^</code> 效果是一样的。</p><h4 id="–soft-1"><a href="#–soft-1" class="headerlink" title="–soft"></a>–soft</h4><p>不删除工作空间改动代码，撤销commit，不撤销git add . </p><h4 id="–hard"><a href="#–hard" class="headerlink" title="–hard"></a>–hard</h4><p>删除工作空间改动代码，撤销commit，撤销git add . </p><p>注意完成这个操作后，就恢复到了上一次的commit状态。</p><h4 id="修改提交注释"><a href="#修改提交注释" class="headerlink" title="修改提交注释"></a>修改提交注释</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit --amend</span><br></pre></td></tr></table></figure><h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><p>一个远程仓库中可以有多个分支（master, dev, test），而一个分支上就存储了我们之前提交的版本，随着提交次数的增多，在分支上会形成一条时间线，每一次的git commit 操作都会在分支上形成一个版本</p><h3 id="基本操作-1"><a href="#基本操作-1" class="headerlink" title="基本操作"></a>基本操作</h3><ol><li><p>查看分支</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></table></figure></li><li><p>创建新的分支,同时复制当前分支</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch 分支名</span><br></pre></td></tr></table></figure></li><li><p>切换分支</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout 分支名</span><br></pre></td></tr></table></figure></li><li><p>将新分支提交</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin HEAD -u</span><br></pre></td></tr></table></figure></li></ol><h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><p>每一个分支都有一个指针，指针默认都会指向分支上最新的一个版本</p><p>分支提交日志查询</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> --oneline</span><br></pre></td></tr></table></figure><h3 id="分支合并"><a href="#分支合并" class="headerlink" title="分支合并"></a>分支合并</h3><p>将一个分支合并到另一个分支上</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge 分支a    <span class="comment">#把分支a合并到当前分支上</span></span><br></pre></td></tr></table></figure><h2 id="git命令总结"><a href="#git命令总结" class="headerlink" title="git命令总结"></a>git命令总结</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">git init      <span class="comment">#初始化本地仓库</span></span><br><span class="line">git add &lt;file&gt; 文件名<span class="comment">#添加文件</span></span><br><span class="line">git status   <span class="comment">#查看状态</span></span><br><span class="line">git commit   <span class="comment">#提交</span></span><br><span class="line">git push     <span class="comment">#推送到仓库</span></span><br><span class="line">git pull     <span class="comment">#从远程仓库拉取数据</span></span><br><span class="line">git <span class="built_in">clone</span>    <span class="comment">#从远程仓库拷贝数据</span></span><br><span class="line"></span><br><span class="line">git config --global user.name <span class="string">&#x27;xxx&#x27;</span> <span class="comment"># 添加用户名</span></span><br><span class="line">git config --global user.name <span class="string">&#x27;xxx&#x27;</span> <span class="comment"># 添加邮箱</span></span><br><span class="line"></span><br><span class="line">git rm --cached  index.html     <span class="comment">#删除指定的某个文件</span></span><br><span class="line">git add *.html      <span class="comment"># 添加某一类型的 文件</span></span><br><span class="line">git add .      <span class="comment">#添加全部文件 </span></span><br><span class="line">git commit -m <span class="string">&#x27;changed index.js&#x27;</span>     <span class="comment">#提交并修改备注</span></span><br><span class="line"></span><br><span class="line">.gitignore      <span class="comment"># 在该文件里面 可以添加一些不需要上传的文件</span></span><br><span class="line"></span><br><span class="line">git branch <span class="string">&#x27;...随便起一个分支名&#x27;</span>     <span class="comment"># 创建分支</span></span><br><span class="line">git checkout  <span class="string">&#x27;分支名&#x27;</span>             <span class="comment"># 切换到对应的分支</span></span><br><span class="line">git checkout  <span class="string">&#x27;master&#x27;</span>            <span class="comment"># 切换到主分支</span></span><br><span class="line">git merge       <span class="comment"># 合并分支</span></span><br><span class="line"></span><br><span class="line">git <span class="built_in">log</span>     <span class="comment"># 查看提交历史</span></span><br><span class="line">git reset --soft HEAD^     <span class="comment"># 撤回上一次提交</span></span><br><span class="line">git reset --soft HEAD~2     <span class="comment"># 撤回2次提交</span></span><br><span class="line">git reset --soft 某次记录编号     <span class="comment"># 撤回某次记录</span></span><br></pre></td></tr></table></figure><p>上传到远程仓库</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment"># 连接到远程仓库</span></span><br><span class="line">git remote add origin https://github.com/liuhaha2001/liu.git</span><br><span class="line"><span class="comment"># 查看是否连接上了</span></span><br><span class="line">git branch -M master</span><br><span class="line"><span class="comment"># 上传到master分支</span></span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
