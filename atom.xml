<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yang&#39;s Blog</title>
  
  <subtitle>虹の先へ</subtitle>
  <link href="https://wuyangqin.github.io/atom.xml" rel="self"/>
  
  <link href="https://wuyangqin.github.io/"/>
  <updated>2021-04-08T07:11:46.523Z</updated>
  <id>https://wuyangqin.github.io/</id>
  
  <author>
    <name>Yangqin Wu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>VueCli3使用 Vue-Test-Utils + Karma / Chrome进行单元测试</title>
    <link href="https://wuyangqin.github.io/2021/04/07/Vue-vue-test-utils/"/>
    <id>https://wuyangqin.github.io/2021/04/07/Vue-vue-test-utils/</id>
    <published>2021-04-07T15:39:49.000Z</published>
    <updated>2021-04-08T07:11:46.523Z</updated>
    
    <content type="html"><![CDATA[<p>在<code>vue2</code>造UI轮子的项目中，因为<code>parcel</code>编译样式时速度有点慢，因此将其迁移到了<code>vue-cli3</code>，同时使用<code>Vue-Test-Utils</code>结合<code>Karma</code>对单元测试框架进行了升级。</p><h2 id="Vue-Test-Utils"><a href="#Vue-Test-Utils" class="headerlink" title="Vue-Test-Utils"></a>Vue-Test-Utils</h2><p><code>Vue Test Utils</code> 是 Vue.js 官方的单元测试实用工具库。</p><p><a href="https://vue-test-utils.vuejs.org/zh/guides/#%E8%B5%B7%E6%AD%A5">官方文档</a></p><p>首先尝试用Mocha+webpack编写单元测试，依然是使用Chai断言库。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在根目录新建tests/units目录，将原有的测试文件改为**.spec.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> chai, &#123;expect&#125; <span class="keyword">from</span> <span class="string">&#x27;chai&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123;shallowMount, mount&#125; <span class="keyword">from</span> <span class="string">&#x27;@vue/test-utils&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Button <span class="keyword">from</span> <span class="string">&#x27;@/components/button&#x27;</span></span><br><span class="line"></span><br><span class="line">describe(<span class="string">&#x27;Button&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    it(<span class="string">&#x27;可以设置icon.&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> wrapper = mount(Button, &#123;</span><br><span class="line">      propsData: &#123;</span><br><span class="line">        icon: <span class="string">&#x27;settings&#x27;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">const</span> useElement = wrapper.find(<span class="string">&#x27;use&#x27;</span>)</span><br><span class="line">    expect(useElement.attributes()[<span class="string">&#x27;href&#x27;</span>]).to.equal(<span class="string">&#x27;#x-settings&#x27;</span>)</span><br><span class="line">    wrapper.destroy()</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="mount-V-S-shallowMount"><a href="#mount-V-S-shallowMount" class="headerlink" title="mount V.S. shallowMount"></a>mount V.S. shallowMount</h3><h4 id="mount"><a href="#mount" class="headerlink" title="mount()"></a>mount()</h4><ul><li><p><strong>参数：</strong></p><ul><li><code>&#123;Component&#125; component</code></li><li><code>&#123;Object&#125; options</code></li></ul></li><li><p><strong>返回值：</strong> <code>&#123;Wrapper&#125;</code></p></li><li><p><strong>选项：</strong>移步<a href="https://vue-test-utils.vuejs.org/zh/api/options.html">选项</a>，常用的有<code>propsData</code>,<code>slots</code>,<code>attachTo</code></p></li><li><p><strong>用法：</strong>创建一个包含被挂载和渲染的 Vue 组件的 <a href="https://vue-test-utils.vuejs.org/zh/api/wrapper/"><code>Wrapper</code></a>。</p></li></ul><h4 id="shallowMount"><a href="#shallowMount" class="headerlink" title="shallowMount()"></a>shallowMount()</h4><p>用法和 <code>mount</code> 一样，创建一个包含被挂载和渲染的 Vue 组件的 <code>Wrapper</code>，不同的是被存根的子组件。</p><h4 id="mount-和shallowMount-的区别"><a href="#mount-和shallowMount-的区别" class="headerlink" title="mount()和shallowMount()的区别"></a>mount()和shallowMount()的区别</h4><ul><li>参考这篇<a href="https://github.com/holylovelqq/vue-unit-test-with-jest/issues/4">笔记</a></li><li><code>mount()</code>会将测试组件中使用到的子子孙孙组件完全渲染，而<code>shallowMount()</code>不会</li><li>为保证测试速度，能用<code>shallowMount()</code>的地方都尽量用<code>mount()</code></li></ul><h2 id="为什么要使用Karma"><a href="#为什么要使用Karma" class="headerlink" title="为什么要使用Karma"></a>为什么要使用Karma</h2><p>将原来<code>button.spec.js</code> 测试用例复制过来后，发现涉及到了样式的测试都未通过</p><p><img src="/images/vue/test-error1.png"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 样式相关的测试用例</span></span><br><span class="line">it(<span class="string">&#x27;icon 默认的 order 是 1&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> wrapper = mount(Button, &#123;</span><br><span class="line">    propsData: &#123;</span><br><span class="line">      icon: <span class="string">&#x27;setting&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> vm = wrapper.vm</span><br><span class="line">  <span class="keyword">const</span> icon = vm.$el.querySelector(<span class="string">&#x27;svg&#x27;</span>)</span><br><span class="line">  expect(getComputedStyle(icon).order).to.eq(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>原因是这个测试框架是运行在node.js里，而非运行在浏览器，所以没有DOM，无法得到元素的样式。</p><p>官方文档中提到<code>attachTo:htmlELement</code>可以将元素设置到DOM中，然而添加后测试依然不通过。</p><p>因此，为了解决这个问题，需要使用<code>Krama</code><strong>启动浏览器</strong>运行测试。</p><h3 id="配置方法"><a href="#配置方法" class="headerlink" title="配置方法"></a>配置方法</h3><h4 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -D karma karma-chrome-launcher karma-mocha karma-sourcemap-loader karma-spec-reporter karma-webpack chai sinon sinon-chai</span><br></pre></td></tr></table></figure><h4 id="创建karma-conf-js"><a href="#创建karma-conf-js" class="headerlink" title="创建karma.conf.js"></a>创建karma.conf.js</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// karma.conf.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> webpackConfig = <span class="built_in">require</span>(<span class="string">&#x27;./webpack.config.js&#x27;</span>)</span><br><span class="line"><span class="comment">// var webpackConfig = require(&#x27;@vue/cli-service/webpack.config.js&#x27;) // 如果没有配置webpack.config.js</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">config</span>) </span>&#123;</span><br><span class="line">  config.set(&#123;</span><br><span class="line">    frameworks: [<span class="string">&#x27;mocha&#x27;</span>],</span><br><span class="line"></span><br><span class="line">    files: [<span class="string">&#x27;test/**/*.spec.js&#x27;</span>],</span><br><span class="line"></span><br><span class="line">    preprocessors: &#123;</span><br><span class="line">      <span class="string">&#x27;**/*.spec.js&#x27;</span>: [<span class="string">&#x27;webpack&#x27;</span>, <span class="string">&#x27;sourcemap&#x27;</span>]</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    webpack: webpackConfig,</span><br><span class="line"></span><br><span class="line">    reporters: [<span class="string">&#x27;spec&#x27;</span>],</span><br><span class="line">    autoWatch: <span class="literal">true</span>,</span><br><span class="line">    browsers: [<span class="string">&#x27;ChromeHeadless&#x27;</span>]</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="配置package-json"><a href="#配置package-json" class="headerlink" title="配置package.json"></a>配置package.json</h4><p>在 <code>package.json</code> 定义测试脚本</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">   <span class="string">&quot;test&quot;</span>: <span class="string">&quot;karma start --single-run&quot;</span>, <span class="comment">// 运行一次</span></span><br><span class="line">   <span class="string">&quot;test:unit&quot;</span>: <span class="string">&quot;karma start&quot;</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="编写测试用例"><a href="#编写测试用例" class="headerlink" title="编写测试用例"></a>编写测试用例</h3><p>添加karma后，将样式相关的测试用例重新编写，举个栗子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">it(<span class="string">&#x27;icon 默认的 order 是 1&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> div = <span class="built_in">document</span>.createElement(<span class="string">&#x27;div&#x27;</span>)</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(div)</span><br><span class="line">  <span class="keyword">const</span> wrapper = mount(Button, &#123;</span><br><span class="line">    attachTo: div,</span><br><span class="line">    propsData: &#123;</span><br><span class="line">      icon: <span class="string">&#x27;settings&#x27;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">const</span> vm = wrapper.vm</span><br><span class="line">  <span class="keyword">const</span> icon = vm.$el.querySelector(<span class="string">&#x27;svg&#x27;</span>)</span><br><span class="line">  expect(getComputedStyle(icon).order).to.eq(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">  div.remove()</span><br><span class="line">  wrapper.destroy()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><img src="/images/vue/test-s.png" alt="测试通过啦"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在&lt;code&gt;vue2&lt;/code&gt;造UI轮子的项目中，因为&lt;code&gt;parcel&lt;/code&gt;编译样式时速度有点慢，因此将其迁移到了&lt;code&gt;vue-cli3&lt;/code&gt;，同时使用&lt;code&gt;Vue-Test-Utils&lt;/code&gt;结合&lt;code&gt;Karma&lt;/c</summary>
      
    
    
    
    <category term="Vue" scheme="https://wuyangqin.github.io/categories/Vue/"/>
    
    <category term="Vue2" scheme="https://wuyangqin.github.io/categories/Vue/Vue2/"/>
    
    
    <category term="Vue" scheme="https://wuyangqin.github.io/tags/Vue/"/>
    
    <category term="Vue2" scheme="https://wuyangqin.github.io/tags/Vue2/"/>
    
    <category term="造轮子" scheme="https://wuyangqin.github.io/tags/%E9%80%A0%E8%BD%AE%E5%AD%90/"/>
    
    <category term="单元测试" scheme="https://wuyangqin.github.io/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Vue小技巧之属性、事件传递：v-bind=&quot;$props&quot;，v-bind=&quot;$attrs&quot;，v-on=&quot;$listeners&quot;</title>
    <link href="https://wuyangqin.github.io/2021/04/02/Vue-v-bind-props/"/>
    <id>https://wuyangqin.github.io/2021/04/02/Vue-v-bind-props/</id>
    <published>2021-04-02T14:39:49.000Z</published>
    <updated>2021-04-06T08:40:35.537Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>今天接手了另一位同事的代码改一个需求时，发现这个需求涉及到的组件层层嵌套，<code>props</code>也得层层传递，如图所示：</p><p><img src="/images/vue/props%E7%A9%BF%E9%80%8F.png"></p><p>从A组件传递的<code>props</code>需要分别传递到第二第三层组件中使用。如果我改这个需求得添加一个属性，就意味着我需要在ABCDE…这几个组件调用的地方分别加上这个属性。想想就非常不优雅：不仅费时，也不利于以后的拓展和维护。那么有什么方法可以优化呢？</p><p>正好前段时间写Vue3UI轮子button组件的时候，用到了<code>v-bind=&quot;$attrs&quot;</code>来将属性和事件绑定给子组件。于是进行了一番探索(搜博客+查阅文档)，发现<code>vue2</code>中也有类似的操作，分别是通过<code>v-bind=&quot;$props&quot;</code>,<code>v-bind=&quot;$attrs&quot;</code>传递属性，通过<code>v-on=&quot;$listeners&quot;</code>传递事件。</p><h2 id="使用介绍"><a href="#使用介绍" class="headerlink" title="使用介绍"></a>使用介绍</h2><h3 id="v-bind-”-props”"><a href="#v-bind-”-props”" class="headerlink" title="v-bind=”$props”"></a>v-bind=”$props”</h3><ul><li><p><code>vm.$props</code>: 当前组件接收到的 props 对象。Vue 实例代理了对其 props 对象属性的访问</p></li><li><p><code>v-bind=&quot;$props&quot;</code>将父组件的所有props向下传递给它的子组件,子组件需要在其props:{} 中定义要接受的props</p></li></ul><h3 id="v-bind-”-attrs”"><a href="#v-bind-”-attrs”" class="headerlink" title="v-bind=”$attrs”"></a>v-bind=”$attrs”</h3><ul><li><code>vm.$attrs</code> :包含了父作用域中不作为 prop 被识别 (且获取) 的特性绑定 (class 和 style 除外)。当一个组件没有声明任何 prop 时，这里会包含所有父作用域的绑定 (class 和 style 除外)</li><li><code>v-bind=&quot;$attrs&quot;</code>： 将调用组件时，组件标签上绑定的非props特性(class和style除外)向下传递</li></ul><h3 id="v-on-”-listeners”"><a href="#v-on-”-listeners”" class="headerlink" title="v-on=”$listeners”"></a>v-on=”$listeners”</h3><ul><li><code>vm.$listeners</code>: 包含了父作用域中的 (不含 .native 修饰器的) v-on 事件监听器。它可以通过 v-on=”$listeners” 传入内部组件</li><li><code>v-on=&quot;$listeners&quot;</code>：将父组件标签上的自定义事件向下传递,其子组件可以直接通过this.$emit(eventName)的方式调用</li></ul><p><strong>注：<code>Vue3</code>中移除了<code>$listeners</code>，而将事件存在了<code>vm.$attrs</code>中</strong></p><h2 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h2><ul><li><p>index.vue</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;Parent test=<span class="string">&quot;非props属性&quot;</span> :name=<span class="string">&quot;name&quot;</span> :age=<span class="string">&quot;age&quot;</span> v-on:start1=<span class="string">&quot;fn1&quot;</span> @start2=<span class="string">&quot;fn2&quot;</span>&gt;</span><br><span class="line">    &lt;/Parent&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">  </span><br><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">import</span> Parent <span class="keyword">from</span> <span class="string">&#x27;./parent.vue&#x27;</span>;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    components: &#123;</span><br><span class="line">      Parent</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">          name: <span class="string">&#x27;爷爷给爸爸的值&#x27;</span>,</span><br><span class="line">          age: <span class="string">&#x27;18&#x27;</span></span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        <span class="function"><span class="title">fn1</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;这是从爷爷传来的方法1&#x27;</span>);</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="function"><span class="title">fn2</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;这是从爷爷传来的方法2&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li><li><p>parent.vue</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">      &lt;h3&gt;父组件&lt;/h3&gt;</span><br><span class="line">      &lt;div&gt;非props属性($attrs): &#123;&#123;$attrs&#125;&#125;&lt;/div&gt;</span><br><span class="line">      &lt;child v-on=<span class="string">&quot;$listeners&quot;</span> v-bind=<span class="string">&quot;$props&quot;</span>&gt;&lt;/child&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">  </span><br><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">import</span> Child <span class="keyword">from</span> <span class="string">&#x27;./child.vue&#x27;</span>;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    inheritAttrs: <span class="literal">false</span>,</span><br><span class="line">    components: &#123;</span><br><span class="line">      Child</span><br><span class="line">    &#125;,</span><br><span class="line">    props: [<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;age&#x27;</span>],</span><br><span class="line">    <span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span> &#123; </span><br><span class="line">        <span class="built_in">this</span>.$emit(<span class="string">&#x27;start1&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li><li><p>child.vue</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">      &lt;h3&gt;子组件&lt;/h3&gt;</span><br><span class="line">      &lt;div&gt;爸爸传递过来的name: &#123;&#123;name&#125;&#125;&lt;/div&gt;</span><br><span class="line">      &lt;div&gt;爸爸传递过来的age: &#123;&#123;age&#125;&#125;&lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">  </span><br><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    props: [<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;age&#x27;</span>],</span><br><span class="line">    <span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.$emit(<span class="string">&#x27;start2&#x27;</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.$listeners, <span class="string">&#x27;儿子的事件&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li></ul><p>效果如下：</p><p><img src="/images/vue/props%E7%A9%BF%E9%80%8F1.png"></p><p><img src="/images/vue/props%E7%A9%BF%E9%80%8F2.png"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/6844903848050589704#heading-4">https://juejin.cn/post/6844903848050589704#heading-4</a></p><p><a href="https://cn.vuejs.org/v2/api/#v-on">https://cn.vuejs.org/v2/api/?#v-on</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;今天接手了另一位同事的代码改一个需求时，发现这个需求涉及到的组件层层嵌套，&lt;code&gt;props&lt;/code&gt;也得层层传递，如图所示：&lt;/p</summary>
      
    
    
    
    <category term="Vue" scheme="https://wuyangqin.github.io/categories/Vue/"/>
    
    
    <category term="Vue" scheme="https://wuyangqin.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>node学习记录（2）-文件模块-制作一个使用命令行操作的todo list</title>
    <link href="https://wuyangqin.github.io/2021/03/31/node-notes-2-fs/"/>
    <id>https://wuyangqin.github.io/2021/03/31/node-notes-2-fs/</id>
    <published>2021-03-31T15:32:01.000Z</published>
    <updated>2021-04-13T06:38:30.910Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>源码链接：<a href="https://github.com/wuyangqin/node-todo-list">https://github.com/wuyangqin/node-todo-list</a></p></blockquote><p>使用node的<code>fs</code>文件模块实现了一个简单的用命令行操作的todo list</p><h2 id="技术细节"><a href="#技术细节" class="headerlink" title="技术细节"></a>技术细节</h2><ul><li>使用node.js <code>fs</code>模块实现文件读写</li><li>使用<code>commander.js</code>编写命令行命令</li><li>使用<code>inquirer.js</code> 实现用户与命令行的交互 </li><li>使用<code>jest.js</code> 模拟fs，编写单元测试</li></ul><h2 id="效果演示"><a href="#效果演示" class="headerlink" title="效果演示"></a>效果演示</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g node-todo-xx</span><br></pre></td></tr></table></figure><p>or</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn global add node-todo-xx</span><br></pre></td></tr></table></figure><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">todo <span class="comment"># 查看所有任务列表,能够操作任务增删改查</span></span><br><span class="line">todo add 任务名 <span class="comment"># 添加一个任务</span></span><br><span class="line">todo clear <span class="comment"># 清空所有任务</span></span><br></pre></td></tr></table></figure><p><strong>todo 查看任务列表</strong></p><p><img src="/images/node-notes/fs-todo.png" alt="查看任务列表"></p><p><img src="/images/node-notes/fs-todo-onetask.png" alt="对某项任务进行操作"></p><p><strong>todo add 添加任务</strong></p><p><img src="/images/node-notes/fs-todo-add.png" alt="添加任务"></p><p><strong>todo clear 清除任务</strong></p><p><img src="/images/node-notes/fs-todo-clear.png" alt="添加任务"></p><h2 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h2><h3 id="逻辑梳理"><a href="#逻辑梳理" class="headerlink" title="逻辑梳理"></a>逻辑梳理</h3><p>该项目的实现逻辑如图所示：</p><p><img src="/images/node-notes/todo-logic.png"></p><h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">├── __mocks__</span><br><span class="line">|  └── fs.js  <span class="comment"># 模拟fs模块</span></span><br><span class="line">├── __test__  <span class="comment"># 存放测试文件</span></span><br><span class="line">|  └── db.test.js</span><br><span class="line">├── cli.js <span class="comment"># 命令行操作逻辑</span></span><br><span class="line">├── db.js <span class="comment"># 读写任务的函数</span></span><br><span class="line">└── index.js <span class="comment"># 任务的操作逻辑</span></span><br></pre></td></tr></table></figure><h3 id="读写文件"><a href="#读写文件" class="headerlink" title="读写文件"></a>读写文件</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> os = <span class="built_in">require</span>(<span class="string">&#x27;os&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> homedir = os.homedir(); <span class="comment">// 获取home目录</span></span><br><span class="line"><span class="keyword">const</span> home = process.env.HOME || homedir; <span class="comment">// 如果用户自己设置了HOME的环境变量</span></span><br><span class="line"><span class="keyword">const</span> dbPath = path.join(home,<span class="string">&#x27;.todo&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> db = &#123;</span><br><span class="line">  <span class="function"><span class="title">read</span>(<span class="params">path = dbPath</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// &#x27;a+&#x27;: Open file for reading and appending. The file is created if it does not exist.</span></span><br><span class="line">      fs.readFile(path,&#123; <span class="attr">flag</span>: <span class="string">&#x27;a+&#x27;</span>&#125;, <span class="function">(<span class="params">readError,data</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (readError) <span class="keyword">return</span> reject(readError)</span><br><span class="line">        <span class="keyword">let</span> list</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          list = <span class="built_in">JSON</span>.parse(data.toString())</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">          list = []</span><br><span class="line">        &#125;</span><br><span class="line">        resolve(list)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">write</span>(<span class="params">list, path = dbPath</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> string = <span class="built_in">JSON</span>.stringify(list)</span><br><span class="line">      fs.writeFile(path,string + <span class="string">&#x27;\n&#x27;</span>,<span class="function">(<span class="params">writeError</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(writeError) <span class="keyword">return</span> reject(writeError)</span><br><span class="line">        resolve()</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports  = db</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><h4 id="测试命令"><a href="#测试命令" class="headerlink" title="测试命令"></a>测试命令</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn <span class="built_in">test</span></span><br></pre></td></tr></table></figure><h4 id="fs-mock"><a href="#fs-mock" class="headerlink" title="fs mock"></a>fs mock</h4><p>从上面的逻辑梳理图可以看到，这个项目最主要的就是对任务文件进行操作的两个函数，因此将围绕这两个函数进行单元测试的编写。</p><p>然而编写单元测试有一条原则就是，<strong>测试代码不要与外界进行交互</strong>，比如如果我通过测试代码读取用户硬盘上的某个文件，而这个文件路径刚好在用户硬盘中存在，这就很尴尬啦。因此<code>jest</code>提供了对node模块进行<code>mock</code>的功能——相当于对node的模块进行接管，调用我们自己编写的方法。具体实现如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在项目根目录创建&#x27;__mock__&#x27;文件夹, 并创建&#x27;fs.js&#x27;文件 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fs = jest.genMockFromModule(<span class="string">&#x27;fs&#x27;</span>) <span class="comment">// 创建模拟的fs模块</span></span><br><span class="line"><span class="keyword">const</span> _fs = jest.requireActual(<span class="string">&#x27;fs&#x27;</span>) <span class="comment">// 引入实际的fs模块</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.assign(fs, _fs) <span class="comment">// 将原fs模块的属性复制给我们创建的模拟fs模块</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> readMocks = &#123;&#125;</span><br><span class="line">fs.setReadFileMock = <span class="function">(<span class="params">path, error, data</span>) =&gt;</span> &#123;</span><br><span class="line">  readMocks[path] = [error, data]</span><br><span class="line">&#125;</span><br><span class="line">fs.readFile = <span class="function">(<span class="params">path,options,callback</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (callback === <span class="literal">undefined</span>) callback = options</span><br><span class="line">  <span class="keyword">if</span> (path <span class="keyword">in</span> readMocks) &#123;</span><br><span class="line">    callback(...readMocks[path])</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    _fs.readFile(path, options, callback)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> writeMocks = &#123;&#125;</span><br><span class="line">fs.setWriteFileMock = <span class="function">(<span class="params">path, fn</span>) =&gt;</span> &#123;</span><br><span class="line">  writeMocks[path] = fn</span><br><span class="line">&#125;</span><br><span class="line">fs.writeFile  = <span class="function">(<span class="params">path, data, options, callback</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (callback === <span class="literal">undefined</span>) callback = options</span><br><span class="line">  <span class="keyword">if</span> (path <span class="keyword">in</span> writeMocks) &#123;</span><br><span class="line">    writeMocks[path](path, data, options, callback)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    _fs.writeFile(path, data, options, callback)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fs.clearMocks = <span class="function">() =&gt;</span> &#123; <span class="comment">// 清除mock</span></span><br><span class="line">  readMocks = &#123;&#125;</span><br><span class="line">  writeMocks = &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = fs</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// __test__文件夹用来存放测试文件，在&#x27;db.spec.js&#x27;中编写读写文件两个函数的测试代码</span></span><br><span class="line"><span class="keyword">const</span> db = <span class="built_in">require</span>(<span class="string">&#x27;../db.js&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line">jest.mock(<span class="string">&#x27;fs&#x27;</span>) <span class="comment">// jest将fs接管</span></span><br><span class="line"></span><br><span class="line">describe(<span class="string">&#x27;db&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  afterEach(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    fs.clearMocks()</span><br><span class="line">  &#125;)</span><br><span class="line">  </span><br><span class="line">  it (<span class="string">&#x27;can read&#x27;</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> data = [&#123;<span class="attr">title</span>: <span class="string">&#x27;hi&#x27;</span>, <span class="attr">done</span>: <span class="literal">false</span>&#125;]</span><br><span class="line">    fs.setReadFileMock(<span class="string">&#x27;/test&#x27;</span>,<span class="literal">null</span>, <span class="built_in">JSON</span>.stringify(data))</span><br><span class="line">    <span class="keyword">const</span> list = <span class="keyword">await</span> db.read(<span class="string">&#x27;/test&#x27;</span>)</span><br><span class="line">    expect(list).toStrictEqual(data)</span><br><span class="line">  &#125;)</span><br><span class="line">  </span><br><span class="line">  it (<span class="string">&#x27;can write&#x27;</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> fakeFile</span><br><span class="line">    fs.setWriteFileMock(<span class="string">&#x27;/test1&#x27;</span>, <span class="function">(<span class="params">path, data, callback</span>) =&gt;</span> &#123;</span><br><span class="line">      fakeFile = data</span><br><span class="line">      callback(<span class="literal">null</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">const</span> list = [&#123;<span class="attr">title</span>: <span class="string">&#x27;hi&#x27;</span>, <span class="attr">done</span>: <span class="literal">false</span>&#125;]</span><br><span class="line">    <span class="keyword">await</span> db.write(list,<span class="string">&#x27;/test1&#x27;</span>)</span><br><span class="line">    expect(fakeFile).toBe(<span class="built_in">JSON</span>.stringify(list) + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;源码链接：&lt;a href=&quot;https://github.com/wuyangqin/node-todo-list&quot;&gt;https://github.com/wuyangqin/node-todo-list&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;</summary>
      
    
    
    
    <category term="node" scheme="https://wuyangqin.github.io/categories/node/"/>
    
    
    <category term="node" scheme="https://wuyangqin.github.io/tags/node/"/>
    
  </entry>
  
  <entry>
    <title>node学习记录（1）-node初识</title>
    <link href="https://wuyangqin.github.io/2021/03/24/node-notes-1-intro/"/>
    <id>https://wuyangqin.github.io/2021/03/24/node-notes-1-intro/</id>
    <published>2021-03-24T12:05:01.000Z</published>
    <updated>2021-04-13T06:38:24.675Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Node-简介"><a href="#Node-简介" class="headerlink" title="Node 简介"></a>Node 简介</h2><h3 id="node-js-不是什么"><a href="#node-js-不是什么" class="headerlink" title="node.js 不是什么"></a>node.js 不是什么</h3><ul><li>不是web后端框架</li><li>不是编程语言</li></ul><h3 id="node-js是什么"><a href="#node-js是什么" class="headerlink" title="node.js是什么"></a>node.js是什么</h3><ul><li>将多种技术组合起来</li><li>让JavaScript也能调用系统接口、开发后端应用</li></ul><h3 id="用到了哪些技术"><a href="#用到了哪些技术" class="headerlink" title="用到了哪些技术"></a>用到了哪些技术</h3><ul><li>V8引擎</li><li>libuv</li><li>C/C++实现的 c-ares(实现DNS 域名的解析)，http-parser(解析http)，OpenSSL(https)，zlib(加密)等库</li></ul><h3 id="Node特点"><a href="#Node特点" class="headerlink" title="Node特点"></a>Node特点</h3><p><strong>单线程</strong></p><ul><li>进程就是一个一个的工作计划（工厂中的车间）</li><li>线程是计算机最小的运算单位（工厂中的工人），线程是干活的</li><li>传统的服务器是多线程的，每进来一个请求，就创建一个线程去处理请求</li><li>Node.js的服务器是单线程的，在后台拥有一个I/O线程池</li></ul><p><strong>非阻塞 I/O</strong></p><ul><li><p>I/O：对磁盘的读写操作( Input/ Output)</p></li><li><p>非阻塞：不会等I/O语句结束，而会执行后面的语句（异步）</p><p>异步：调用者发起一个异步调用，然后立即返回去做别的事。“被调用者”通过状态、通知、回调函数等手段来通知“调用者”。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line">fs.readFile(<span class="string">&#x27;/app.js&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err,file</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;我读完文件了！);</span></span><br><span class="line"><span class="string">&#125;)</span></span><br><span class="line"><span class="string">console.log(&#x27;</span>我不会被阻塞！<span class="string">&#x27;)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">//我不会被阻塞是在我读完文件了之前输出 =&gt;异步调用</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">//机制:进行I/O操作，给readFile绑定一个回调函数function(err,file)&#123;&#125;,并在读取textfile完成后执行回调函数。期间，后面的代码继续执行，不受I/O阻塞</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>事件驱动</strong></p><h2 id="Node-js技术架构"><a href="#Node-js技术架构" class="headerlink" title="Node.js技术架构"></a>Node.js技术架构</h2><p><img src="/images/node-notes/node-struct.png" alt="Node.js技术架构"></p><p>stream模块</p><ul><li>第一层 可以用js直接调用的api</li></ul><h4 id="bingdings-让JS和C-C-通信"><a href="#bingdings-让JS和C-C-通信" class="headerlink" title="bingdings 让JS和C/C++通信"></a>bingdings 让JS和C/C++通信</h4><p>举例：</p><ul><li>C/C++实现了一个http_parser库，但不能用JS直接调用这个库，于是需要一个中间的销量</li><li>Node.js用C++对该库进行封装，并用其提供的编译工具将该库编译为.node文件</li><li>js代码可以直接require这个.node文件</li><li>实现js调用C++库，中间的桥梁–binding</li><li>Node.js提供了很多binding – bindings</li></ul><h4 id="V8-JS引擎"><a href="#V8-JS引擎" class="headerlink" title="V8 JS引擎"></a>V8 JS引擎</h4><ul><li>功能<ul><li>将JS源代码变成本地代码并执行</li><li>维护调用栈，确保JS函数的执行顺序</li><li>内存管理，为所有对象分配内存</li><li>垃圾回收，重复利用无用的内存</li><li>实现JS的标准库</li></ul></li><li>注意<ul><li>V8不提供 DOM API</li><li>本身是多线程，如垃圾回收是单独线程，但执行JS是单线程的</li><li>可以开启两个线程分别执行JS</li><li>自带event loop，但Node.js基于liuv自己做了一个</li></ul></li></ul><h4 id="libuv"><a href="#libuv" class="headerlink" title="libuv"></a>libuv</h4><ul><li>一个跨平台的异步I/O库，会根据系统自动选择合适的方案</li><li>I/O:对磁盘的读写操作( Input/ Output)</li><li>功能：可以用于 TCP/UDP/DNS/文件 等的异步操作<ul><li>TCP：http是基于TCPIP，能操作TCP就能做服务器</li><li>UDP：一般用于网页聊天</li><li>DNS：域名</li></ul></li></ul><h3 id="Event-Loop"><a href="#Event-Loop" class="headerlink" title="Event Loop"></a>Event Loop</h3><h4 id="什么是loop"><a href="#什么是loop" class="headerlink" title="什么是loop"></a>什么是loop</h4><ul><li>loop就是循环</li><li>由于事件是分优先级的，所以处理起来也是分先后的</li><li>node.js需要按顺序轮询每种事件</li><li>这种轮询往往是循环的</li></ul><h4 id="Event-Loop-1"><a href="#Event-Loop-1" class="headerlink" title="Event Loop"></a>Event Loop</h4><ul><li>对事件处理顺序的管理</li></ul><h4 id="顺序示意图"><a href="#顺序示意图" class="headerlink" title="顺序示意图"></a>顺序示意图</h4><p><img src="/images/node-notes/node-eventloop.png" alt="Event Loop图示"></p><ul><li>重点阶段<ul><li>timers 检查计时器</li><li>poll 轮询，检查系统时间</li><li>check检查setImmediate回调</li></ul></li><li>注意<ul><li>大部分时间，Node.js都停在poll 轮询阶段</li><li>大部分事件都在poll阶段被处理，如文件、网络请求</li></ul></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>用libuv进行异步I/O操作</li><li>用event loop管理事件处理顺序</li><li>用C/C++库高效处理DNS/HTTP</li><li>用bindings让JS能和C/C++沟通</li><li>用V8运行JS</li><li>用Node.js标准库简化JS</li></ul><h4 id="Node-js工作流程"><a href="#Node-js工作流程" class="headerlink" title="Node.js工作流程"></a>Node.js工作流程</h4><p><img src="/images/node-notes/node-progress.png" alt="Node.js工作流程图示"></p><h2 id="Node-js-API"><a href="#Node-js-API" class="headerlink" title="Node.js API"></a>Node.js API</h2><h3 id="API文档"><a href="#API文档" class="headerlink" title="API文档"></a>API文档</h3><ul><li>官方文档：<a href="http://nodejs.cn/api/">http://nodejs.cn/api/</a></li><li>民间版本： <a href="https://devdocs.io/">https://devdocs.io/</a></li></ul><h3 id="API有哪些功能"><a href="#API有哪些功能" class="headerlink" title="API有哪些功能"></a>API有哪些功能</h3><ul><li>assersion 断言</li><li>testing</li><li>async hooks</li><li>*Buffer  一小段缓存</li><li>*Child Processes 子进程</li><li>*Cluster</li><li>*Events 发布订阅模式</li><li>*Debugger 调试</li><li>*File System 文件系统 对文件的增删改查</li><li>*Globals 全局变量</li><li>*HTTP</li><li>*Path 路径</li><li>*Process 当前进程的相关信息</li><li>*Query String </li><li>*Stream 流格式</li><li>*Timers</li><li>*URL</li><li>*Worker Threads   node10之后才有的</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Node-简介&quot;&gt;&lt;a href=&quot;#Node-简介&quot; class=&quot;headerlink&quot; title=&quot;Node 简介&quot;&gt;&lt;/a&gt;Node 简介&lt;/h2&gt;&lt;h3 id=&quot;node-js-不是什么&quot;&gt;&lt;a href=&quot;#node-js-不是什么&quot; class=&quot;</summary>
      
    
    
    
    <category term="node" scheme="https://wuyangqin.github.io/categories/node/"/>
    
    
    <category term="node" scheme="https://wuyangqin.github.io/tags/node/"/>
    
  </entry>
  
  <entry>
    <title>Vue3学习笔记</title>
    <link href="https://wuyangqin.github.io/2021/03/21/Vue3-notes/"/>
    <id>https://wuyangqin.github.io/2021/03/21/Vue3-notes/</id>
    <published>2021-03-21T14:11:02.000Z</published>
    <updated>2021-04-20T03:09:55.189Z</updated>
    
    <content type="html"><![CDATA[<h2 id="亮点"><a href="#亮点" class="headerlink" title="亮点"></a>亮点</h2><ul><li>Performance（比Vue2 runtime快了两倍）</li><li>Tree shaking (按需编译代码)</li><li>Ts support</li><li>Composition API（组合API）</li><li>Custom Renderer API(自定义渲染器)</li></ul><h2 id="数据响应"><a href="#数据响应" class="headerlink" title="数据响应"></a>数据响应</h2><p> Vue3.0 之前的对象数据响应式的原理是 Object.defineProperty(), 数组的响应式原理是拦截了数组的7个方法（包括 push、pop、shift、unshift、 splice、 sort、 reverse）。这种方式存在的问题：对于对象，我们无法直接检测到属性的新增和删除；对于数组我们无法检测到直接去修改数组下标对应的内容以及利用 length 修改数组的长度。</p><p>Vue3.0的数据响应的原理是利用 <code>Proxy </code>实现的。Proxy在ES2015规范中被正式发布，它在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。</p><ul><li>Proxy 可以直接监听对象而非属性。因此对象的属性新增和删除也可以被监听。</li><li>Proxy 可以直接监听数组的变化。因此数组直接修改下标的内容以及长度也可以被监听。</li><li>Proxy 有多达13种拦截方法，不限于apply、deleteProperty、has等</li></ul><h2 id="diff算法优化"><a href="#diff算法优化" class="headerlink" title="diff算法优化"></a>diff算法优化</h2><ul><li>Vue2中的虚拟dom是进行全量比对</li><li>Vue3新增了静态标记（<code>PatchFlag</code>）</li></ul><p>在与上次虚拟节点进行比对时候，只对比带有<code>patch flag</code>的节点（绑定了响应式数据的节点）， 并且可以通过flag的信息 得知当前节点要比对的具体内容。</p><h1 id="新特性"><a href="#新特性" class="headerlink" title="新特性"></a>新特性</h1><h2 id="组合式API"><a href="#组合式API" class="headerlink" title="组合式API"></a>组合式API</h2><h3 id="为什么"><a href="#为什么" class="headerlink" title="为什么"></a>为什么</h3><p>总结一下就是：<strong>避免逻辑关注点过于碎片化，</strong>提高代码的可读性和可维护性。</p><p>在Vue2中，我们如果要实现一个需求，那么这些逻辑会被分散在data、methods、computed等各个<code>Options API</code>，而在Vue3中，我们可以将同一个需求的各个逻辑模块整合起来，放在<code>Composition API</code>。如果用颜色来区分各个逻辑块，那么下图可以直观地展示这种区别。</p><p><img src="/images/vue3-switch/composition.png"></p><h3 id="setup"><a href="#setup" class="headerlink" title="setup"></a>setup</h3><ul><li><p>一个接受<code>props</code>和<code>context</code>的函数，从<code>setup</code>返回的内容都将暴露给组件的其余部分</p><ul><li>props: 传入组件的属性:setup 中接收的<code>props</code>是响应式的， 当传入新的 props 时，会及时被更新。由于是响应式的， 所以<strong>不可以使用 ES6 解构</strong>，解构会消除它的响应式</li><li>context：暴露<code>attrs</code>、<code>slots</code>、<code>emit</code>这三个组件的property</li></ul></li><li><p>在<strong>创建组件之前</strong>，初始化 props 之后调用执行，因此<code>setup</code>中无法访问组件实例<code>this</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="title">beforeCreate</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;beforeCreate&#x27;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">created</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;created&#x27;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;mounted&#x27;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  setup (props, context) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;setup&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// setup</span></span><br><span class="line"><span class="comment">// beforeCreate</span></span><br><span class="line"><span class="comment">// created</span></span><br><span class="line"><span class="comment">// mounted</span></span><br></pre></td></tr></table></figure></li><li><p>我刚开始使用<code>setup</code>的时候，也产生过疑惑，这样不是将所有的代码都塞到<code>setup</code>里面，让它变得非常庞大臃肿吗？官方文档给出了解决方案——将各逻辑模块分别提取到独立的<a href="https://vue3js.cn/docs/zh/guide/composition-api-introduction.html#%E7%8B%AC%E7%AB%8B%E7%9A%84-computed-%E5%B1%9E%E6%80%A7"><strong>组合式函数</strong></a></p></li></ul><h3 id="reactive"><a href="#reactive" class="headerlink" title="reactive"></a>reactive</h3><ul><li>reactive是Vue3中提供的实现响应式数据的方法</li><li>在Vue2中响应式数据是通过defineProperty来实现的，而在Vue3中响应式数据是通过ES6的Proxy来实现的</li></ul><p><strong>注意</strong>:</p><ul><li><p>reactive参数必须是对象（json/arr）</p></li><li><p>如果给reactive传递了其他对象</p><ul><li>默认情况下修改对象，界面不会自动更新</li><li>如果想更新，可以通过重新赋值的方式</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;p&gt;&#123;&#123;state.age&#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;button @click=<span class="string">&quot;myFn&quot;</span>&gt;点我&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">import</span> &#123; reactive &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  name: <span class="string">&#x27;App&#x27;</span>,</span><br><span class="line">  <span class="function"><span class="title">setup</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> state = reactive(&#123;</span><br><span class="line">      age: <span class="number">123</span>,</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">myFn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      state.age = <span class="number">666</span></span><br><span class="line">      <span class="built_in">console</span>.log(state) <span class="comment">// Proxy&#123;age:666&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      state,</span><br><span class="line">      myFn,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li></ul><h3 id="带ref-的响应式变量-响应式引用"><a href="#带ref-的响应式变量-响应式引用" class="headerlink" title="带ref 的响应式变量 (响应式引用)"></a>带ref 的响应式变量 (响应式引用)</h3><ul><li><p>在setup中直接声明的变量是非响应式的，因此需引入<code>ref</code>函数</p></li><li><p><code>ref</code>接受参数并返回一个<a href="https://juejin.cn/post/6844904041357508615">包装对象</a>，包装对象具有 <code>value</code> property ，可使用该 property 访问或更改响应式变量的值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ref &#125; form <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> visible = ref(<span class="literal">false</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(visible) <span class="comment">// &#123; value: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(visible.value) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">visible.value = <span class="literal">true</span></span><br><span class="line"><span class="built_in">console</span>.log(visible.value) <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><a href="https://juejin.cn/post/6844904042242523144#heading-4">为什么要返回一个包装对象</a>?</p><p>提供一个让我们能够在函数之间以引用的方式传递任意类型值的容器。这个容器可以在封装了逻辑的组合函数中将状态以引用的方式传回给组件。组件负责展示（追踪依赖），组合函数负责管理状态（触发更新）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">setup</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> valueA = useLogicA() <span class="comment">// valueA 可能被 useLogicA() 内部的代码修改从而触发更新</span></span><br><span class="line">  <span class="keyword">const</span> valueB = useLogicB()</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    valueA,</span><br><span class="line">    valueB</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 作者：摸鱼架构师</span></span><br><span class="line"><span class="comment">// 链接：https://juejin.cn/post/6844904042242523144</span></span><br><span class="line"><span class="comment">// 来源：掘金</span></span><br></pre></td></tr></table></figure></li><li><p>ref底层的本质其实还是reactive，系统会自动根据我们给ref传入的值将它转换成<code>ref(xx) -&gt; reactive(&#123;value: xx&#125;)</code></p></li></ul><h3 id="ref和reactive的区别"><a href="#ref和reactive的区别" class="headerlink" title="ref和reactive的区别"></a>ref和reactive的区别</h3><p>其目的都是对数据添加响应式效果,<strong>区别在于是否需要添加一层引用包装</strong></p><p>Vue在处理的时候会先判断数据是什么类型的：</p><ul><li>如果在template里面使用的是ref类型(<code>__v_isRef</code>)的数据，那么Vue会自动帮我们添加.value</li><li>如果template里使用的是reactive类型的数据，那么Vue不会自动帮我们添加.value</li></ul><h4 id="isRef和isReactive"><a href="#isRef和isReactive" class="headerlink" title="isRef和isReactive"></a>isRef和isReactive</h4><p>通过 <code>isRef</code> 和<code>isReactive</code>可以判断数据是 <code>ref</code> 还是 <code>reactive</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> age = ref(<span class="number">18</span>)</span><br><span class="line"><span class="keyword">const</span> state = reactive(&#123; <span class="attr">age</span>: <span class="number">18</span> &#125;)</span><br><span class="line"><span class="built_in">console</span>.log(isRef(age),<span class="string">&#x27;isRef--age&#x27;</span>)  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(isRef(state),<span class="string">&#x27;isRef--state&#x27;</span>)  <span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(isReactive(age),<span class="string">&#x27;isReactive--age&#x27;</span>)  <span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(isReactive(state),<span class="string">&#x27;isReactive--state&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="toRefs"><a href="#toRefs" class="headerlink" title="toRefs"></a>toRefs</h3><p>解构的同时保持<code>props</code>和<code>reactive</code>内部变量的响应式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; toRefs &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="function"><span class="title">setup</span>(<span class="params">props</span>)</span>&#123;</span><br><span class="line"><span class="keyword">const</span> &#123; user &#125; = toRefs(props)</span><br><span class="line">    consloe.log(user.value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;img alt=<span class="string">&quot;Vue logo&quot;</span> src=<span class="string">&quot;./assets/logo.png&quot;</span> /&gt;</span><br><span class="line">  &lt;h1&gt;&#123;&#123; title &#125;&#125;&lt;/h1&gt;</span><br><span class="line">  &lt;button @click=<span class="string">&quot;handleClick&quot;</span>&gt;✌&lt;/button&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang=<span class="string">&quot;ts&quot;</span>&gt;</span><br><span class="line"><span class="keyword">import</span> &#123; defineComponent, reactive, toRefs &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> defineComponent(&#123;</span><br><span class="line">  name: <span class="string">&quot;App&quot;</span>,</span><br><span class="line">  <span class="function"><span class="title">setup</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> data = reactive(&#123;</span><br><span class="line">      title: <span class="string">&quot;你好, Vue3&quot;</span>,</span><br><span class="line">      handleClick: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        data.title = <span class="string">&quot;数据来了&quot;</span>;</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">const</span> dataAsRefs = toRefs(data);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    Type of dataAsRefs:</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        title: Ref&lt;string&gt;,</span></span><br><span class="line"><span class="comment">        handleClick: Ref&lt;() =&gt; void&gt;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">return</span> &#123; ...dataAsRefs &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line">&lt;/script&gt;   </span><br></pre></td></tr></table></figure><h3 id="computed属性"><a href="#computed属性" class="headerlink" title="computed属性"></a>computed属性</h3><ul><li><p>使用从 Vue 导入的 <code>computed</code> 函数在 Vue 组件外部创建计算属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ref, computed &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> counter = ref(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">const</span> twiceTheCounter = computed(<span class="function">() =&gt;</span> counter.value * <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">counter.value++</span><br><span class="line"><span class="built_in">console</span>.log(counter.value) <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(twiceTheCounter.value) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure></li><li><p><code>computed</code>函数返回一个<em>只读</em>的<strong>响应式引用</strong>，由一个作为 <code>computed</code> 的第一个参数传递的 getter 类回调输出。为了访问新创建的计算变量的 <strong>value</strong>，我们需要像使用 <code>ref</code> 一样使用 <code>.value</code> property。</p></li></ul><h3 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h3><p><code>watch</code> 需要侦听特定的数据源，并在回调函数中执行副作用。默认情况下，它也是惰性的，即只有当被侦听的源发生变化时才执行回调</p><h4 id="侦听单个数据源"><a href="#侦听单个数据源" class="headerlink" title="侦听单个数据源"></a>侦听单个数据源</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 侦听一个 getter</span></span><br><span class="line"><span class="keyword">const</span> state = reactive(&#123; <span class="attr">count</span>: <span class="number">0</span> &#125;)</span><br><span class="line">watch(</span><br><span class="line">  () =&gt; state.count,</span><br><span class="line">  (count, prevCount) =&gt; &#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接侦听ref</span></span><br><span class="line"><span class="keyword">const</span> count = ref(<span class="number">0</span>)</span><br><span class="line">watch(count, <span class="function">(<span class="params">count, prevCount</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="侦听多个数据源"><a href="#侦听多个数据源" class="headerlink" title="侦听多个数据源"></a>侦听多个数据源</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">watch([fooRef, barRef], <span class="function">(<span class="params">[foo, bar], [prevFoo, prevBar]</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="watchEffect"><a href="#watchEffect" class="headerlink" title="watchEffect"></a>watchEffect</h3><p><code>watchEffect</code>方法接收的第一个参数：<code>effect</code>函数，用于定义副作用。他会立即执行传入的<code>effect</code>函数，同时响应式追踪其依赖，并在其依赖变更时重新运行该函数。</p><p>目的：为了根据响应式状态<em>自动应用</em>和<em>重新应用</em>副作用</p><blockquote><p>注：函数副作用是指当调用函数时，除了返回函数值之外，还对主调用函数产生附加的影响。副作用的函数不仅仅只是返回了一个值，而且还做了其他的事情</p></blockquote><p>如下代码中，副作用函数的作用是：当 <code>count</code> 被访问时，旋即在控制台打出日志。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> count = ref(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">watchEffect(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(count.value))</span><br><span class="line"><span class="comment">// -&gt; logs 0</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  count.value++</span><br><span class="line">  <span class="comment">// -&gt; logs 1</span></span><br><span class="line">&#125;, <span class="number">100</span>)</span><br></pre></td></tr></table></figure><h4 id="副作用刷新时机"><a href="#副作用刷新时机" class="headerlink" title="副作用刷新时机"></a>副作用刷新时机</h4><p>默认情况下，会在所有的组件 <code>update</code> <strong>前</strong>执行，如果需要在组件更新<strong>后</strong>重新运行侦听器副作用，可以传递带有 <code>flush</code> 选项的附加 <code>options</code> 对象 (默认为 <code>&#39;pre&#39;</code>)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fire before component updates</span></span><br><span class="line">watchEffect(</span><br><span class="line">  () =&gt; &#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    flush: <span class="string">&#x27;post&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h4 id="停止侦听"><a href="#停止侦听" class="headerlink" title="停止侦听"></a>停止侦听</h4><p><code>watchEffect</code>会返回一个用于停止这个监听的函数。</p><ul><li><p>这个函数可以在组件被卸载时隐式调用：当 <code>watchEffect</code> 在组件的 setup() 函数或生命周期钩子被调用时，侦听器会被链接到该组件的生命周期，并在组件卸载时自动停止</p></li><li><p>也可以在<code>setup</code>函数里被显式调用，以停止侦听</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> stop = watchEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// later</span></span><br><span class="line">stop()</span><br></pre></td></tr></table></figure></li></ul><h4 id="清除副作用"><a href="#清除副作用" class="headerlink" title="清除副作用"></a>清除副作用</h4><p>有时副作用函数会执行一些异步的副作用，比如当数据变化时发送一次异步请求，如果请求过程中数据发生多次变化，那么就得多次发送请求。这样不仅浪费资源，还会因无法判断异步请求的执行顺序增加不确定性。</p><p>为了解决这个问题，<code>watchEffect</code>副作用传入的函数接收一个<code>onInvalidate</code>函数作为入参，用来注册清理失效时的回调。</p><p><code>onInvalidate</code>只作用于异步函数，并且只有在如下两种情况下才会被调用：</p><ul><li>副作用即将重新执行时</li><li>侦听器被停止 (如果在 <code>setup()</code> 或生命周期钩子函数中使用了 <code>watchEffect</code>，则在组件卸载时)</li></ul><p>我的理解中对异步副作用的清除就相当于<strong>函数防抖</strong>，执行这一次的副作用时，清理上一次的异步副作用，使得之前挂起的异步操作无效。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">watchEffect(<span class="function"><span class="params">onInvalidate</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 异步api调用，返回一个操作对象</span></span><br><span class="line">  <span class="keyword">const</span> token = performAsyncOperation(id.value)</span><br><span class="line">  onInvalidate(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 取消异步api的调用。</span></span><br><span class="line">    token.cancel()</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>Vue3 之所以是通过传入一个函数去注册失效回调，而不是从回调返回它，是因为返回值对于异步错误处理很重要。</p><p>在执行数据请求时，副作用函数往往是一个异步函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> data = ref(<span class="literal">null</span>)</span><br><span class="line">watchEffect(<span class="keyword">async</span> onInvalidate =&gt; &#123;</span><br><span class="line">  onInvalidate(<span class="function">() =&gt;</span> &#123;...&#125;) <span class="comment">// 在Promise解析之前注册清除函数</span></span><br><span class="line">  data.value = <span class="keyword">await</span> fetchData(props.id)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="watchEffect和watch的区别"><a href="#watchEffect和watch的区别" class="headerlink" title="watchEffect和watch的区别"></a>watchEffect和watch的区别</h3><ul><li> <code>watchEffect</code> 不需要指定监听的属性，他会自动的收集依赖， 只要我们回调中引用到了 响应式的属性， 那么当这些属性变更的时候，这个回调都会执行，而 <code>watch</code> 只能监听指定的属性而做出变更(v3开始可以同时指定多个)。</li><li> <code>watch</code> 访问侦听状态变化前后的值。</li><li> <code>watch</code>可以懒执行回调：<code> watchEffect</code> 如果存在，组件初始化的时候就会执行一次用以收集依赖（与<code>computed</code>同理），而后收集到的依赖发生变化，这个回调才会再次执行，而 watch 不需要，因为他一开始就指定了依赖。</li></ul><h2 id="Fragment"><a href="#Fragment" class="headerlink" title="Fragment"></a>Fragment</h2><p>组件现在可以有多个根节点，此时需要明确定义属性应该分布在哪里。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">header</span>&gt;</span>...<span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">main</span> <span class="attr">v-bind</span>=<span class="string">&quot;$attrs&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">footer</span>&gt;</span>...<span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="Teleport组件"><a href="#Teleport组件" class="headerlink" title="Teleport组件"></a>Teleport组件</h2><p><code>vue3</code>提供了一个非常方便的新特性——<code>teloport</code>，可以理解为传送门，允许我们控制在 DOM 中哪个父节点下呈现 HTML，将模板渲染的位置与组件逻辑剥离开来。</p><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p><code>teleport</code>接受两个属性：</p><p><strong>to - string</strong></p><p>以<code>Dialog</code>组件为例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Teleport</span> <span class="attr">to</span>=<span class="string">&quot;#app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;xx-dialog-overlay&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;onClickOverlay&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;xx-dialog-wrapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;xx-dialog&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">header</span> <span class="attr">:class</span>=<span class="string">&quot;&#123; &#x27;title&#x27;: title || $slots.title &#125;&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>=<span class="string">&quot;$slots.title&quot;</span> <span class="attr">class</span>=<span class="string">&quot;title-slot&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;title&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-else</span>&gt;</span>&#123;&#123; title &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;xx-dialog-close&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;close&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">main</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">slot</span> <span class="attr">v-if</span>=<span class="string">&quot;$slots.content&quot;</span> <span class="attr">name</span>=<span class="string">&quot;content&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else</span>&gt;</span>&#123;&#123; content &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">footer</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">x-button</span> <span class="attr">size</span>=<span class="string">&quot;small&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;onCancel&quot;</span>&gt;</span>取消<span class="tag">&lt;/<span class="name">x-button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">x-button</span> <span class="attr">size</span>=<span class="string">&quot;small&quot;</span> <span class="attr">theme</span>=<span class="string">&quot;primary&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;onConfirm&quot;</span>&gt;</span>确定<span class="tag">&lt;/<span class="name">x-button</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Teleport</span>&gt;</span></span><br></pre></td></tr></table></figure><p>效果演示：</p><p><img src="/images/vue3-dialog/teleport.png"></p><p>可以看到通过<code>to</code>属性，指定该组件挂载到了<code>&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</code>中。</p><p><strong>注意</strong>：</p><ul><li><p><code>to</code>属性传入的值必须是有效的查询选择器或 HTMLElement</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 正确 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">teleport</span> <span class="attr">to</span>=<span class="string">&quot;#some-id&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">teleport</span> <span class="attr">to</span>=<span class="string">&quot;.some-class&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">teleport</span> <span class="attr">to</span>=<span class="string">&quot;[data-teleport]&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 错误 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">teleport</span> <span class="attr">to</span>=<span class="string">&quot;h1&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">teleport</span> <span class="attr">to</span>=<span class="string">&quot;some-string&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>默认挂载到第一个选择的元素</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span>container1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span>container2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">teleport</span> <span class="attr">to</span>=<span class="string">&quot;.container&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">teleport</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><p><img src="/images/vue3-dialog/teleport1.png" alt="挂载到第一个.container"></p><p><strong>disabled-boolean</strong></p><p>此可选属性可用于禁用 <code>teleport</code> 的功能，这意味着其插槽内容将不会移动到任何位置，而是在您在周围父组件中指定了 <code>teleport</code> 的位置渲染。</p><h3 id="与-Vue-components-一起使用"><a href="#与-Vue-components-一起使用" class="headerlink" title="与 Vue components 一起使用"></a>与 Vue components 一起使用</h3><p>如果 <code>teleport</code> 包含 Vue 组件，则它仍将是 <code>teleport</code> 父组件的逻辑子组件，仍接收父组件传来的属性。</p><h2 id="Suspense组件"><a href="#Suspense组件" class="headerlink" title="Suspense组件"></a>Suspense组件</h2><p><code>Suspense</code> 是Vue3推出的一个内置特殊组件，用来定义具有异步请求数据的组件的显示。如果使用 Suspense，要 setup函数中需要返回一个 <code>Promise</code>。</p><p>新建 <code>AyncShow.vue</code> 文件，setup函数需要返回一个Promise对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;h1&gt;&#123;&#123;result&#125;&#125;&lt;/h1&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script lang=<span class="string">&quot;ts&quot;</span>&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="function"><span class="title">setup</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resoluve</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">                resoluve(&#123;<span class="attr">result</span>: <span class="number">100</span>&#125;)</span><br><span class="line">            &#125;, <span class="number">2000</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>在<code>App.vue</code>中使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;Suspense&gt;</span><br><span class="line">      &lt;template #<span class="keyword">default</span>&gt; </span><br><span class="line">        &lt;div&gt;</span><br><span class="line">          &lt;AsyncShow/&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">      &lt;/template&gt;</span><br><span class="line">      &lt;template #fallback&gt;</span><br><span class="line">        &lt;h1&gt;Loading...&lt;/h1&gt;</span><br><span class="line">      &lt;/template&gt;</span><br><span class="line">  &lt;/Suspense&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang=<span class="string">&quot;ts&quot;</span>&gt;</span><br><span class="line"><span class="keyword">import</span> &#123; defineComponent, ref, toRefs&#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> AsyncShow <span class="keyword">from</span> <span class="string">&#x27;./components/AsyncShow.vue&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> defineComponent(&#123;</span><br><span class="line">  name: <span class="string">&#x27;App&#x27;</span>,</span><br><span class="line">  components: &#123;</span><br><span class="line">    AsyncShow</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><ul><li><code>Suspense</code>组件内置了两个具名插槽slot,一个是<code>default</code>，用来显示异步组件请求成功的内容；一个是<code>fallback</code>用来显示异步组件请求响应前页面显示的内容。</li><li><code>default</code>插槽可以有多个组件，但是需要有一个根节点。</li></ul><h2 id="defineComponent"><a href="#defineComponent" class="headerlink" title="defineComponent"></a>defineComponent</h2><p><code>defineComponent</code>为了支持 TypeScript 存在的。defineComponent并没有实现特殊逻辑，可以将传入的对象获得对应的类型。我们使用defineComponent定义的组件可以很好的支持 setup、props等的类型提示。</p><h1 id="非兼容的变更"><a href="#非兼容的变更" class="headerlink" title="非兼容的变更"></a>非兼容的变更</h1><h2 id="全局API"><a href="#全局API" class="headerlink" title="全局API"></a>全局API</h2><h3 id="Vue2的全局API"><a href="#Vue2的全局API" class="headerlink" title="Vue2的全局API"></a>Vue2的全局API</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">&#x27;button-counter&#x27;</span>, &#123;</span><br><span class="line">  data: <span class="function">() =&gt;</span> (&#123;</span><br><span class="line">    count: <span class="number">0</span></span><br><span class="line">  &#125;),</span><br><span class="line">  template: <span class="string">&#x27;&lt;button @click=&quot;count++&quot;&gt;Clicked &#123;&#123; count &#125;&#125; times.&lt;/button&gt;&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">Vue.directive(<span class="string">&#x27;focus&#x27;</span>, &#123;</span><br><span class="line">  inserted: <span class="function"><span class="params">el</span> =&gt;</span> el.focus()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这样会导致同一个 Vue 构造函数<strong>创建的每个根实例共享相同的全局配置</strong></p><p>为了避免这些问题，在Vue3中引入了<code>createApp</code></p><h3 id="Vue3-createApp"><a href="#Vue3-createApp" class="headerlink" title="Vue3 createApp"></a>Vue3 createApp</h3><p>调用 <code>createApp</code> 返回一个应用实例，应用实例暴露当前全局 API 的子集，经验法则是，任何全局改变 Vue 行为的 API 现在都会移动到应用实例上</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> app = createApp(MyApp)</span><br><span class="line"></span><br><span class="line">app.component(<span class="string">&#x27;button-counter&#x27;</span>, &#123;</span><br><span class="line">  data: <span class="function">() =&gt;</span> (&#123;</span><br><span class="line">    count: <span class="number">0</span></span><br><span class="line">  &#125;),</span><br><span class="line">  template: <span class="string">&#x27;&lt;button @click=&quot;count++&quot;&gt;Clicked &#123;&#123; count &#125;&#125; times.&lt;/button&gt;&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.directive(<span class="string">&#x27;focus&#x27;</span>, &#123;</span><br><span class="line">  mounted: <span class="function"><span class="params">el</span> =&gt;</span> el.focus()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在所有应用实例都挂载了，与其组件树一起，将具有相同的 “button-counter” 组件 和 “focus” 指令不污染全局环境</span></span><br><span class="line">app.mount(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="v-model"><a href="#v-model" class="headerlink" title="v-model"></a>v-model</h2><h3 id="Vue2的v-model"><a href="#Vue2的v-model" class="headerlink" title="Vue2的v-model"></a>Vue2的v-model</h3><ul><li><p>Vue2.x中，在组件上使用 <code>v-model</code> 相当于绑定 <code>value</code> prop 和 <code>input</code> 事件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">x-switch</span> <span class="attr">v-model</span>=<span class="string">&quot;checked&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 简写: --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">x-switch</span> <span class="attr">:value</span>=<span class="string">&quot;checked&quot;</span> @<span class="attr">input</span>=<span class="string">&quot;checked = $event&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>如果想更改绑定的属性名，或绑定多个变量，可使用<code>.sync</code></p><p>子组件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.$emit(<span class="string">&#x27;update:value&#x27;</span>, newValue)</span><br></pre></td></tr></table></figure><p>父组件：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">x-switch</span> <span class="attr">:value.sync</span>=<span class="string">&quot;checked&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="Vue3的v-model"><a href="#Vue3的v-model" class="headerlink" title="Vue3的v-model"></a>Vue3的v-model</h3><ul><li>属性名任意，假设为 x</li><li>事件名必须为 <code>&#39;update:x&#39;</code></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">x-switch</span> <span class="attr">v-model:value</span>=<span class="string">&quot;checked&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 简写: --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">x-switch</span> <span class="attr">:value</span>=<span class="string">&quot;checked&quot;</span> @<span class="attr">update:value</span>=<span class="string">&quot;checked = $event&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><h2 id="h-渲染函数"><a href="#h-渲染函数" class="headerlink" title="h() 渲染函数"></a>h() 渲染函数</h2><p><code>Vue2</code>中的<a href="https://vuejs.bootcss.com/guide/render-function.html">渲染函数</a>为<code>createElement()</code>，而在<code>Vue3</code>中被称为<code>h()</code>，用于创建虚拟节点（更准确地命名为<code>createVNode()</code>，出于频繁使用和简洁的目的，改为了<code>h()</code>）。</p><p><code>h()</code>同样接受三个参数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @returns &#123;VNode&#125;</span></span><br><span class="line">h(</span><br><span class="line">  <span class="comment">// &#123;String | Object | Function | null&#125; tag</span></span><br><span class="line">  <span class="comment">// 一个 HTML 标签名、一个组件、一个异步组件，或者 null。</span></span><br><span class="line">  <span class="comment">// 使用 null 将会渲染一个注释。</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// 必需的。</span></span><br><span class="line">  <span class="string">&#x27;div&#x27;</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// &#123;Object&#125; props</span></span><br><span class="line">  <span class="comment">// 与 attribute、prop 和事件相对应的对象。</span></span><br><span class="line">  <span class="comment">// 我们会在模板中使用。</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// 可选的。</span></span><br><span class="line">  &#123;&#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// &#123;String | Array | Object&#125; children</span></span><br><span class="line">  <span class="comment">// 子 VNodes, 使用 `h()` 构建,</span></span><br><span class="line">  <span class="comment">// 或使用字符串获取 &quot;文本 Vnode&quot; 或者</span></span><br><span class="line">  <span class="comment">// 有 slot 的对象。</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// 可选的。</span></span><br><span class="line">  [</span><br><span class="line">    <span class="string">&#x27;Some text comes first.&#x27;</span>,</span><br><span class="line">    h(<span class="string">&#x27;h1&#x27;</span>, <span class="string">&#x27;A headline&#x27;</span>),</span><br><span class="line">    h(MyComponent, &#123;</span><br><span class="line">      someProp: <span class="string">&#x27;foobar&#x27;</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>实际应用如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> XDialog <span class="keyword">from</span> <span class="string">&#x27;../Dialog.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; createApp, h &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> openDialog = (&#123;</span><br><span class="line">    title = <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    content = <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    onConfirm = <span class="function">() =&gt;</span> &#123;&#125;,</span><br><span class="line">    onCancel = <span class="function">() =&gt;</span> &#123;&#125;,</span><br><span class="line">    closeOnClickOverlay = <span class="literal">true</span></span><br><span class="line">&#125;) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> div =  <span class="built_in">document</span>.createElement(<span class="string">&#x27;div&#x27;</span>)</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(div)</span><br><span class="line">    <span class="keyword">const</span> close = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        app.unmount()</span><br><span class="line">        div.remove()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> app = createApp(&#123;</span><br><span class="line">        <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> h(</span><br><span class="line">                XDialog,</span><br><span class="line">                &#123;</span><br><span class="line">                    visible: <span class="literal">true</span>,</span><br><span class="line">                    title,</span><br><span class="line">                    content,</span><br><span class="line">                    onConfirm,</span><br><span class="line">                    onCancel,</span><br><span class="line">                    closeOnClickOverlay,</span><br><span class="line">                    <span class="string">&#x27;onUpdate:visible&#x27;</span>:<span class="function">(<span class="params">newVisible</span>) =&gt;</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (!newVisible) &#123;</span><br><span class="line">                            close()</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    app.mount(div)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h2><p>在 Vue 2 中，在 <code>v-for</code> 里使用的 <code>ref</code>  会用 ref 数组填充相应的 <code>$refs</code> property。当存在嵌套的 <code>v-for</code> 时，这种行为会变得不明确且效率低下。</p><p>在 Vue 3 中，这样的用法将不再在 <code>$ref</code> 中自动创建数组。如果要从单个绑定获取多个 ref，需将 <code>ref</code> 绑定到一个更灵活的函数上</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">&quot;item in list&quot;</span> <span class="attr">:ref</span>=<span class="string">&quot;setItemRef&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ref, onBeforeUpdate, onUpdated &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="function"><span class="title">setup</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> itemRefs = []</span><br><span class="line">    <span class="keyword">const</span> setItemRef = <span class="function"><span class="params">el</span> =&gt;</span> &#123;</span><br><span class="line">      itemRefs.push(el) <span class="comment">// 这里的el即为循环的DOM元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      itemRefs,</span><br><span class="line">      setItemRef</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="v-bind-”object“排序"><a href="#v-bind-”object“排序" class="headerlink" title="v-bind=”object“排序"></a>v-bind=”object“排序</h2><h3 id="Vue2-单独的-property优先"><a href="#Vue2-单独的-property优先" class="headerlink" title="Vue2 单独的 property优先"></a>Vue2 单独的 property优先</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- template --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;red&quot;</span> <span class="attr">v-bind</span>=<span class="string">&quot;&#123; id: &#x27;blue&#x27; &#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- result --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;red&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Vue3-绑定顺序决定渲染结果"><a href="#Vue3-绑定顺序决定渲染结果" class="headerlink" title="Vue3 绑定顺序决定渲染结果"></a>Vue3 绑定顺序决定渲染结果</h3><p>v-bind 的绑定顺序会影响渲染结果</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- template --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;red&quot;</span> <span class="attr">v-bind</span>=<span class="string">&quot;&#123; id: &#x27;blue&#x27; &#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- result --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;blue&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- template --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind</span>=<span class="string">&quot;&#123; id: &#x27;blue&#x27; &#125;&quot;</span> <span class="attr">id</span>=<span class="string">&quot;red&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- result --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;red&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;亮点&quot;&gt;&lt;a href=&quot;#亮点&quot; class=&quot;headerlink&quot; title=&quot;亮点&quot;&gt;&lt;/a&gt;亮点&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Performance（比Vue2 runtime快了两倍）&lt;/li&gt;
&lt;li&gt;Tree shaking (按需编译代码)&lt;/l</summary>
      
    
    
    
    <category term="Vue" scheme="https://wuyangqin.github.io/categories/Vue/"/>
    
    <category term="Vue3" scheme="https://wuyangqin.github.io/categories/Vue/Vue3/"/>
    
    
    <category term="Vue" scheme="https://wuyangqin.github.io/tags/Vue/"/>
    
    <category term="Vue3" scheme="https://wuyangqin.github.io/tags/Vue3/"/>
    
  </entry>
  
  <entry>
    <title>Vue3造轮子总结 - 基于Vite + Vue3 + TypeScript实现的简单UI框架</title>
    <link href="https://wuyangqin.github.io/2021/03/19/Vue3-ui-notes/"/>
    <id>https://wuyangqin.github.io/2021/03/19/Vue3-ui-notes/</id>
    <published>2021-03-19T14:51:34.000Z</published>
    <updated>2021-04-14T03:32:32.627Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>历时将近一个月的时间，Vue3造轮子的项目暂时完结，果然不断实践不断踩坑才是巩固新知识的最好方法，对Vue3算是有了一个整体的把握。把官网部署上线之后成就感也是满满的哈哈哈。所以先对这个项目进行一个整体的回顾~</p><h2 id="技术细节"><a href="#技术细节" class="headerlink" title="技术细节"></a>技术细节</h2><ul><li>使用<code>Vue3</code> + <code>TypeScript</code> 开发组件，基本运用了<code>Vue3</code>的新特性</li><li>使用<code>Vue3 </code>+ <code>Vue Router</code>制作官网，官网支持代码的预览和展示，并进行了移动端适配</li><li>使用<code>marked</code>实现官网对Markdown文件的支持</li><li>使用<code>prism.js</code>实现代码的高亮展示</li><li>使用<code>Vite</code>进行项目的搭建、开发和部署</li><li>手动编写 shell 自动化部署脚本</li><li>使用 <code>Rollup</code> 打包库文件，并发布到 npm</li></ul><h2 id="成果展示"><a href="#成果展示" class="headerlink" title="成果展示"></a>成果展示</h2><p><img src="/images/vue/vue3-ui-index.png"></p><p><a href="https://wuyangqin.github.io/xing-ui-v3-dist/#/">官网地址</a></p><p><a href="https://github.com/wuyangqin/xing-ui-v3">源码查看</a></p><h2 id="项目回顾"><a href="#项目回顾" class="headerlink" title="项目回顾"></a>项目回顾</h2><h3 id="项目搭建"><a href="#项目搭建" class="headerlink" title="项目搭建"></a>项目搭建</h3><p>项目采用<code>vite</code>来搭建项目</p><ul><li><p>什么是vite</p><p><code>vite</code> 是一个由原生 <strong>ESM</strong> 驱动的Web开发构建工具。在开发环境下基于浏览器原生 <code>ES imports</code> 开发，在生产环境下基于 <code>Rollup</code> 打包</p></li><li><p>vite的特点</p><ul><li>快速的冷启动：不需要等待打包操作；即时的热模块更新</li><li>替换性能和模块数量的解耦让更新飞起；</li><li>真正的按需编译：不再等待整个应用编译完成</li></ul></li><li><p>创建项目</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装脚手架工具</span></span><br><span class="line">yarn global add create-vite-app@1.18.0</span><br><span class="line"><span class="comment"># 创建并进入工程目录</span></span><br><span class="line">mkdir xing-ui-v3 &amp;&amp; <span class="built_in">cd</span> xing-ui-v3</span><br><span class="line"><span class="comment"># 创建项目目录</span></span><br><span class="line">cva xing-ui-v3</span><br></pre></td></tr></table></figure></li><li><p>项目主要目录结构</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">├── index.html</span><br><span class="line">├── vite.config.ts<span class="comment"># vite配置文件</span></span><br><span class="line">├── public<span class="comment"># 该项目静态资源</span></span><br><span class="line">├── plugins<span class="comment"># 该项目所使用插件</span></span><br><span class="line">└── src</span><br><span class="line">    ├── assets  </span><br><span class="line">    |└── css<span class="comment"># 公共css文件</span></span><br><span class="line">├── components<span class="comment"># 制作官网需要的组件</span></span><br><span class="line">├── lib<span class="comment"># 需导出的UI组件库</span></span><br><span class="line">├── markdown<span class="comment"># 官网展示所需md文件</span></span><br><span class="line">├── router<span class="comment"># 路由</span></span><br><span class="line">├── views<span class="comment"># 官网页面逻辑</span></span><br><span class="line">├── App.vue</span><br><span class="line">├── main.ts</span><br><span class="line">    └── index.scss</span><br></pre></td></tr></table></figure></li></ul><h3 id="组件开发"><a href="#组件开发" class="headerlink" title="组件开发"></a>组件开发</h3><h4 id="组件开发思路"><a href="#组件开发思路" class="headerlink" title="组件开发思路"></a>组件开发思路</h4><p>每个组件的开发基本遵循的开发思路为：</p><p><img src="/images/vue/vue3-components.png"></p><ol><li><p>需求分析：明确每个组件需要实现的功能，交互方式，设计基本样式和API</p></li><li><p>逻辑实现：将功能上的逻辑走通，下文会详细叙述每个组件开发过程中运用到的<code>Vue3</code>新特性、遇到的问题及解决过程</p></li><li><p>完善css样式：为方便后期维护，将组件库的公共scss变量以及各个组件的scss变量存放到公共的scss文件中</p><p>*注：在该项目的开发中，尝试配置全局的scss文件失败，后续会继续尝试优化</p></li><li><p>优化测试：优化代码，测试功能是否正常运行，后续会添加每个组件的单元测试，以及实现持续集成测试</p></li></ol><p><em>注：该UI框架的开发是以学习<code>Vue3</code>为主要目的，因此每个组件都只实现了部分基础功能，并不能满足实际项目开发需要；组件的功能和样式参考了主流的UI框架</em></p><h4 id="Switch-开关"><a href="#Switch-开关" class="headerlink" title="Switch 开关"></a>Switch 开关</h4><p><a href="https://wuyangqin.github.io/2021/02/20/Vue3-1-switch/">Switch组件总结</a></p><p><img src="/images/vue3-switch/switch.gif"></p><h4 id="Button-按钮"><a href="#Button-按钮" class="headerlink" title="Button 按钮"></a>Button 按钮</h4><p><a href="https://wuyangqin.github.io/2021/02/27/Vue3-2-button/">Button组件总结</a></p><p><img src="/images/vue3-button/button.png"></p><h4 id="Dialog-对话框"><a href="#Dialog-对话框" class="headerlink" title="Dialog 对话框"></a>Dialog 对话框</h4><p><a href="https://wuyangqin.github.io/2021/03/07/Vue3-3-dialog/">Dialog组件总结</a></p><p><img src="/images/vue3-dialog/dialog.png"></p><h4 id="Tabs-标签页"><a href="#Tabs-标签页" class="headerlink" title="Tabs 标签页"></a>Tabs 标签页</h4><p><a href="https://wuyangqin.github.io/2021/03/16/Vue3-4-tabs/">Tabs组件总结</a></p><p><img src="/images/vue3-tabs/tabs.gif"></p><h3 id="完善官网"><a href="#完善官网" class="headerlink" title="完善官网"></a>完善官网</h3><h4 id="支持引入markdown文件"><a href="#支持引入markdown文件" class="headerlink" title="支持引入markdown文件"></a>支持引入markdown文件</h4><ul><li><p>安装<code>marked</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add --dev marked</span><br></pre></td></tr></table></figure></li><li><p>配置<code>md.ts</code>（自制vite插件）</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @ts-nocheck</span></span><br><span class="line"><span class="keyword">import</span> path <span class="keyword">from</span> <span class="string">&#x27;path&#x27;</span></span><br><span class="line"><span class="keyword">import</span> fs <span class="keyword">from</span> <span class="string">&#x27;fs&#x27;</span></span><br><span class="line"><span class="keyword">import</span> marked <span class="keyword">from</span> <span class="string">&#x27;marked&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mdToJs = <span class="function"><span class="params">str</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> content = <span class="built_in">JSON</span>.stringify(marked(str))</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`export default <span class="subst">$&#123;content&#125;</span>`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">md</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        configureServer: [ <span class="comment">// 用于开发</span></span><br><span class="line">            <span class="keyword">async</span> (&#123; app &#125;) =&gt; &#123;</span><br><span class="line">                app.use(<span class="keyword">async</span> (ctx, next) =&gt; &#123; <span class="comment">// koa</span></span><br><span class="line">                    <span class="keyword">if</span> (ctx.path.endsWith(<span class="string">&#x27;.md&#x27;</span>)) &#123; <span class="comment">// 如果文件时以.md结尾，就转译为js(因为浏览器只支持js)</span></span><br><span class="line">                        ctx.type = <span class="string">&#x27;js&#x27;</span></span><br><span class="line">                        <span class="keyword">const</span> filePath = path.join(process.cwd(), ctx.path)</span><br><span class="line">                        ctx.body = mdToJs(fs.readFileSync(filePath).toString())</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">await</span> next()</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;,</span><br><span class="line">        ],</span><br><span class="line">        transforms: [&#123;  <span class="comment">// 用于 rollup // 插件</span></span><br><span class="line">            test: <span class="function"><span class="params">context</span> =&gt;</span> context.path.endsWith(<span class="string">&#x27;.md&#x27;</span>),</span><br><span class="line">            transform: <span class="function">(<span class="params">&#123; code &#125;</span>) =&gt;</span> mdToJs(code)</span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>创建<code>vite.config.ts</code></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @ts-nocheck</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; md &#125; <span class="keyword">from</span> <span class="string">&quot;./plugins/md&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    plugins: [md()] <span class="comment">// 使用md插件</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>使用示例</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">article</span> <span class="attr">v-mtml</span>=<span class="string">&quot;md&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> md <span class="keyword">from</span> <span class="string">&#x27;../markdown/attr-button.md&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123;ref&#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  setup () &#123;</span><br><span class="line">    <span class="keyword">const</span> md = ref&lt;<span class="built_in">string</span>&gt;(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    md.value = md</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      md</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li></ul><h4 id="代码高亮展示"><a href="#代码高亮展示" class="headerlink" title="代码高亮展示"></a>代码高亮展示</h4><ul><li><p>为什么使用<code>prism.js</code>？</p><p>在Vue2造轮子的项目中，我使用了<code>highlight.js</code>进行代码高亮，于是这个项目我也先尝试使用了这个库。</p><p>然而，引入后，运行时会报错<code>Uncaught ReferenceError: require is not defined</code>。</p><p> google后了解到，<code>vite</code>使用的是浏览器自带的<code>module</code>去解析<code>js</code>的，而<code>require</code>语法是<code>node</code>语法，因此不支持使用 <code>require</code> 方式来导入模块。</p><p>然后查看了一下<code>highlight.js</code>的源代码，发现其入口文件是这样的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> hljs = <span class="built_in">require</span>(<span class="string">&#x27;./core&#x27;</span>);</span><br><span class="line"><span class="comment">/* --- */</span></span><br><span class="line"><span class="built_in">module</span>.exports = hljs;</span><br></pre></td></tr></table></figure><p>于是只能采用方应杭老师的建议，使用<code>prism.js</code>。</p></li><li><p>如何引入</p><p>查看<code>prism.js</code>的源代码，发现有这么一段</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">global</span> !== <span class="string">&#x27;undefined&#x27;</span>) &#123;</span><br><span class="line"><span class="built_in">global</span>.Prism = Prism;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>指其声明了一个全局变量<code>Prism</code>，因此可以这样引入</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;pre <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;language-html&quot;</span> v-html=<span class="string">&quot;Prism.highlight(code, Prism.languages.html, type)&quot;</span> /&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang=<span class="string">&quot;ts&quot;</span>&gt;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;prismjs&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> Prism = (<span class="built_in">window</span> <span class="keyword">as</span> any).Prism</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>封装代码高亮组件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">pre</span> <span class="attr">class</span>=<span class="string">&quot;language-html&quot;</span> <span class="attr">v-html</span>=<span class="string">&quot;Prism.highlight(code, Prism.languages.html, type)&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> <span class="string">&#x27;prismjs&#x27;</span>;</span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> Prism = (<span class="built_in">window</span> <span class="keyword">as</span> any).Prism</span></span><br><span class="line"></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">  name: <span class="string">&#x27;pre-code&#x27;</span>,</span></span><br><span class="line">  props: &#123;</span><br><span class="line">    code: &#123;</span><br><span class="line"><span class="javascript">      type: <span class="built_in">String</span>,</span></span><br><span class="line"><span class="javascript">      <span class="keyword">default</span>: <span class="string">&#x27;&#x27;</span></span></span><br><span class="line">    &#125;,</span><br><span class="line">    type: &#123;</span><br><span class="line"><span class="javascript">      type: <span class="built_in">String</span>,</span></span><br><span class="line"><span class="javascript">      <span class="keyword">default</span>: <span class="string">&#x27;html&#x27;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"><span class="javascript">  <span class="function"><span class="title">setup</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line">      Prism</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">lang</span>=<span class="string">&quot;scss&quot;</span>&gt;</span></span><br><span class="line"><span class="css"><span class="keyword">@import</span> <span class="string">&#x27;../../assets/css/prism.css&#x27;</span>;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>封装代码展示组件</p></li></ul><p>效果：</p><p><img src="/images/vue/vue3-ui-code.png"></p><h4 id="打包部署"><a href="#打包部署" class="headerlink" title="打包部署"></a>打包部署</h4><ul><li><p>在vite.config.ts中配置build path</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    base: <span class="string">&#x27;./&#x27;</span>,</span><br><span class="line">    assetsDir: <span class="string">&#x27;assets&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>编写一键部署脚本</p><p>项目根目录添加<code>deploy.sh</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">rm -rf dist &amp;&amp;</span><br><span class="line">yarn build &amp;&amp;</span><br><span class="line"><span class="built_in">cd</span> dist &amp;&amp;</span><br><span class="line">git init &amp;&amp;</span><br><span class="line">git add . &amp;&amp;</span><br><span class="line">git commit -m <span class="string">&quot;update&quot;</span> &amp;&amp;</span><br><span class="line">git branch -M master &amp;&amp;</span><br><span class="line">git remote add origin git@github.com:wuyangqin/xing-ui-v3-dist.git &amp;&amp;</span><br><span class="line">git push -f -u origin master &amp;&amp;</span><br><span class="line"><span class="built_in">cd</span> -</span><br><span class="line"><span class="built_in">echo</span> https://wuyangqin.github.io/xing-ui-v3-dist/<span class="comment">#/</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="发布至npm"><a href="#发布至npm" class="headerlink" title="发布至npm"></a>发布至npm</h3><h4 id="rollup-编译库文件"><a href="#rollup-编译库文件" class="headerlink" title="rollup 编译库文件"></a>rollup 编译库文件</h4><ul><li><p>在<code>lib</code>目录新建<code>index.ts</code>导出需导出的文件</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123; <span class="keyword">default</span> <span class="keyword">as</span> XSwitch &#125; <span class="keyword">from</span> <span class="string">&#x27;./Switch.vue&#x27;</span></span><br><span class="line"><span class="keyword">export</span> &#123; <span class="keyword">default</span> <span class="keyword">as</span> XButton &#125; <span class="keyword">from</span> <span class="string">&#x27;./Button.vue&#x27;</span></span><br><span class="line"><span class="keyword">export</span> &#123; <span class="keyword">default</span> <span class="keyword">as</span> XTabs &#125; <span class="keyword">from</span> <span class="string">&#x27;./tabs/tabs.vue&#x27;</span></span><br><span class="line"><span class="keyword">export</span> &#123; <span class="keyword">default</span> <span class="keyword">as</span> XTab &#125; <span class="keyword">from</span> <span class="string">&#x27;./tabs/tab.vue&#x27;</span></span><br><span class="line"><span class="keyword">export</span> &#123; <span class="keyword">default</span> <span class="keyword">as</span> XDialog &#125; <span class="keyword">from</span> <span class="string">&#x27;./Dialog.vue&#x27;</span></span><br><span class="line"><span class="keyword">export</span> &#123; <span class="keyword">default</span> <span class="keyword">as</span> XIcon &#125; <span class="keyword">from</span> <span class="string">&#x27;./Icon.vue&#x27;</span></span><br><span class="line"><span class="keyword">export</span> &#123; openDialog <span class="keyword">as</span> openDialog &#125; <span class="keyword">from</span> <span class="string">&#x27;./plugin/openDialog&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>配置<code>rollup.config.js</code></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> esbuild <span class="keyword">from</span> <span class="string">&#x27;rollup-plugin-esbuild&#x27;</span> <span class="comment">// 把ts变成js</span></span><br><span class="line"><span class="keyword">import</span> vue <span class="keyword">from</span> <span class="string">&#x27;rollup-plugin-vue&#x27;</span>  <span class="comment">// 把vue结尾的文件变成js</span></span><br><span class="line"><span class="keyword">import</span> scss <span class="keyword">from</span> <span class="string">&#x27;rollup-plugin-scss&#x27;</span> <span class="comment">// 把scss结尾的变成js</span></span><br><span class="line"><span class="keyword">import</span> dartSass <span class="keyword">from</span> <span class="string">&#x27;sass&#x27;</span>; <span class="comment">// 用来支持rollup-plugin-scss插件</span></span><br><span class="line"><span class="keyword">import</span> &#123; terser &#125; <span class="keyword">from</span> <span class="string">&quot;rollup-plugin-terser&quot;</span> <span class="comment">// 把js代码变得别人看不懂</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  input: <span class="string">&#x27;src/lib/index.ts&#x27;</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    globals: &#123; <span class="comment">// 用到了外部依赖Vue</span></span><br><span class="line">      vue: <span class="string">&#x27;Vue&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    name: <span class="string">&#x27;xing-ui-v3&#x27;</span>,</span><br><span class="line">    file: <span class="string">&#x27;dist/lib/xing-ui-v3.js&#x27;</span>,</span><br><span class="line">    format: <span class="string">&#x27;umd&#x27;</span>,</span><br><span class="line">    plugins: [terser()]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    scss(&#123; <span class="attr">include</span>: <span class="regexp">/\.scss$/</span>, sass: dartSass &#125;),</span><br><span class="line">    esbuild(&#123;</span><br><span class="line">      include: <span class="regexp">/\.[jt]s$/</span>,</span><br><span class="line">      minify: process.env.NODE_ENV === <span class="string">&#x27;production&#x27;</span>,</span><br><span class="line">      target: <span class="string">&#x27;es2015&#x27;</span></span><br><span class="line">    &#125;),</span><br><span class="line">    vue(&#123;</span><br><span class="line">      include: <span class="regexp">/\.vue$/</span>,</span><br><span class="line">    &#125;)</span><br><span class="line">  ],</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>使用rollup打包</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rollup -c</span><br></pre></td></tr></table></figure></li></ul><h4 id="发布至npm-1"><a href="#发布至npm-1" class="headerlink" title="发布至npm"></a>发布至npm</h4><ul><li><p>配置package.json</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;xing-ui-v3&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;0.0.1&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;files&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;dist/lib/*&quot;</span> <span class="comment">// 发布dist/lib下的所有文件</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">&quot;main&quot;</span>: <span class="string">&quot;dist/lib/xing-ui-v3.js&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>发布</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm login</span><br><span class="line">npm publish</span><br></pre></td></tr></table></figure></li></ul><h2 id="Xing-UI-Vue2版"><a href="#Xing-UI-Vue2版" class="headerlink" title="Xing-UI Vue2版"></a>Xing-UI Vue2版</h2><p>在<code>Vue3</code>版本的UI库实现之前，还实现了<code>Vue2</code>版本，对应的官网和源码链接如下：</p><p><a href="https://wuyangqin.github.io/xing-ui/">效果预览</a></p><p><a href="https://github.com/wuyangqin/xing-ui">源码查看</a></p><h2 id="后期规划"><a href="#后期规划" class="headerlink" title="后期规划"></a>后期规划</h2><ul><li>添加图标库</li><li>添加单元测试</li><li>组件库持续更新</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;历时将近一个月的时间，Vue3造轮子的项目暂时完结，果然不断实践不断踩坑才是巩固新知识的最好方法，对Vue3算是有了一个整体的把握。把官网部</summary>
      
    
    
    
    <category term="Vue" scheme="https://wuyangqin.github.io/categories/Vue/"/>
    
    <category term="Vue3" scheme="https://wuyangqin.github.io/categories/Vue/Vue3/"/>
    
    
    <category term="Vue" scheme="https://wuyangqin.github.io/tags/Vue/"/>
    
    <category term="造轮子" scheme="https://wuyangqin.github.io/tags/%E9%80%A0%E8%BD%AE%E5%AD%90/"/>
    
    <category term="Vue3" scheme="https://wuyangqin.github.io/tags/Vue3/"/>
    
  </entry>
  
  <entry>
    <title>Vue3造轮子（四）-Tabs组件</title>
    <link href="https://wuyangqin.github.io/2021/03/16/Vue3-4-tabs/"/>
    <id>https://wuyangqin.github.io/2021/03/16/Vue3-4-tabs/</id>
    <published>2021-03-16T15:11:05.000Z</published>
    <updated>2021-04-14T01:25:52.500Z</updated>
    
    <content type="html"><![CDATA[<h2 id="效果预览"><a href="#效果预览" class="headerlink" title="效果预览"></a>效果预览</h2><p><img src="/images/vue3-tabs/tabs.gif"></p><p><a href="https://github.com/wuyangqin/xing-ui-v3">代码链接</a></p><p><a href="https://github.com/wuyangqin/xing-ui-v3/commits/07da8167bb0401938f1db86c57c54be01b7ae83c">提交历史</a></p><h2 id="API设计"><a href="#API设计" class="headerlink" title="API设计"></a>API设计</h2><h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><ul><li><p>tabs的子组件只能是tab组件</p></li><li><p>点击标签切换，动态渲染内容 – v-model:selected，动态组件</p></li><li><p>tab标签下横线移动，且长度根据标签宽度变化</p></li></ul><h3 id="用户怎么用该组件"><a href="#用户怎么用该组件" class="headerlink" title="用户怎么用该组件"></a>用户怎么用该组件</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">x-tabs</span> <span class="attr">v-model:selected</span>=<span class="string">&quot;selectTab&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">x-tab</span> <span class="attr">label</span>=<span class="string">&quot;星星&quot;</span> <span class="attr">name</span>=<span class="string">&quot;star&quot;</span>&gt;</span>一颗小星星<span class="tag">&lt;/<span class="name">x-tab</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">x-tab</span> <span class="attr">label</span>=<span class="string">&quot;羊&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sheep&quot;</span>&gt;</span>羊羊羊<span class="tag">&lt;/<span class="name">x-tab</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">x-tab</span> <span class="attr">label</span>=<span class="string">&quot;咩咩&quot;</span> <span class="attr">name</span>=<span class="string">&quot;mie&quot;</span>&gt;</span>咩咩是全世界最可爱的猫咪<span class="tag">&lt;/<span class="name">x-tab</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">x-tabs</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h2><p>从需求出发，将每个需求分别拆分成几个小问题一一解决</p><h3 id="如何确认子组件的类型"><a href="#如何确认子组件的类型" class="headerlink" title="如何确认子组件的类型"></a>如何确认子组件的类型</h3><p>要解决这个问题，首先得知道如何拿到子组件。由于<code>Tab</code>组件都是通过默认插槽的形式和<code>Tabs</code>组件一起使用，因此只要拿到<code>Tabs</code>组件的插槽就可以了。</p><p>在<code>Vue2</code>中，是使用<code>$slots</code>来获取插槽。而在<code>Vue3</code>中，通过文档可知，<code>setup</code>函数接受的第二个参数<code>context</code>中，暴露了<code>slots</code>这个属性，因此可通过<code>context.slots</code>后获取插槽，再通过组件的name判断组件类型</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> defaults = context.slots.default()</span><br><span class="line">defaults.forEach(<span class="function"><span class="params">pane</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (pane.type.name !== <span class="string">&#x27;xx-tab&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;Tabs 子标签必须是 Tab 组件&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="如何动态渲染嵌套的组件"><a href="#如何动态渲染嵌套的组件" class="headerlink" title="如何动态渲染嵌套的组件"></a>如何动态渲染嵌套的组件</h3><p>拿到了默认插槽(<code>tab</code>组件)后，首先想到的是通过循环渲染，然后比较子组件的<code>name</code>属性和<code>selected</code>的值过滤未选中的组件内容。</p><p>然而这样会遇到一个问题：将<code>v-for</code>和<code>v-if</code>一起使用了。官方文档并<a href="https://vue3js.cn/docs/zh/style-guide/#%E9%81%BF%E5%85%8D-v-if-%E5%92%8C-v-for-%E4%B8%80%E8%B5%B7%E4%BD%BF%E7%94%A8%E5%BF%85%E8%A6%81">不推荐这样做</a>。</p><p>因此，先通过计算属性拿到当前选中的组件，再通过动态组件渲染</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">&quot;currentTab&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;selected&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">setup</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> currentTab = computed(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> defaults.filter(<span class="function"><span class="params">pane</span> =&gt;</span> pane.props.name === props.selected)[<span class="number">0</span>]</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> &#123; currentTab &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注</strong>：如果<component/>渲染的内容改变，必须要将<code>key</code>标识也改变，否则将无法动态变化</p><h3 id="如何制作移动的导航条"><a href="#如何制作移动的导航条" class="headerlink" title="如何制作移动的导航条"></a>如何制作移动的导航条</h3><h4 id="确定标签导航的html结构"><a href="#确定标签导航的html结构" class="headerlink" title="确定标签导航的html结构"></a>确定标签导航的html结构</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;xx-tabs-nav&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 标签 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;xx-tabs-nav-item&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">v-for</span>=<span class="string">&quot;(pane,index) in tabPanes&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">:class</span>=<span class="string">&quot;&#123; selected: pane.name === selected &#125;&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">:key</span>=<span class="string">&quot;index&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;changeTab(pane.name)&quot;</span>&gt;</span></span><br><span class="line">    &#123;&#123; pane.label &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 导航条 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;xx-tabs-nav-indicator&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>根据需求，导航条的宽度应为当前选中标签的宽度，而导航条的位置应该是选中标签的left - 导航容器的left。那么问题就变成了：如何获取导航容器，导航条，选中标签这三个DOM元素呢？</p><h4 id="如何获取DOM元素"><a href="#如何获取DOM元素" class="headerlink" title="如何获取DOM元素"></a>如何获取DOM元素</h4><p>在<code>Vue2</code>中，可以使用<code>ref</code>和<code>$refs</code>来获取DOM元素，而在<code>Vue3</code>中有了新变化。如果在<code>v-for</code>中使用<code>ref</code>，需要将 <code>ref</code> 绑定到一个更灵活的函数上。</p><p>基于此，可以使用如下方式创建设置导航条属性的方法：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;xx-tabs-nav&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;navContainer&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;xx-tabs-nav-item&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">v-for</span>=<span class="string">&quot;(pane,index) in tabPanes&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">:class</span>=<span class="string">&quot;&#123; selected: pane.name === selected &#125;&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">:ref</span>=<span class="string">&quot;el =&gt; &#123; if (pane.name === selected) selectedItem = el &#125;&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">:key</span>=<span class="string">&quot;index&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;changeTab(pane.name)&quot;</span>&gt;</span></span><br><span class="line">    &#123;&#123; pane.label &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;xx-tabs-nav-indicator&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;indicator&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">setup</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> selectedItem = ref&lt;HTMLDivElement&gt;(<span class="literal">null</span>)</span><br><span class="line">    <span class="keyword">const</span> indicator = ref&lt;HTMLDivElement&gt;(<span class="literal">null</span>)</span><br><span class="line">    <span class="keyword">const</span> navContainer = ref&lt;HTMLDivElement&gt;(<span class="literal">null</span>)</span><br><span class="line">    <span class="keyword">const</span> getIndicatorAttr = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; width &#125; = selectedItem.value.getBoundingClientRect()</span><br><span class="line">      <span class="keyword">const</span> &#123; <span class="attr">left</span>: containerLeft &#125; = navContainer.value.getBoundingClientRect()</span><br><span class="line">      <span class="keyword">const</span> &#123; <span class="attr">left</span>: selectedItemLeft &#125; = selectedItem.value.getBoundingClientRect()</span><br><span class="line">      <span class="keyword">const</span> left = selectedItemLeft - containerLeft</span><br><span class="line">      indicator.value.style.left = left + <span class="string">&#x27;px&#x27;</span></span><br><span class="line">      indicator.value.style.width = width + <span class="string">&#x27;px&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> count = ref(<span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="如何实现宽度动态变化"><a href="#如何实现宽度动态变化" class="headerlink" title="如何实现宽度动态变化"></a>如何实现宽度动态变化</h4><p>很容易想到，当控制标签选中的变量<code>selected</code>发生变化后，生命周期函数<code>updated</code>即会执行，因此我们可以在组件挂载完成及更新完成时分别调用<code>getIndicatorAttr</code>方法实现宽度的动态变化。</p><p>在Vue 3中，可以使用直接导入的 <code>onX</code> 函数注册生命周期钩子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; onMounted, onUpdated &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">setup</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    onMounted(getIndicatorAttr)</span><br><span class="line">    onUpdated(getIndicatorAttr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="如何优化"><a href="#如何优化" class="headerlink" title="如何优化"></a>如何优化</h4><p>虽然需求已经实现，但问题又来了：这段代码还有没有优化空间呢？</p><p>于是想到，能不能通过<strong>监听<code>selected</code>的变化</strong>来实现<code>getIndicatorAttr</code>方法的调用呢？</p><p>查阅文档发现，Vue3还提供了一个新特性——<code>watchEffect</code>响应式追踪其依赖的变化。于是根据文档进行了尝试：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> count = ref(<span class="number">0</span>)</span><br><span class="line">onMounted(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;onMounted&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line">watchEffect(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(count.value))</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  count.value++</span><br><span class="line">&#125;, <span class="number">100</span>)</span><br><span class="line"><span class="comment">// -&gt; 0</span></span><br><span class="line"><span class="comment">// -&gt; onMounted</span></span><br><span class="line"><span class="comment">// -&gt; 1</span></span><br></pre></td></tr></table></figure><p>可以看到<code>watchEffect</code>会在<strong>onMounted执行前</strong>调用一次，并在所传入函数中的依赖发生变化时再次被调用。</p><p>但DOM元素在组件挂载完成后才能获取到，因此采取了这样的调用方式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">onMounted(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">  watchEffect(getIndicatorAttr())</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>然而，当我欣喜地期待着功能完美实现的时候，马上就打脸了：</p><p><img src="/images/vue3-tabs/tabs-bug.gif" alt="怎么不按剧本来呢"></p><h4 id="解决使用watchEffect的bug"><a href="#解决使用watchEffect的bug" class="headerlink" title="解决使用watchEffect的bug"></a>解决使用<code>watchEffect</code>的bug</h4><p>这是什么情况？马上打console看了看：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">onMounted(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;onMounted&#x27;</span>);</span><br><span class="line">  watchEffect(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(selectedItem.value);</span><br><span class="line">    getIndicatorAttr()</span><br><span class="line">  &#125;, &#123; <span class="attr">flush</span>:<span class="string">&#x27;pre&#x27;</span> &#125;) <span class="comment">// Vue3正式版默认flush为pre（即在渲染前执行watchEffect）</span></span><br><span class="line">&#125;)</span><br><span class="line">onUpdated(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;onUpdated&#x27;</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><img src="/images/vue3-tabs/tabs-console.gif"></p><p>重新梳理逻辑：</p><p><img src="/images/vue3-tabs/why.png"></p><p>原本是期望<code>selected</code>变化导致<code>selectedItem</code>变化，之后<code>watchEffect</code>执行，改变<code>indicator</code>位置。实际上却是：<code>watchEffect</code>在<code>selectedItem</code>变化前就执行了，发现其还未变化，因此传入的函数并未立即调用。</p><p>查阅文档发现确实如此：</p><blockquote><p>Vue 的响应性系统会缓存副作用函数，并异步地刷新它们，这样可以避免同一个“tick” 中多个状态改变导致的不必要的重复调用。在核心的具体实现中，组件的 <code>update</code> 函数也是一个被侦听的副作用。当一个用户定义的副作用函数进入队列时，默认情况下，会在所有的组件 <code>update</code> <strong>前</strong>执行</p></blockquote><p>文档也给出了相应的解决方案：</p><blockquote><p>如果需要在组件更新<strong>后</strong>重新运行侦听器副作用，可以传递带有 <code>flush</code> 选项的附加 <code>options</code> 对象 (默认为 <code>&#39;pre&#39;</code>)：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fire before component updates</span></span><br><span class="line">watchEffect(</span><br><span class="line">  () =&gt; &#123;</span><br><span class="line">    getIndicatorAttr()</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    flush: <span class="string">&#x27;post&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><img src="/images/vue3-tabs/success.gif" alt="问题解决~"></p><h2 id="Vue3笔记"><a href="#Vue3笔记" class="headerlink" title="Vue3笔记"></a>Vue3笔记</h2><h3 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h3><p>在 Vue 2 中，在 <code>v-for</code> 里使用的 <code>ref</code>  会用 ref 数组填充相应的 <code>$refs</code> property。当存在嵌套的 <code>v-for</code> 时，这种行为会变得不明确且效率低下。</p><p>在 Vue 3 中，这样的用法将不再在 <code>$ref</code> 中自动创建数组。如果要从单个绑定获取多个 ref，需将 <code>ref</code> 绑定到一个更灵活的函数上</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">&quot;item in list&quot;</span> <span class="attr">:ref</span>=<span class="string">&quot;setItemRef&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ref, onBeforeUpdate, onUpdated &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="function"><span class="title">setup</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> itemRefs = []</span><br><span class="line">    <span class="keyword">const</span> setItemRef = <span class="function"><span class="params">el</span> =&gt;</span> &#123;</span><br><span class="line">      itemRefs.push(el) <span class="comment">// 这里的el即为循环的DOM元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      itemRefs,</span><br><span class="line">      setItemRef</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h3><p><code>watch</code> 需要侦听特定的数据源，并在回调函数中执行副作用。默认情况下，它也是惰性的，即只有当被侦听的源发生变化时才执行回调</p><h4 id="侦听单个数据源"><a href="#侦听单个数据源" class="headerlink" title="侦听单个数据源"></a>侦听单个数据源</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 侦听一个 getter</span></span><br><span class="line"><span class="keyword">const</span> state = reactive(&#123; <span class="attr">count</span>: <span class="number">0</span> &#125;)</span><br><span class="line">watch(</span><br><span class="line">  () =&gt; state.count,</span><br><span class="line">  (count, prevCount) =&gt; &#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接侦听ref</span></span><br><span class="line"><span class="keyword">const</span> count = ref(<span class="number">0</span>)</span><br><span class="line">watch(count, <span class="function">(<span class="params">count, prevCount</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="侦听多个数据源"><a href="#侦听多个数据源" class="headerlink" title="侦听多个数据源"></a>侦听多个数据源</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">watch([fooRef, barRef], <span class="function">(<span class="params">[foo, bar], [prevFoo, prevBar]</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="watchEffect"><a href="#watchEffect" class="headerlink" title="watchEffect"></a>watchEffect</h3><p><code>watchEffect</code>方法接收的第一个参数：<code>effect</code>函数，用于定义副作用。他会立即执行传入的<code>effect</code>函数，同时响应式追踪其依赖，并在其依赖变更时重新运行该函数。</p><p>目的：为了根据响应式状态<em>自动应用</em>和<em>重新应用</em>副作用</p><blockquote><p>注：函数副作用是指当调用函数时，除了返回函数值之外，还对主调用函数产生附加的影响。副作用的函数不仅仅只是返回了一个值，而且还做了其他的事情</p></blockquote><p>如下代码中，副作用函数的作用是：当 <code>count</code> 被访问时，旋即在控制台打出日志。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> count = ref(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">watchEffect(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(count.value))</span><br><span class="line"><span class="comment">// -&gt; logs 0</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  count.value++</span><br><span class="line">  <span class="comment">// -&gt; logs 1</span></span><br><span class="line">&#125;, <span class="number">100</span>)</span><br></pre></td></tr></table></figure><h4 id="副作用刷新时机"><a href="#副作用刷新时机" class="headerlink" title="副作用刷新时机"></a>副作用刷新时机</h4><p>默认情况下，会在所有的组件 <code>update</code> <strong>前</strong>执行，如果需要在组件更新<strong>后</strong>重新运行侦听器副作用，可以传递带有 <code>flush</code> 选项的附加 <code>options</code> 对象 (默认为 <code>&#39;pre&#39;</code>)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fire before component updates</span></span><br><span class="line">watchEffect(</span><br><span class="line">  () =&gt; &#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    flush: <span class="string">&#x27;post&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h4 id="停止侦听"><a href="#停止侦听" class="headerlink" title="停止侦听"></a>停止侦听</h4><p><code>watchEffect</code>会返回一个用于停止这个监听的函数。</p><ul><li><p>这个函数可以在组件被卸载时隐式调用：当 <code>watchEffect</code> 在组件的 setup() 函数或生命周期钩子被调用时，侦听器会被链接到该组件的生命周期，并在组件卸载时自动停止</p></li><li><p>也可以在<code>setup</code>函数里被显式调用，以停止侦听</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> stop = watchEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// later</span></span><br><span class="line">stop()</span><br></pre></td></tr></table></figure></li></ul><h4 id="清除副作用"><a href="#清除副作用" class="headerlink" title="清除副作用"></a>清除副作用</h4><p>有时副作用函数会执行一些异步的副作用，比如当数据变化时发送一次异步请求，如果请求过程中数据发生多次变化，那么就得多次发送请求。这样不仅浪费资源，还会因无法判断异步请求的执行顺序增加不确定性。</p><p>为了解决这个问题，<code>watchEffect</code>副作用传入的函数接收一个<code>onInvalidate</code>函数作为入参，用来注册清理失效时的回调。</p><p><code>onInvalidate</code>只作用于异步函数，并且只有在如下两种情况下才会被调用：</p><ul><li>副作用即将重新执行时</li><li>侦听器被停止 (如果在 <code>setup()</code> 或生命周期钩子函数中使用了 <code>watchEffect</code>，则在组件卸载时)</li></ul><p>我的理解中对异步副作用的清除就相当于<strong>函数防抖</strong>，执行这一次的副作用时，清理上一次的异步副作用，使得之前挂起的异步操作无效。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">watchEffect(<span class="function"><span class="params">onInvalidate</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 异步api调用，返回一个操作对象</span></span><br><span class="line">  <span class="keyword">const</span> token = performAsyncOperation(id.value)</span><br><span class="line">  onInvalidate(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 取消异步api的调用。</span></span><br><span class="line">    token.cancel()</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>Vue3 之所以是通过传入一个函数去注册失效回调，而不是从回调返回它，是因为返回值对于异步错误处理很重要。</p><p>在执行数据请求时，副作用函数往往是一个异步函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> data = ref(<span class="literal">null</span>)</span><br><span class="line">watchEffect(<span class="keyword">async</span> onInvalidate =&gt; &#123;</span><br><span class="line">  onInvalidate(<span class="function">() =&gt;</span> &#123;...&#125;) <span class="comment">// 在Promise解析之前注册清除函数</span></span><br><span class="line">  data.value = <span class="keyword">await</span> fetchData(props.id)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="watchEffect和watch的区别"><a href="#watchEffect和watch的区别" class="headerlink" title="watchEffect和watch的区别"></a>watchEffect和watch的区别</h3><ul><li> <code>watchEffect</code> 不需要指定监听的属性，他会自动的收集依赖， 只要我们回调中引用到了 响应式的属性， 那么当这些属性变更的时候，这个回调都会执行，而 <code>watch</code> 只能监听指定的属性而做出变更(v3开始可以同时指定多个)。</li><li><code>watch</code> 访问侦听状态变化前后的值。</li><li><code>watch</code>可以懒执行回调：<code> watchEffect</code> 如果存在，组件初始化的时候就会执行一次用以收集依赖（与<code>computed</code>同理），而后收集到的依赖发生变化，这个回调才会再次执行，而 watch 不需要，因为他一开始就指定了依赖。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>生命周期钩子：onMounted / onUpdated </li><li><code>v-for</code>中绑定<code>ref</code></li><li>watchEffect的使用（注意其副作用的刷新时机）</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>官方文档：<a href="https://vue3js.cn/docs/zh/guide/reactivity-computed-watchers.html#watcheffect">https://vue3js.cn/docs/zh/guide/reactivity-computed-watchers.html#watcheffect</a></p><p><a href="https://www.jianshu.com/p/a8fdf52d0bcf">https://www.jianshu.com/p/a8fdf52d0bcf</a></p><p><a href="https://segmentfault.com/a/1190000023669309">https://segmentfault.com/a/1190000023669309</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;效果预览&quot;&gt;&lt;a href=&quot;#效果预览&quot; class=&quot;headerlink&quot; title=&quot;效果预览&quot;&gt;&lt;/a&gt;效果预览&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/images/vue3-tabs/tabs.gif&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https:/</summary>
      
    
    
    
    <category term="Vue" scheme="https://wuyangqin.github.io/categories/Vue/"/>
    
    <category term="Vue3" scheme="https://wuyangqin.github.io/categories/Vue/Vue3/"/>
    
    
    <category term="Vue" scheme="https://wuyangqin.github.io/tags/Vue/"/>
    
    <category term="造轮子" scheme="https://wuyangqin.github.io/tags/%E9%80%A0%E8%BD%AE%E5%AD%90/"/>
    
    <category term="Vue3" scheme="https://wuyangqin.github.io/tags/Vue3/"/>
    
  </entry>
  
  <entry>
    <title>Vue3造轮子（三）-Dialog组件</title>
    <link href="https://wuyangqin.github.io/2021/03/07/Vue3-3-dialog/"/>
    <id>https://wuyangqin.github.io/2021/03/07/Vue3-3-dialog/</id>
    <published>2021-03-07T15:31:05.000Z</published>
    <updated>2021-04-01T07:34:25.921Z</updated>
    
    <content type="html"><![CDATA[<h2 id="效果预览"><a href="#效果预览" class="headerlink" title="效果预览"></a>效果预览</h2><p><img src="/images/vue3-dialog/dialog.png"></p><p><a href="https://github.com/wuyangqin/xing-ui-v3">代码链接</a></p><p><a href="https://github.com/wuyangqin/xing-ui-v3/commits/aa06d1bddb7c8c922ad912cd66722a764e4eaccb">提交历史</a></p><h2 id="API设计"><a href="#API设计" class="headerlink" title="API设计"></a>API设计</h2><h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><ul><li>点击后弹出  – v-model:visible</li><li>有遮罩层 overlay，可控制点击遮罩层是否关闭 – closeOnClickOverlay</li><li>有 close 按钮</li><li>有标题，支持自定义标题 – title / slot=”title” </li><li>有内容 ，支持自定义内容 – content / slot=”content”</li><li>有 确认 / 取消 按钮，同时支持确认 / 取消事件 – onConfirm / onCancel</li><li>支持异步关闭</li><li>支持组件式调用，也支持函数式调用 – 动态挂载组件</li><li>可以指定挂载节点 – getContainer</li></ul><h3 id="用户怎么用该组件"><a href="#用户怎么用该组件" class="headerlink" title="用户怎么用该组件"></a>用户怎么用该组件</h3><p><strong>组件调用</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">x-dialog</span> </span></span><br><span class="line"><span class="tag">  <span class="attr">visible</span></span></span><br><span class="line"><span class="tag">  <span class="attr">title</span>=<span class="string">&quot;标题&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">content</span>=<span class="string">&quot;内容太&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">:onConfirm</span>=<span class="string">&quot;fn1&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">:onCancel</span>=<span class="string">&quot;fn2&quot;</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">x-ialog</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>函数式调用</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">setup() =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> showDialog = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      openDialog(&#123;</span><br><span class="line">        title: <span class="string">&#x27;标题&#x27;</span>,</span><br><span class="line">        content: <span class="string">&#x27;嗨 小星星&#x27;</span>,</span><br><span class="line">        onConfirm:<span class="function">() =&gt;</span> &#123;&#125;,</span><br><span class="line">        onCancel:<span class="function">() =&gt;</span> &#123;&#125;,</span><br><span class="line">        closeOnClickOverlay: <span class="literal">false</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123; showDialog &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Vue3笔记"><a href="#Vue3笔记" class="headerlink" title="Vue3笔记"></a>Vue3笔记</h2><h3 id="Teleport"><a href="#Teleport" class="headerlink" title="Teleport"></a>Teleport</h3><p><a href="https://vue3js.cn/docs/zh/guide/teleport.html">参考文档</a></p><p><code>Dialog</code>组件使用<code>fixed</code>定位，如果将其嵌套在某个组件内部，很可能会产生嵌套组件定位层级问题，处理起来会比较麻烦。因此，需要将模板渲染的位置与组件逻辑剥离开来。<code>vue3</code>提供了一个非常方便的新特性——<code>teloport</code>，可以理解为传送门，允许我们控制在 DOM 中哪个父节点下呈现 HTML。</p><h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><p><code>teleport</code>接受两个属性：</p><p><strong>to - string</strong></p><p>以<code>Dialog</code>组件为例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Teleport</span> <span class="attr">to</span>=<span class="string">&quot;#app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;xx-dialog-overlay&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;onClickOverlay&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;xx-dialog-wrapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;xx-dialog&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">header</span> <span class="attr">:class</span>=<span class="string">&quot;&#123; &#x27;title&#x27;: title || $slots.title &#125;&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>=<span class="string">&quot;$slots.title&quot;</span> <span class="attr">class</span>=<span class="string">&quot;title-slot&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;title&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-else</span>&gt;</span>&#123;&#123; title &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;xx-dialog-close&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;close&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">main</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">slot</span> <span class="attr">v-if</span>=<span class="string">&quot;$slots.content&quot;</span> <span class="attr">name</span>=<span class="string">&quot;content&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else</span>&gt;</span>&#123;&#123; content &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">footer</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">x-button</span> <span class="attr">size</span>=<span class="string">&quot;small&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;onCancel&quot;</span>&gt;</span>取消<span class="tag">&lt;/<span class="name">x-button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">x-button</span> <span class="attr">size</span>=<span class="string">&quot;small&quot;</span> <span class="attr">theme</span>=<span class="string">&quot;primary&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;onConfirm&quot;</span>&gt;</span>确定<span class="tag">&lt;/<span class="name">x-button</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Teleport</span>&gt;</span></span><br></pre></td></tr></table></figure><p>效果演示：</p><p><img src="/images/vue3-dialog/teleport.png"></p><p>可以看到通过<code>to</code>属性，指定该组件挂载到了<code>&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</code>中。</p><p><strong>注意</strong>：</p><ul><li><p><code>to</code>属性传入的值必须是有效的查询选择器或 HTMLElement</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 正确 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">teleport</span> <span class="attr">to</span>=<span class="string">&quot;#some-id&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">teleport</span> <span class="attr">to</span>=<span class="string">&quot;.some-class&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">teleport</span> <span class="attr">to</span>=<span class="string">&quot;[data-teleport]&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 错误 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">teleport</span> <span class="attr">to</span>=<span class="string">&quot;h1&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">teleport</span> <span class="attr">to</span>=<span class="string">&quot;some-string&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>默认挂载到第一个选择的元素</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span>container1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span>container2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">teleport</span> <span class="attr">to</span>=<span class="string">&quot;.container&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">teleport</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><p><img src="/images/vue3-dialog/teleport1.png" alt="挂载到第一个.container"></p><p><strong>disabled-boolean</strong></p><p>此可选属性可用于禁用 <code>teleport</code> 的功能，这意味着其插槽内容将不会移动到任何位置，而是在您在周围父组件中指定了 <code>teleport</code> 的位置渲染。</p><h4 id="与-Vue-components-一起使用"><a href="#与-Vue-components-一起使用" class="headerlink" title="与 Vue components 一起使用"></a>与 Vue components 一起使用</h4><p>如果 <code>teleport</code> 包含 Vue 组件，则它仍将是 <code>teleport</code> 父组件的逻辑子组件，仍接收父组件传来的属性。</p><h3 id="h-渲染函数"><a href="#h-渲染函数" class="headerlink" title="h() 渲染函数"></a>h() 渲染函数</h3><p>如果想要实现函数式调用<code>Dialog</code>组件，则需要通过渲染函数实现该组件的动态挂载。<code>Vue2</code>中的<a href="https://vuejs.bootcss.com/guide/render-function.html">渲染函数</a>为<code>createElement()</code>，而在<code>Vue3</code>中被称为<code>h()</code>，用于创建虚拟节点（更准确地命名为<code>createVNode()</code>，出于频繁使用和简洁的目的，改为了<code>h()</code>）。</p><p><code>h()</code>同样接受三个参数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @returns &#123;VNode&#125;</span></span><br><span class="line">h(</span><br><span class="line">  <span class="comment">// &#123;String | Object | Function | null&#125; tag</span></span><br><span class="line">  <span class="comment">// 一个 HTML 标签名、一个组件、一个异步组件，或者 null。</span></span><br><span class="line">  <span class="comment">// 使用 null 将会渲染一个注释。</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// 必需的。</span></span><br><span class="line">  <span class="string">&#x27;div&#x27;</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// &#123;Object&#125; props</span></span><br><span class="line">  <span class="comment">// 与 attribute、prop 和事件相对应的对象。</span></span><br><span class="line">  <span class="comment">// 我们会在模板中使用。</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// 可选的。</span></span><br><span class="line">  &#123;&#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// &#123;String | Array | Object&#125; children</span></span><br><span class="line">  <span class="comment">// 子 VNodes, 使用 `h()` 构建,</span></span><br><span class="line">  <span class="comment">// 或使用字符串获取 &quot;文本 Vnode&quot; 或者</span></span><br><span class="line">  <span class="comment">// 有 slot 的对象。</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// 可选的。</span></span><br><span class="line">  [</span><br><span class="line">    <span class="string">&#x27;Some text comes first.&#x27;</span>,</span><br><span class="line">    h(<span class="string">&#x27;h1&#x27;</span>, <span class="string">&#x27;A headline&#x27;</span>),</span><br><span class="line">    h(MyComponent, &#123;</span><br><span class="line">      someProp: <span class="string">&#x27;foobar&#x27;</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>实际应用如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> XDialog <span class="keyword">from</span> <span class="string">&#x27;../Dialog.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; createApp, h &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> openDialog = (&#123;</span><br><span class="line">    title = <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    content = <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    onConfirm = <span class="function">() =&gt;</span> &#123;&#125;,</span><br><span class="line">    onCancel = <span class="function">() =&gt;</span> &#123;&#125;,</span><br><span class="line">    closeOnClickOverlay = <span class="literal">true</span></span><br><span class="line">&#125;) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> div =  <span class="built_in">document</span>.createElement(<span class="string">&#x27;div&#x27;</span>)</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(div)</span><br><span class="line">    <span class="keyword">const</span> close = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        app.unmount()</span><br><span class="line">        div.remove()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> app = createApp(&#123;</span><br><span class="line">        <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> h(</span><br><span class="line">                XDialog,</span><br><span class="line">                &#123;</span><br><span class="line">                    visible: <span class="literal">true</span>,</span><br><span class="line">                    title,</span><br><span class="line">                    content,</span><br><span class="line">                    onConfirm,</span><br><span class="line">                    onCancel,</span><br><span class="line">                    closeOnClickOverlay,</span><br><span class="line">                    <span class="string">&#x27;onUpdate:visible&#x27;</span>:<span class="function">(<span class="params">newVisible</span>) =&gt;</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (!newVisible) &#123;</span><br><span class="line">                            close()</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    app.mount(div)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><code>teleport</code>指定挂载节点</li><li><code>h()</code>动态挂载组件</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;效果预览&quot;&gt;&lt;a href=&quot;#效果预览&quot; class=&quot;headerlink&quot; title=&quot;效果预览&quot;&gt;&lt;/a&gt;效果预览&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/images/vue3-dialog/dialog.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;htt</summary>
      
    
    
    
    <category term="Vue" scheme="https://wuyangqin.github.io/categories/Vue/"/>
    
    <category term="Vue3" scheme="https://wuyangqin.github.io/categories/Vue/Vue3/"/>
    
    
    <category term="Vue" scheme="https://wuyangqin.github.io/tags/Vue/"/>
    
    <category term="造轮子" scheme="https://wuyangqin.github.io/tags/%E9%80%A0%E8%BD%AE%E5%AD%90/"/>
    
    <category term="Vue3" scheme="https://wuyangqin.github.io/tags/Vue3/"/>
    
  </entry>
  
  <entry>
    <title>Vue3造轮子（二）-Button组件</title>
    <link href="https://wuyangqin.github.io/2021/02/27/Vue3-2-button/"/>
    <id>https://wuyangqin.github.io/2021/02/27/Vue3-2-button/</id>
    <published>2021-02-27T14:55:13.000Z</published>
    <updated>2021-04-01T02:50:50.258Z</updated>
    
    <content type="html"><![CDATA[<h2 id="效果预览"><a href="#效果预览" class="headerlink" title="效果预览"></a>效果预览</h2><p><img src="/images/vue3-button/button.png"></p><p><a href="https://github.com/wuyangqin/xing-ui-v3">代码链接</a></p><p><a href="https://github.com/wuyangqin/xing-ui-v3/commits/a3eebc79f3ca6affd7c5fc6b87d1e076fe4a82fe">提交历史</a></p><h2 id="API设计"><a href="#API设计" class="headerlink" title="API设计"></a>API设计</h2><h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><ul><li><p>支持button的基本事件 — click, focus,mouseover等 — 属性绑定</p></li><li><p>可以是基础按钮，可以是链接 — theme</p></li><li><p>可以有不同的等级 — level</p></li><li><p>可以改变大小 — size</p></li><li><p>可以禁用 — diabled</p></li><li><p>加载状态 — loading</p></li></ul><h3 id="用户怎么用该组件"><a href="#用户怎么用该组件" class="headerlink" title="用户怎么用该组件"></a>用户怎么用该组件</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">x-button</span> </span></span><br><span class="line"><span class="tag">  @<span class="attr">click</span>=<span class="string">?</span> </span></span><br><span class="line"><span class="tag">  @<span class="attr">focus</span>=<span class="string">?</span> </span></span><br><span class="line"><span class="tag">  @<span class="attr">mouseover</span>=<span class="string">?</span></span></span><br><span class="line"><span class="tag">  <span class="attr">theme</span>=<span class="string">&quot;default or primary or link&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">level</span>=<span class="string">&quot;nomal or info or warning or success or danger&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">size</span>=<span class="string">&quot;mini or small or normal or large&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">disabled</span></span></span><br><span class="line"><span class="tag">  <span class="attr">loading</span></span></span><br><span class="line"><span class="tag">&gt;</span><span class="tag">&lt;/<span class="name">x-button</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Vue3笔记"><a href="#Vue3笔记" class="headerlink" title="Vue3笔记"></a>Vue3笔记</h2><h3 id="属性绑定"><a href="#属性绑定" class="headerlink" title="属性绑定"></a>属性绑定</h3><h4 id="非Prop-属性继承"><a href="#非Prop-属性继承" class="headerlink" title="非Prop 属性继承"></a>非Prop 属性继承</h4><p><a href="https://vue3js.cn/docs/zh/guide/component-attrs.html">参考文档</a></p><ul><li>如果父组件传给子组件的属性，子组件中没有相应 <code>props</code>或 <code>emits</code>定义，则这些属性被称为<strong>非Prop属性</strong></li><li>当组件<strong>返回单个根节点</strong>时，<code>Vue3</code>会默认将所有非 prop属性绑定到子组件的根元素。</li></ul><p>基于此特性，父组件中绑定的事件可以直接传至子组件，因此可以初步实现button组件对事件的支持，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父组件</span></span><br><span class="line">&lt;template&gt; </span><br><span class="line">  &lt;x-button @click=<span class="string">&quot;clickButton&quot;</span></span><br><span class="line">      @focus=<span class="string">&quot;clickButton&quot;</span></span><br><span class="line">      @mouseover=<span class="string">&quot;clickButton&quot;</span>&gt;</span><br><span class="line">    点我</span><br><span class="line">  &lt;/x-button&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script lang=<span class="string">&quot;ts&quot;</span>&gt;</span><br><span class="line"><span class="keyword">import</span> XButton <span class="keyword">from</span> <span class="string">&quot;../lib/Button.vue&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  components: &#123; Button &#125;,</span><br><span class="line">  <span class="function"><span class="title">setup</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> clickButton = <span class="function">()=&gt;</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;clickButton&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- button 组件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;x-button-dv&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;x-button&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">slot</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="禁用属性继承"><a href="#禁用属性继承" class="headerlink" title="禁用属性继承"></a>禁用属性继承</h4><p>从上面的代码中，不难发现一个问题——button组件的事件其实应该绑定给<code>&lt;button/&gt;</code>元素而不是其根元素；而事件之外的其他属性需绑定给根元素。解决这些问题的思路如下：</p><ul><li>通过将 <code>inheritAttrs</code> 选项设置为 <code>false</code>，禁用非prop属性的继承</li><li>获取传来的属性，通过<code>v-bind</code>将事件绑定给<code>&lt;button/&gt;</code>元素</li><li>将其余属性绑定给根元素</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;x-button-dv&quot;</span> :size=<span class="string">&quot;size&quot;</span>&gt;</span><br><span class="line">    &lt;button <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;x-button&quot;</span> v-bind=<span class="string">&quot;rest&quot;</span>&gt;</span><br><span class="line">      &lt;slot&gt;&lt;/slot&gt;</span><br><span class="line">    &lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  name: <span class="string">&#x27;x-button&#x27;</span>,</span><br><span class="line">  inheritAttrs: <span class="literal">false</span>,</span><br><span class="line">  setup (props, context) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; size, ...rest &#125; = context.attrs <span class="comment">// 将事件绑定给button，其余属性绑定给外层div</span></span><br><span class="line">    <span class="keyword">return</span> &#123; size, rest &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="props-V-S-attrs"><a href="#props-V-S-attrs" class="headerlink" title="props  V.S.  attrs"></a>props  V.S.  attrs</h3><ul><li>props要先声明才能取值，attrs不用声明</li><li>当props声明了属性时，该属性不能在attrs里面取到</li><li>props不包含事件，attrs包含</li><li>当属性的数据类型为Booalen时，必须要给该属性绑定value，否则attrs中为空字符串</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 父组件</span><br><span class="line"><span class="tag">&lt;<span class="name">x-button</span> <span class="attr">size</span>=<span class="string">&quot;small&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">disabled</span></span></span><br><span class="line"><span class="tag">              <span class="attr">:multiple</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">              @<span class="attr">click</span>=<span class="string">&quot;clickButton&quot;</span></span></span><br><span class="line"><span class="tag">              @<span class="attr">mouseenter</span>=<span class="string">&quot;clickButton&quot;</span></span></span><br><span class="line"><span class="tag">              @<span class="attr">focus</span>=<span class="string">&quot;clickButton&quot;</span>&gt;</span></span><br><span class="line">      点我</span><br><span class="line"><span class="tag">&lt;/<span class="name">x-button</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 子组件</span></span><br><span class="line"> props: &#123;</span><br><span class="line">    size: &#123;</span><br><span class="line">      type: <span class="built_in">String</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  setup (props, context) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(    &#123;...props&#125;)</span><br><span class="line">    <span class="built_in">console</span>.log(    &#123;...context.attrs&#125;)</span><br><span class="line">    <span class="keyword">const</span> &#123; size, ...rest &#125; = context.attrs <span class="comment">// 将事件绑定给button，其余属性绑定给外层div</span></span><br><span class="line">    <span class="keyword">return</span> &#123; size, rest &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><img src="/images/vue3-button/props-vs-attrs.png" alt="输出结果"></p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h3 id="css影响最小原则"><a href="#css影响最小原则" class="headerlink" title="css影响最小原则"></a>css影响最小原则</h3><p><strong>CSS 绝对不能影响库使用者</strong></p><ul><li>尽量不使用 scoped<br>因为 data-v-xxx 中的 xxx 每次运行可能不同<br>必须输出稳定不变的 class 选择器，方便使用者覆盖</li><li>必须加前缀，不容易被使用者覆盖</li></ul><h3 id="css写loading动画"><a href="#css写loading动画" class="headerlink" title="css写loading动画"></a>css写loading动画</h3><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.xx-loadingIndicator</span>&#123;</span><br><span class="line"> <span class="variable">$main-theme-color</span>: <span class="number">#87dfd6</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">14px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">14px</span>;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">  <span class="attribute">margin-right</span>: <span class="number">4px</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">14px</span>;</span><br><span class="line">  <span class="attribute">border-color</span>: <span class="variable">$main-theme-color</span> <span class="variable">$main-theme-color</span> <span class="variable">$main-theme-color</span> transparent;</span><br><span class="line">  <span class="attribute">border-style</span>: solid;</span><br><span class="line">  <span class="attribute">border-width</span>: <span class="number">2px</span>;</span><br><span class="line">  <span class="attribute">animation</span>: xx-spin <span class="number">1s</span> infinite linear;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@keyframes</span> xx-spin &#123;</span><br><span class="line">  0% &#123; <span class="attribute">transform</span>: rotate(<span class="number">0deg</span>) &#125;</span><br><span class="line">  <span class="number">100%</span> &#123; transform: rotate(<span class="number">360deg</span>) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>Vue 属性继承<ul><li>默认属性传给根元素</li><li><code>inheritAttrs: false</code> 禁用属性继承</li><li><code>v-bind=&quot;$attrs&quot;</code>绑定属性， <code> context.attrs</code>获取属性</li></ul></li><li>props V.S. attrs</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;效果预览&quot;&gt;&lt;a href=&quot;#效果预览&quot; class=&quot;headerlink&quot; title=&quot;效果预览&quot;&gt;&lt;/a&gt;效果预览&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/images/vue3-button/button.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;htt</summary>
      
    
    
    
    <category term="Vue" scheme="https://wuyangqin.github.io/categories/Vue/"/>
    
    <category term="Vue3" scheme="https://wuyangqin.github.io/categories/Vue/Vue3/"/>
    
    
    <category term="Vue" scheme="https://wuyangqin.github.io/tags/Vue/"/>
    
    <category term="造轮子" scheme="https://wuyangqin.github.io/tags/%E9%80%A0%E8%BD%AE%E5%AD%90/"/>
    
    <category term="Vue3" scheme="https://wuyangqin.github.io/tags/Vue3/"/>
    
  </entry>
  
  <entry>
    <title>Vue3造轮子（一）-Switch组件</title>
    <link href="https://wuyangqin.github.io/2021/02/20/Vue3-1-switch/"/>
    <id>https://wuyangqin.github.io/2021/02/20/Vue3-1-switch/</id>
    <published>2021-02-20T15:25:49.000Z</published>
    <updated>2021-04-01T02:49:57.760Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><a href="%5Bwuyangqin.github.io/xing-ui/%5D(https://wuyangqin.github.io/xing-ui/)">UI造轮子Vue2版</a>官网初步部署上线了，决定暂时告一段落，先学习Vue3的造轮子课。这个阶段的学习总结以Vue3新特性为主，以及这其中踩到的坑，节奏依然是写轮子–&gt;看文档–&gt;写总结，然后会将Vue3的学习笔记做一个整体的总结。加油~(ง •_•)ง</p><h2 id="效果预览"><a href="#效果预览" class="headerlink" title="效果预览"></a>效果预览</h2><p><img src="/images/vue3-switch/switch.gif"></p><p><a href="https://github.com/wuyangqin/xing-ui-v3">代码链接</a></p><p><a href="https://github.com/wuyangqin/xing-ui-v3/commits/d221188bd2dc987cb169aeb66fe5a060b2283a02">提交历史</a></p><h2 id="API设计"><a href="#API设计" class="headerlink" title="API设计"></a>API设计</h2><h3 id="value"><a href="#value" class="headerlink" title="value"></a>value</h3><ul><li>组件内部，用<code>value</code>控制开关的开与关 — <code>computed</code>计算属性控制开关状态的样式</li><li><code>value</code>应该是由父组件传入 — 父组件用<code>ref</code>声明变量，子组件用<code>props</code>接受值（父子通信）</li><li>当父组件调用该子组件时，应该知道当前子组件的状态 — <code>v-model</code>实现父子双向绑定</li></ul><h3 id="disable-loading"><a href="#disable-loading" class="headerlink" title="disable loading"></a>disable loading</h3><ul><li>disable 禁用属性，loading，加载状态，处在该状态下开关无法进行操作</li><li>样式类型的属性，因此也是使用<code>computed</code>计算属性控制样式</li></ul><h2 id="Vue3笔记"><a href="#Vue3笔记" class="headerlink" title="Vue3笔记"></a>Vue3笔记</h2><h3 id="组件注册"><a href="#组件注册" class="headerlink" title="组件注册"></a>组件注册</h3><h4 id="Vue2-x"><a href="#Vue2-x" class="headerlink" title="Vue2.x"></a>Vue2.x</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  render: <span class="function"><span class="params">h</span> =&gt;</span> h(App)</span><br><span class="line">&#125;).$mount(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure><h4 id="Vue3-x"><a href="#Vue3-x" class="headerlink" title="Vue3.x"></a>Vue3.x</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line"><span class="keyword">const</span> app = createApp(App)</span><br><span class="line">app.mount(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="Composition-API（组合式API）"><a href="#Composition-API（组合式API）" class="headerlink" title="Composition API（组合式API）"></a>Composition API（组合式API）</h3><h4 id="为什么"><a href="#为什么" class="headerlink" title="为什么"></a>为什么</h4><p>总结一下就是：<strong>避免逻辑关注点过于碎片化，</strong>提高代码的可读性和可维护性。</p><p>在Vue2中，我们如果要实现一个需求，那么这些逻辑会被分散在data、methods、computed等各个<code>Options API</code>，而在Vue3中，我们可以将同一个需求的各个逻辑模块整合起来，放在<code>Composition API</code>。如果用颜色来区分各个逻辑块，那么下图可以直观地展示这种区别。</p><p><img src="/images/vue3-switch/composition.png"></p><h4 id="setup"><a href="#setup" class="headerlink" title="setup"></a>setup</h4><ul><li><p>一个接受<code>props</code>和<code>context</code>的函数，从<code>setup</code>返回的内容都将暴露给组件的其余部分</p><ul><li>props: 传入组件的属性:setup 中接收的<code>props</code>是响应式的， 当传入新的 props 时，会及时被更新。由于是响应式的， 所以<strong>不可以使用 ES6 解构</strong>，解构会消除它的响应式</li><li>context：暴露<code>attrs</code>、<code>slots</code>、<code>emit</code>这三个组件的property</li></ul></li><li><p>在<strong>创建组件之前</strong>，初始化 props 之后调用执行，因此<code>setup</code>中无法访问组件实例<code>this</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="title">beforeCreate</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;beforeCreate&#x27;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">created</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;created&#x27;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;mounted&#x27;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  setup (props, context) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;setup&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// setup</span></span><br><span class="line"><span class="comment">// beforeCreate</span></span><br><span class="line"><span class="comment">// created</span></span><br><span class="line"><span class="comment">// mounted</span></span><br></pre></td></tr></table></figure></li><li><p>我刚开始使用<code>setup</code>的时候，也产生过疑惑，这样不是将所有的代码都塞到<code>setup</code>里面，让它变得非常庞大臃肿吗？官方文档给出了解决方案——将各逻辑模块分别提取到独立的<a href="https://vue3js.cn/docs/zh/guide/composition-api-introduction.html#%E7%8B%AC%E7%AB%8B%E7%9A%84-computed-%E5%B1%9E%E6%80%A7"><strong>组合式函数</strong></a></p></li></ul><h4 id="带ref-的响应式变量-响应式引用"><a href="#带ref-的响应式变量-响应式引用" class="headerlink" title="带ref 的响应式变量 (响应式引用)"></a>带ref 的响应式变量 (响应式引用)</h4><ul><li><p>在setup中直接声明的变量是非响应式的，因此需引入<code>ref</code>函数</p></li><li><p><code>ref</code>接受参数并返回一个<a href="https://juejin.cn/post/6844904041357508615">包装对象</a>，包装对象具有 <code>value</code> property ，可使用该 property 访问或更改响应式变量的值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ref &#125; form <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> visible = ref(<span class="literal">false</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(visible) <span class="comment">// &#123; value: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(visible.value) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">visible.value = <span class="literal">true</span></span><br><span class="line"><span class="built_in">console</span>.log(visible.value) <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><a href="https://juejin.cn/post/6844904042242523144#heading-4">为什么要返回一个包装对象</a>?</p><p>提供一个让我们能够在函数之间以引用的方式传递任意类型值的容器。这个容器可以在封装了逻辑的组合函数中将状态以引用的方式传回给组件。组件负责展示（追踪依赖），组合函数负责管理状态（触发更新）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">setup</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> valueA = useLogicA() <span class="comment">// valueA 可能被 useLogicA() 内部的代码修改从而触发更新</span></span><br><span class="line">  <span class="keyword">const</span> valueB = useLogicB()</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    valueA,</span><br><span class="line">    valueB</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 作者：摸鱼架构师</span></span><br><span class="line"><span class="comment">// 链接：https://juejin.cn/post/6844904042242523144</span></span><br><span class="line"><span class="comment">// 来源：掘金</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="toRefs"><a href="#toRefs" class="headerlink" title="toRefs"></a>toRefs</h4><p>解构的同时保持<code>props</code>内部变量的响应式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; toRefs &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="function"><span class="title">setup</span>(<span class="params">props</span>)</span>&#123;</span><br><span class="line"><span class="keyword">const</span> &#123; user &#125; = toRefs(props)</span><br><span class="line">    consloe.log(user.value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="computed属性"><a href="#computed属性" class="headerlink" title="computed属性"></a>computed属性</h4><ul><li><p>使用从 Vue 导入的 <code>computed</code> 函数在 Vue 组件外部创建计算属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ref, computed &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> counter = ref(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">const</span> twiceTheCounter = computed(<span class="function">() =&gt;</span> counter.value * <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">counter.value++</span><br><span class="line"><span class="built_in">console</span>.log(counter.value) <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(twiceTheCounter.value) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure></li><li><p><code>computed</code>函数返回一个<em>只读</em>的<strong>响应式引用</strong>，由一个作为 <code>computed</code> 的第一个参数传递的 getter 类回调输出。为了访问新创建的计算变量的 <strong>value</strong>，我们需要像使用 <code>ref</code> 一样使用 <code>.value</code> property。</p></li></ul><h3 id="v-model"><a href="#v-model" class="headerlink" title="v-model"></a>v-model</h3><h4 id="使用-value和-input进行父子组件双向通信"><a href="#使用-value和-input进行父子组件双向通信" class="headerlink" title="使用:value和@input进行父子组件双向通信"></a>使用:value和@input进行父子组件双向通信</h4><p>其实<code>v-model</code>就是一个语法糖，我们可以先拆解出来它具体做了什么，以switch组件为例：</p><p><img src="/images/vue3-switch/props-emit.png"></p><p>父组件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;x-<span class="keyword">switch</span> :value=<span class="string">&quot;checked&quot;</span> @input=<span class="string">&quot;visible = $event&quot;</span>&gt;&lt;/x-<span class="keyword">switch</span>&gt;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"> setup () &#123;</span><br><span class="line">   <span class="keyword">const</span> checked = ref(<span class="literal">false</span>)</span><br><span class="line">   <span class="keyword">const</span> toggle = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">     checked.value = !checked.value</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> &#123; checked, toggle &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>子组件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line">setup (props, context) &#123;</span><br><span class="line">  <span class="keyword">const</span> toggle = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    context.emit(<span class="string">&#x27;input&#x27;</span>, !props.value)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123; toggle &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Vue2的v-model"><a href="#Vue2的v-model" class="headerlink" title="Vue2的v-model"></a>Vue2的v-model</h4><ul><li><p>Vue2.x中，在组件上使用 <code>v-model</code> 相当于绑定 <code>value</code> prop 和 <code>input</code> 事件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">x-switch</span> <span class="attr">v-model</span>=<span class="string">&quot;checked&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 简写: --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">x-switch</span> <span class="attr">:value</span>=<span class="string">&quot;checked&quot;</span> @<span class="attr">input</span>=<span class="string">&quot;checked = $event&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>如果想更改绑定的属性名，或绑定多个变量，可使用<code>.sync</code></p><p>子组件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.$emit(<span class="string">&#x27;update:value&#x27;</span>, newValue)</span><br></pre></td></tr></table></figure><p>父组件：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">x-switch</span> <span class="attr">:value.sync</span>=<span class="string">&quot;checked&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="Vue3的v-model"><a href="#Vue3的v-model" class="headerlink" title="Vue3的v-model"></a>Vue3的v-model</h4><ul><li>属性名任意，假设为 x</li><li>事件名必须为 <code>&#39;update:x&#39;</code></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">x-switch</span> <span class="attr">v-model:value</span>=<span class="string">&quot;checked&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 简写: --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">x-switch</span> <span class="attr">:value</span>=<span class="string">&quot;checked&quot;</span> @<span class="attr">update:value</span>=<span class="string">&quot;checked = $event&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>使用 ref 创建内部数据</li><li>使用 :value 和 @input 让父子组件进行交流(组件通信)</li><li>使用 v-model</li><li>Vue 2 和 Vue 3 的区别<ul><li>新 <code>v-model:prop</code> 代替以前的 <code>v-model</code> 和 <code>.sync</code></li><li>新增 context.emit，与 this.$emit 作用相同</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;%5Bwuyangqin.github.io/xing-ui/%5D(https://wuyangqin.github.i</summary>
      
    
    
    
    <category term="Vue" scheme="https://wuyangqin.github.io/categories/Vue/"/>
    
    <category term="Vue3" scheme="https://wuyangqin.github.io/categories/Vue/Vue3/"/>
    
    
    <category term="Vue" scheme="https://wuyangqin.github.io/tags/Vue/"/>
    
    <category term="造轮子" scheme="https://wuyangqin.github.io/tags/%E9%80%A0%E8%BD%AE%E5%AD%90/"/>
    
    <category term="Vue3" scheme="https://wuyangqin.github.io/tags/Vue3/"/>
    
  </entry>
  
  <entry>
    <title>iOS正则兼容，报错safari invalid regular expression</title>
    <link href="https://wuyangqin.github.io/2020/11/30/keng-ios-reg/"/>
    <id>https://wuyangqin.github.io/2020/11/30/keng-ios-reg/</id>
    <published>2020-11-30T13:09:49.000Z</published>
    <updated>2021-03-25T10:01:54.204Z</updated>
    
    <content type="html"><![CDATA[<h3 id="情景复现"><a href="#情景复现" class="headerlink" title="情景复现"></a>情景复现</h3><p>今天在项目中发现Android显示正常，而iOS显示一片空白，用safari打开后发现报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Invalid regular expression: invalid group specifier name</span><br></pre></td></tr></table></figure><p><img src="/images/ios-reg-error.png"></p><h3 id="排查原因及解决"><a href="#排查原因及解决" class="headerlink" title="排查原因及解决"></a>排查原因及解决</h3><p>谷歌后得到<a href="https://stackoverflow.com/questions/51568821/works-in-chrome-but-breaks-in-safari-invalid-regular-expression-invalid-group">stackoverflow</a>的答案：safari，firefox的正则表达式不支持<code>?&lt;=、?&lt;!、?!、?= </code>等表达，而我在项目中为了根据特定字符截取字符串中间部分，使用了如下正则：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> matchNameReg = <span class="regexp">/(?&lt;=name=&quot;).*?(?=&quot;)/</span></span><br></pre></td></tr></table></figure><p>因此只能采取替代方案，用<code>split</code>分割字符串。修改后报错解决。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;情景复现&quot;&gt;&lt;a href=&quot;#情景复现&quot; class=&quot;headerlink&quot; title=&quot;情景复现&quot;&gt;&lt;/a&gt;情景复现&lt;/h3&gt;&lt;p&gt;今天在项目中发现Android显示正常，而iOS显示一片空白，用safari打开后发现报错：&lt;/p&gt;
&lt;figure cla</summary>
      
    
    
    
    <category term="踩坑记" scheme="https://wuyangqin.github.io/categories/%E8%B8%A9%E5%9D%91%E8%AE%B0/"/>
    
    <category term="移动端" scheme="https://wuyangqin.github.io/categories/%E8%B8%A9%E5%9D%91%E8%AE%B0/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"/>
    
    
    <category term="踩坑记" scheme="https://wuyangqin.github.io/tags/%E8%B8%A9%E5%9D%91%E8%AE%B0/"/>
    
    <category term="移动端" scheme="https://wuyangqin.github.io/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"/>
    
    <category term="正则" scheme="https://wuyangqin.github.io/tags/%E6%AD%A3%E5%88%99/"/>
    
  </entry>
  
  <entry>
    <title>简单实现一个ajax</title>
    <link href="https://wuyangqin.github.io/2020/10/02/js-ajax/"/>
    <id>https://wuyangqin.github.io/2020/10/02/js-ajax/</id>
    <published>2020-10-02T05:50:01.000Z</published>
    <updated>2021-04-02T03:32:01.658Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ajax"><a href="#ajax" class="headerlink" title="ajax"></a>ajax</h2><h2 id="什么是Ajax"><a href="#什么是Ajax" class="headerlink" title="什么是Ajax"></a>什么是Ajax</h2><p>ajax:前后端分离后，都是后台通过接口返回数据，前端需要通过接口访问数据。那么这个通过接口访问后台数据的过程就叫ajax。</p><blockquote><p>简单来说就是用 JS 向服务端发起一个请求，并获取服务器返回的内容</p></blockquote><p>参考 ：<a href="https://zhuanlan.zhihu.com/p/22564745">https://zhuanlan.zhihu.com/p/22564745</a></p><h2 id="ajax-步骤"><a href="#ajax-步骤" class="headerlink" title="ajax 步骤"></a>ajax 步骤</h2><ol><li>买手机  –&gt;  创建ajax对象</li><li>拨号  –&gt;   链接url接口地址  设置传输数据方法：get和post<ul><li>get和post的区别：一般get获取数据，而post发送数据<ul><li>get发送数据最多为2kb，post理论上没有限制，但不同浏览器有不同限制</li><li>get发送数据在url地址 post在消息内发送数据</li><li>get有缓存，相对不安全；post没有，相对安全</li><li>get方式和post方式传递的数据在服务端获取也不相同</li></ul></li></ul></li><li>说 –&gt; 发送数据参数</li><li>听  –&gt;  接收返回的数据，并渲染到html页面</li></ol><h2 id="简单实现"><a href="#简单实现" class="headerlink" title="简单实现"></a>简单实现</h2><h3 id="get"><a href="#get" class="headerlink" title="get"></a>get</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> oAjax = <span class="keyword">new</span> XMLHttpRequest();<span class="comment">//创建ajax对象</span></span><br><span class="line">oAjax.open(<span class="string">&#x27;get&#x27;</span>,<span class="string">&#x27;arr.txt&#x27;</span>);<span class="comment">//链接地址  设置请求的方法</span></span><br><span class="line">oAjax.send();<span class="comment">//发送数据参数</span></span><br><span class="line">oAjax.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="comment">//页面注册事件更新</span></span><br><span class="line">    <span class="keyword">if</span>(oAjax.readyState == <span class="number">4</span>)&#123;<span class="comment">//ajax执行状态码</span></span><br><span class="line">        <span class="keyword">if</span>(oAjax.status == <span class="number">200</span>)&#123;<span class="comment">//http状态码 200 说明一切ok</span></span><br><span class="line">            <span class="keyword">var</span> data = oAjax.responseText;</span><br><span class="line">            <span class="comment">// 异步获取数据  后续操作  都得写在这  可以封装函数传参 将data传出去</span></span><br><span class="line">            <span class="comment">// console.log(typeof data);//string</span></span><br><span class="line">            <span class="comment">// 将具有js格式的字符串 转换为js代码或数据</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="post"><a href="#post" class="headerlink" title="post"></a>post</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> oAjax = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">oAjax.open(<span class="string">&#x27;post&#x27;</span>,<span class="string">&#x27;aaa.txt&#x27;</span>);</span><br><span class="line">oAjax.setRequestHeader(<span class="string">&#x27;Content-type&#x27;</span>,<span class="string">&#x27;application/x-www-form-urlencoded&#x27;</span>);<span class="comment">//设置请求头传输数据的类型编码方式</span></span><br><span class="line"></span><br><span class="line">oAjax.send();</span><br><span class="line"></span><br><span class="line">oAjax.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="comment">//页面注册事件更新</span></span><br><span class="line">    <span class="keyword">if</span>(oAjax.readyState == <span class="number">4</span>)&#123;<span class="comment">//ajax执行状态码</span></span><br><span class="line">        <span class="keyword">if</span>(oAjax.status == <span class="number">200</span>)&#123;<span class="comment">//http状态码 200 说明一切ok</span></span><br><span class="line">            <span class="built_in">console</span>.log(oAjax.responseText);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="readyState-ajax执行状态码"><a href="#readyState-ajax执行状态码" class="headerlink" title="readyState ajax执行状态码"></a>readyState ajax执行状态码</h3><ul><li>0：初始化   还没有调用open()方法</li><li>1： 载入  已调用send()方法，正在发送请求</li><li>2： 载入完成   send()方法完成，已收到全部相应内容</li><li>3： 解析  正在解析相应内容</li><li>4： 完成   响应内容解析完成，可以在客户端使用了</li></ul><h3 id="status-http状态码"><a href="#status-http状态码" class="headerlink" title="status http状态码"></a>status http状态码</h3><ul><li>100-199 Infromationale responses 接受请求</li><li>200-299 Successful responses 成功响应</li><li>300-399 Redirects 重定向</li><li>400-499 Client errors 客户端错误</li><li>500-599 Sever errors 服务端错误</li></ul><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">//封装一个ajax请求</span></span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">ajax</span>(<span class="params">options</span>)</span>&#123;</span><br><span class="line">     <span class="comment">//创建XMLHttpRequest对象</span></span><br><span class="line">     <span class="keyword">var</span> request = <span class="built_in">window</span>.XMLHttpRequest ? <span class="keyword">new</span> XMLHttpRequest : <span class="keyword">new</span> ActiveXObject()</span><br><span class="line"></span><br><span class="line">     <span class="comment">//初始化参数的内容</span></span><br><span class="line">     options = options ||&#123;&#125;</span><br><span class="line">     options.type = (options.type ||<span class="string">&#x27;GET&#x27;</span>).toUpperCase()</span><br><span class="line">     options.dataType = options.dataType || <span class="string">&#x27;json&#x27;</span></span><br><span class="line">     <span class="keyword">var</span> params = options.data</span><br><span class="line"></span><br><span class="line">     <span class="comment">//发送请求</span></span><br><span class="line">     <span class="keyword">if</span>(options.type == <span class="string">&#x27;GET&#x27;</span>)&#123;</span><br><span class="line">       request.open(<span class="string">&#x27;GET&#x27;</span>,options.url + <span class="string">&#x27;?&#x27;</span> + params,<span class="literal">true</span>)</span><br><span class="line">       request.send(<span class="literal">null</span>)</span><br><span class="line">     &#125;<span class="keyword">else</span> <span class="keyword">if</span>(options.type == <span class="string">&#x27;POST&#x27;</span>)&#123;</span><br><span class="line">       request.open(<span class="string">&#x27;POST&#x27;</span>,options.url,<span class="literal">true</span>)</span><br><span class="line">       request.setRequestHeader(<span class="string">&#x27;Content-Type&#x27;</span>, <span class="string">&quot;application/x-www-form-urlencoded&quot;</span>)<span class="comment">//规定输出为键值对的形式</span></span><br><span class="line">       request.send(params)</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//接收请求</span></span><br><span class="line">     request.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(request.readyState == <span class="number">4</span>)&#123;</span><br><span class="line">         <span class="keyword">var</span> status = request.status</span><br><span class="line">         <span class="keyword">if</span> (status &gt;= <span class="number">200</span> &amp;&amp; status &lt; <span class="number">300</span>)&#123;</span><br><span class="line">           options.success &amp;&amp; options.success(request.responseText,request.responseXML)</span><br><span class="line">         &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">           options.fail &amp;&amp;options.fail(status)</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;  </span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line">   ajax(&#123;</span><br><span class="line">     type: <span class="string">&#x27;post&#x27;</span>,</span><br><span class="line">     dataType: <span class="string">&#x27;json&#x27;</span>,</span><br><span class="line">     data: &#123;&#125;,</span><br><span class="line">     url: <span class="string">&#x27;xxx&#x27;</span>,</span><br><span class="line">     success: <span class="function"><span class="keyword">function</span>(<span class="params">text,xml</span>)</span>&#123;<span class="comment">//请求成功后的回调函数</span></span><br><span class="line">       <span class="built_in">console</span>.log(text)</span><br><span class="line">     &#125;,</span><br><span class="line">     fail: <span class="function"><span class="keyword">function</span>(<span class="params">status</span>)</span>&#123;<span class="comment">////请求失败后的回调函数</span></span><br><span class="line">       <span class="built_in">console</span>.log(status)</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;ajax&quot;&gt;&lt;a href=&quot;#ajax&quot; class=&quot;headerlink&quot; title=&quot;ajax&quot;&gt;&lt;/a&gt;ajax&lt;/h2&gt;&lt;h2 id=&quot;什么是Ajax&quot;&gt;&lt;a href=&quot;#什么是Ajax&quot; class=&quot;headerlink&quot; title=&quot;什么是</summary>
      
    
    
    
    <category term="JavaScript" scheme="https://wuyangqin.github.io/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="https://wuyangqin.github.io/tags/JavaScript/"/>
    
    <category term="ajax" scheme="https://wuyangqin.github.io/tags/ajax/"/>
    
  </entry>
  
  <entry>
    <title>函数节流与函数防抖</title>
    <link href="https://wuyangqin.github.io/2020/10/02/js-throttle-and-debounce/"/>
    <id>https://wuyangqin.github.io/2020/10/02/js-throttle-and-debounce/</id>
    <published>2020-10-02T03:21:34.000Z</published>
    <updated>2021-04-02T02:09:51.190Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是函数节流与函数防抖"><a href="#什么是函数节流与函数防抖" class="headerlink" title="什么是函数节流与函数防抖"></a>什么是函数节流与函数防抖</h2><ul><li>函数节流：指定时间间隔内只会执行一次任务</li><li>函数防抖:   事件被触发n秒后，任务才会执行，如果n秒内再次被触发，则重新计时。</li></ul><p>举个🌰，我的理解中，节流就相当于技能冷却时间，每隔一段时间才能释放一次技能，冷却过程中不管多想放技能都无济于事；而防抖相当于外卖员等一段时间没有新的外卖，就将手上的外卖一起派送一次，期间如果来了新的外卖，就抛弃这次送外卖的想法，重新等待。</p><p>那么为什么需要节流与防抖呢？</p><p>总得来说就是要<strong>限制函数调用的频次，优化性能</strong>。</p><p>js中的一些事件如浏览器的resize、scroll，鼠标的mousemove、mouseover，input输入框的keypress等事件在触发时，会不断地调用绑定在事件上的回调函数，极大地浪费资源，降低前端性能。为了优化体验，就需要对这类事件进行调用次数的限制。</p><h2 id="简单实现"><a href="#简单实现" class="headerlink" title="简单实现"></a>简单实现</h2><h3 id="函数节流-throttle"><a href="#函数节流-throttle" class="headerlink" title="函数节流(throttle)"></a>函数节流(throttle)</h3><p>根据节流的理念，可以先梳理其实现逻辑：</p><p><img src="/images/js/throttle.png"></p><p>代码实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn, delay</span>)</span>&#123;</span><br><span class="line">     <span class="keyword">let</span> canRun = <span class="literal">true</span></span><br><span class="line">     <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(canRun)&#123;</span><br><span class="line">             fn.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>)</span><br><span class="line">             canRun= <span class="literal">false</span></span><br><span class="line">             <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>canRun = <span class="literal">true</span>, delay)</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">const</span> throttled = throttle(<span class="function">()=&gt;</span><span class="built_in">console</span>.log(<span class="string">&#x27;hi&#x27;</span>))</span><br><span class="line"> throttled()</span><br><span class="line"> throttled()</span><br></pre></td></tr></table></figure><h3 id="函数防抖-debounce"><a href="#函数防抖-debounce" class="headerlink" title="函数防抖(debounce)"></a>函数防抖(debounce)</h3><p>防抖的逻辑梳理如下：</p><p><img src="/images/js/debounce.png"></p><p>代码实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, delay</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timerId = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> context = <span class="built_in">this</span>  <span class="comment">// 取debounce执行作用域的this</span></span><br><span class="line">        <span class="keyword">if</span>(timerId)&#123;<span class="built_in">window</span>.clearTimeout(timerId)&#125;</span><br><span class="line">        timerId = <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">            fn.apply(context, <span class="built_in">arguments</span>)</span><br><span class="line">            timerId = <span class="literal">null</span></span><br><span class="line">        &#125;,delay)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> debounced = debounce(<span class="function">()=&gt;</span><span class="built_in">console</span>.log(<span class="string">&#x27;hi&#x27;</span>))</span><br><span class="line">debounced()</span><br><span class="line">debounced()</span><br></pre></td></tr></table></figure><h2 id="区别与应用场景"><a href="#区别与应用场景" class="headerlink" title="区别与应用场景"></a>区别与应用场景</h2><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ul><li>防抖侧重于一段时间内连续触发的事件，只在最后执行一次</li><li>节流侧重于每隔固定的一段时间只执行一次</li></ul><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>节流 throttle</p><ul><li>高频点击提交，表单重复提交</li><li>监听滚动事件，加载更多或滚到底部监听</li></ul><p>防抖 debounce</p><ul><li>搜索联想，只需等用户最后一次输入完再发送请求</li><li>手机、邮箱等验证时，进行输入检测</li><li>resize事件，等用户最后一次调整完浏览器大小再执行</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>函数节流与函数防抖的原理其实非常简单，巧妙地使用 <code>setTimeout</code> 来存放待执行的函数，这样可以很方便的利用 <code>clearTimeout</code> 在合适的时机来清除待执行的函数。</p><p>使用函数节流与函数防抖的目的，就是为了限制函数调用的频次，节约计算机资源。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/6844903669389885453#heading-7">https://juejin.cn/post/6844903669389885453#heading-7</a></p><p><a href="https://juejin.cn/post/6844903926798516237">https://juejin.cn/post/6844903926798516237</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;什么是函数节流与函数防抖&quot;&gt;&lt;a href=&quot;#什么是函数节流与函数防抖&quot; class=&quot;headerlink&quot; title=&quot;什么是函数节流与函数防抖&quot;&gt;&lt;/a&gt;什么是函数节流与函数防抖&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;函数节流：指定时间间隔内只会执行一次任务&lt;/li</summary>
      
    
    
    
    <category term="JavaScript" scheme="https://wuyangqin.github.io/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="https://wuyangqin.github.io/tags/JavaScript/"/>
    
    <category term="性能优化" scheme="https://wuyangqin.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>this的值是什么？</title>
    <link href="https://wuyangqin.github.io/2020/09/30/js-this/"/>
    <id>https://wuyangqin.github.io/2020/09/30/js-this/</id>
    <published>2020-09-30T14:12:57.000Z</published>
    <updated>2021-04-02T03:41:32.342Z</updated>
    
    <content type="html"><![CDATA[<h2 id="this是什么"><a href="#this是什么" class="headerlink" title="this是什么"></a>this是什么</h2><p>当声明一个函数时，函数会有一个this（指针），声明时this不指向任何对象。当函数被调用时，哪个对象调用了该函数，则该函数的this就指向该对象</p><ul><li><p>当事件驱动时，结果匿名函数的this就指向触发事件的对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">oDiv.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="comment">//this --&gt; oDiv</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>普通命名函数被调用时，函数的this指向全局对象window</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">&#125;</span><br><span class="line">fn(); <span class="comment">//window</span></span><br><span class="line"><span class="comment">// window 是js的全局对象</span></span><br></pre></td></tr></table></figure></li><li><p>对象中定义的函数的this就指向该对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj=&#123;</span><br><span class="line">name: <span class="string">&#x27;John&#x27;</span>,</span><br><span class="line">age:<span class="number">19</span>;</span><br><span class="line">eat:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.eat();<span class="comment">// object</span></span><br><span class="line"><span class="keyword">var</span> fnn = obj.eat;</span><br><span class="line">  fnn();<span class="comment">// this--&gt; window</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="this的值是什么？"><a href="#this的值是什么？" class="headerlink" title="this的值是什么？"></a>this的值是什么？</h2><p><strong>谁调用函数，函数的this就指向谁</strong></p><p><strong>就近原则</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">fn()</span><br><span class="line"><span class="built_in">this</span> =&gt; <span class="built_in">window</span>/<span class="built_in">global</span></span><br><span class="line">obj.fn()</span><br><span class="line"><span class="built_in">this</span> =&gt; obj</span><br><span class="line">fn.call(xx)</span><br><span class="line"><span class="built_in">this</span> =&gt; xx</span><br><span class="line">fn.apply(xx)</span><br><span class="line"><span class="built_in">this</span> =&gt; xx</span><br><span class="line">fn.bind(xx)</span><br><span class="line"><span class="built_in">this</span> =&gt; xx</span><br><span class="line"><span class="keyword">new</span> Fn()</span><br><span class="line"><span class="built_in">this</span> =&gt; 新的对象</span><br><span class="line">fn = <span class="function">()=&gt;</span> &#123;&#125;</span><br><span class="line"><span class="built_in">this</span> =&gt; 外面的 <span class="built_in">this</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;this是什么&quot;&gt;&lt;a href=&quot;#this是什么&quot; class=&quot;headerlink&quot; title=&quot;this是什么&quot;&gt;&lt;/a&gt;this是什么&lt;/h2&gt;&lt;p&gt;当声明一个函数时，函数会有一个this（指针），声明时this不指向任何对象。当函数被调用时，哪个对</summary>
      
    
    
    
    <category term="JavaScript" scheme="https://wuyangqin.github.io/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="https://wuyangqin.github.io/tags/JavaScript/"/>
    
    <category term="this" scheme="https://wuyangqin.github.io/tags/this/"/>
    
  </entry>
  
  <entry>
    <title>如何进行深拷贝?</title>
    <link href="https://wuyangqin.github.io/2020/09/30/js-deep-clone/"/>
    <id>https://wuyangqin.github.io/2020/09/30/js-deep-clone/</id>
    <published>2020-09-30T06:52:12.000Z</published>
    <updated>2021-04-14T10:30:46.749Z</updated>
    
    <content type="html"><![CDATA[<h2 id="深拷贝与浅拷贝"><a href="#深拷贝与浅拷贝" class="headerlink" title="深拷贝与浅拷贝"></a>深拷贝与浅拷贝</h2><ul><li><p>浅拷贝：<strong>拷贝引用地址</strong> (只复制指向某个对象的指针，而不复制对象本身，新旧对象共享一块内存)</p><p>由于引用类型(object,array,function)的数据在栈里储存的只是堆地址，所以当对引用类型进行直接赋值时，实际上只复制了地址，复制出来的变量和原来的变量最终都指向同一个对象。当改变其中一个对象的属性值时，两个对象都会发生改变</p></li><li><p>深拷贝：<strong>拷贝实例</strong>  (复制并创建一个一摸一样的对象，不共享内存，修改新对象，旧对象保持不变。)</p></li><li><p>当修改赋值的对象 会影响原对象；修改原对象也会影响赋值的对象</p></li><li><p>如果希望深拷贝，想到了使用for in的方式，但for in有自身的问题</p><ul><li><p>当for in 的键对应的值又是引用类型时，又会变为赋址操作；</p><p>解决：用递归</p></li><li><p>原型上的共享属性也会遍历</p><p>解决：使用hasOwnProperty来进行判断</p></li></ul></li></ul><h2 id="如何进行深拷贝"><a href="#如何进行深拷贝" class="headerlink" title="如何进行深拷贝"></a>如何进行深拷贝</h2><ul><li>原生js</li><li>JSON.parse(JSON.stringify(obj))</li><li>jq的$.extend方法：将一个或多个对象合并到目标对象</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">            name:<span class="string">&#x27;joth&#x27;</span>,</span><br><span class="line">            age:<span class="number">18</span>,</span><br><span class="line">            sex:<span class="string">&#x27;male&#x27;</span>,</span><br><span class="line">            arr:[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],</span><br><span class="line">            body:&#123;</span><br><span class="line">                weight:<span class="string">&#x27;70kg&#x27;</span>,</span><br><span class="line">                height:<span class="string">&#x27;176cm&#x27;</span>,</span><br><span class="line">                eyes:&#123;</span><br><span class="line">                    left:<span class="string">&#x27;2.0&#x27;</span>,</span><br><span class="line">                    right:<span class="string">&#x27;1.6&#x27;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            fn:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">&#x27;haha&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法一：原生js的深拷贝(递归)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">obj</span>)</span>&#123; <span class="comment">//obj 原对象</span></span><br><span class="line">    <span class="keyword">var</span> objClone = <span class="built_in">Array</span>.isArray(obj) ? [] : &#123;&#125;;<span class="comment">//在函数内 要拷贝的对象</span></span><br><span class="line">    <span class="keyword">if</span>(obj &amp;&amp; <span class="keyword">typeof</span> obj == <span class="string">&#x27;object&#x27;</span>);&#123; <span class="comment">//如果有obj 且obj是一个对象</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> obj)&#123; <span class="comment">//进行 for in循环</span></span><br><span class="line">            <span class="keyword">if</span>(obj.hasOwnProperty(key))&#123;<span class="comment">//判断该属性是否是构造函数上的属性（即不是原型上的共享属性）</span></span><br><span class="line">                <span class="keyword">if</span>(obj[key] &amp;&amp; <span class="keyword">typeof</span> obj[key] == <span class="string">&#x27;object&#x27;</span>)&#123;<span class="comment">//判断该属性对应的值是否为对象</span></span><br><span class="line">                    objClone[key] = deepClone(obj[key]);<span class="comment">//如果该属性对应的值是一个对象则再次调用该函数</span></span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    objClone[key] = obj[key];  <span class="comment">// 如果该属性对应的值不是对象，则是基本类型，直接赋值</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> objClone：</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法二：(不能复制函数)</span></span><br><span class="line"><span class="keyword">var</span> obj1 = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(obj))</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法三：jq的深浅拷贝</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//浅拷贝</span></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">    money: <span class="number">1000</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">    number: <span class="number">101</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj3 = $.extend(&#123;&#125;,obj1,obj2)</span><br><span class="line"></span><br><span class="line"><span class="comment">//深拷贝</span></span><br><span class="line"><span class="keyword">var</span> obj3 = $.extend(<span class="literal">true</span>,&#123;&#125;,obj1)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;深拷贝与浅拷贝&quot;&gt;&lt;a href=&quot;#深拷贝与浅拷贝&quot; class=&quot;headerlink&quot; title=&quot;深拷贝与浅拷贝&quot;&gt;&lt;/a&gt;深拷贝与浅拷贝&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;浅拷贝：&lt;strong&gt;拷贝引用地址&lt;/strong&gt; (只复制指向某个对象的指针</summary>
      
    
    
    
    <category term="JavaScript" scheme="https://wuyangqin.github.io/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="https://wuyangqin.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>call、apply、bind 的用法分别是什么？</title>
    <link href="https://wuyangqin.github.io/2020/09/29/js-bind/"/>
    <id>https://wuyangqin.github.io/2020/09/29/js-bind/</id>
    <published>2020-09-29T02:11:23.000Z</published>
    <updated>2021-04-20T03:56:01.161Z</updated>
    
    <content type="html"><![CDATA[<h2 id="它们最主要的作用是-改变this的指向"><a href="#它们最主要的作用是-改变this的指向" class="headerlink" title="它们最主要的作用是 改变this的指向"></a>它们最主要的作用是 改变this的指向</h2><h2 id="call"><a href="#call" class="headerlink" title="call()"></a>call()</h2><p>call() 写法 ： <code>function.call(thisArg, arg1, arg2, ...)</code></p><p>call()调用一个函数，第一个参数是指定的this值，其他参数分别是提供的参数，用逗号隔开。</p><p><strong>call()用法</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">a,b,c</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  fn 的this指向的是obj， 参数是 1，2，3</span></span><br><span class="line">fn.call(obj,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个fn 的this指向obj， 但它参数是 [1,2,3]  、 undefined 、 undefined</span></span><br><span class="line">fn.call(obj,[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])Copy</span><br></pre></td></tr></table></figure><h2 id="apply"><a href="#apply" class="headerlink" title="apply()"></a>apply()</h2><p>apply()写法： <code>func.apply(thisArg, [argsArray])</code></p><p>apply 只接收俩个参数， 第一个参数和call一样。 第二个参数，必须是数组或者类数组。</p><p><strong>apply() 和call() 使用上是一致的，唯一区别在于 call() 方法接受若干个参数，而apply()方法接受一个包含多个参数的数组</strong></p><h2 id="bind"><a href="#bind" class="headerlink" title="bind()"></a>bind()</h2><p>bind() 不同于 call() 和 apply() ， 它返回一个新的函数，该函数将this设置未我们赋给它的值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mdn demo</span></span><br><span class="line"><span class="built_in">this</span>.x = <span class="number">9</span>; <span class="comment">// 在浏览器中this指向全局的 window 对象</span></span><br><span class="line"><span class="keyword">var</span> <span class="built_in">module</span> = &#123;</span><br><span class="line">  x: <span class="number">81</span>,</span><br><span class="line">  getX: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="built_in">this</span>.x; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.getX(); <span class="comment">// 81</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> retrieveX = <span class="built_in">module</span>.getX;</span><br><span class="line">retrieveX();</span><br><span class="line"><span class="comment">// 返回9 - 因为函数是在全局作用域中调用的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个新函数，把this绑定都module对象上</span></span><br><span class="line"><span class="keyword">var</span> bondGetX = retrieveX.bind(<span class="built_in">module</span>);</span><br><span class="line">bondGetX(); <span class="comment">// 81</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;它们最主要的作用是-改变this的指向&quot;&gt;&lt;a href=&quot;#它们最主要的作用是-改变this的指向&quot; class=&quot;headerlink&quot; title=&quot;它们最主要的作用是 改变this的指向&quot;&gt;&lt;/a&gt;它们最主要的作用是 改变this的指向&lt;/h2&gt;&lt;h2 i</summary>
      
    
    
    
    <category term="JavaScript" scheme="https://wuyangqin.github.io/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="https://wuyangqin.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>typeof 与 instanceof 区别</title>
    <link href="https://wuyangqin.github.io/2020/09/28/js-typeof-vs-instanceof/"/>
    <id>https://wuyangqin.github.io/2020/09/28/js-typeof-vs-instanceof/</id>
    <published>2020-09-28T14:23:23.000Z</published>
    <updated>2021-04-20T06:11:06.675Z</updated>
    
    <content type="html"><![CDATA[<h3 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h3><p>type ：“类型”</p><p>用于判断数据类型，返回值是6个不同的字符串：分别是：<strong>string</strong> <strong>number</strong> <strong>boolean</strong> <strong>undefined</strong> <strong>function</strong> <strong>object</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="string">&quot;1&quot;</span>);   <span class="comment">// string</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="number">1</span>);  <span class="comment">// number</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">false</span>);  <span class="comment">// boolean</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">undefined</span>);  <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;&#125;);   <span class="comment">// function</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> &#123;&#125;);   <span class="comment">// objectCopy</span></span><br></pre></td></tr></table></figure><p>除了以上之外，你会发现 typeof 判断 <strong>null</strong> <strong>Array</strong> <strong>构造函数的实例</strong>时， 会发现 永远得到是 <strong>object</strong></p><p>因此可知道 typeof 运算符 适用于检测除null的基础数据类型和函数类型</p><h3 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h3><p>instance ：“实例” 因此可以通过他的翻译知道这个含义了，就是 判断该对象是属于谁的实例。由于是实例，所以不得不牵扯到了对象的继承，即原型的知识了。而 <strong>instanceof</strong> 就是根据原型链进行搜寻的。</p><p>所以 instanceof 是检测对象之间的关联性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Number</span>() <span class="keyword">instanceof</span> <span class="built_in">Number</span>);  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">String</span>() <span class="keyword">instanceof</span> <span class="built_in">String</span>);  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] <span class="keyword">instanceof</span> <span class="built_in">Array</span>);  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(&#123; <span class="attr">name</span>: <span class="string">&quot;foo&quot;</span> &#125; <span class="keyword">instanceof</span> <span class="built_in">Object</span>);  <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;1&quot;</span> <span class="keyword">instanceof</span> <span class="built_in">String</span>);  <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span> <span class="keyword">instanceof</span> <span class="built_in">Number</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">false</span> <span class="keyword">instanceof</span> <span class="built_in">Boolean</span>);   <span class="comment">// falseCopy</span></span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><table><thead><tr><th></th><th>typeof</th><th>instanceof</th></tr></thead><tbody><tr><td>作用</td><td>检测数据类型</td><td>检测对象之间的关联性</td></tr><tr><td>返回值</td><td>小写的字母 字符串</td><td>布尔值</td></tr><tr><td>操作符</td><td>简单数据类型（没有null）、函数或者对象</td><td>左边必须是引用类型，右边必须是函数</td></tr><tr><td>操作数数量</td><td>1个</td><td>2个</td></tr></tbody></table><p><strong>typeof</strong> 中的 type 是类型的意思，所以他是用来检测数据类型的， 可以检测除了null以外的数据类型加上function，返回字符串</p><p><strong>instanceof</strong> 中的 instance是实例的意思， 所以他是用来检测这个实例是谁 <strong>new</strong> 出来的。返回布尔值</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;typeof&quot;&gt;&lt;a href=&quot;#typeof&quot; class=&quot;headerlink&quot; title=&quot;typeof&quot;&gt;&lt;/a&gt;typeof&lt;/h3&gt;&lt;p&gt;type ：“类型”&lt;/p&gt;
&lt;p&gt;用于判断数据类型，返回值是6个不同的字符串：分别是：&lt;strong&gt;st</summary>
      
    
    
    
    <category term="JavaScript" scheme="https://wuyangqin.github.io/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="https://wuyangqin.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Vue - vuex详解</title>
    <link href="https://wuyangqin.github.io/2020/09/28/Vue-vuex/"/>
    <id>https://wuyangqin.github.io/2020/09/28/Vue-vuex/</id>
    <published>2020-09-28T03:20:12.000Z</published>
    <updated>2021-04-20T10:14:22.563Z</updated>
    
    <content type="html"><![CDATA[<h2 id="vuex介绍"><a href="#vuex介绍" class="headerlink" title="vuex介绍"></a>vuex介绍</h2><ul><li>vuex是什么：Vuex 是一个专为 Vue.js 应用程序开发的<strong>状态管理模式</strong>。它采用<strong>集中式存储管理应用的所有组件的状态</strong>，并以相应的规则保证状态以一种可预测的方式发生变化。Vuex 也集成到 Vue 的官方调试工具 <a href="https://github.com/vuejs/vue-devtools">devtools extension</a>，提供了诸如零配置的 time-travel 调试、状态快照导入导出等高级调试功能。</li><li>vuex文档地址：<a href="https://vuex.vuejs.org/zh/">https://vuex.vuejs.org/zh/</a></li></ul><h2 id="vuex使用"><a href="#vuex使用" class="headerlink" title="vuex使用"></a>vuex使用</h2><ul><li><p>安装vuex</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i vuex --save</span><br></pre></td></tr></table></figure></li><li><p>创建仓库文件<code>src/store/index.js</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue  <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">&quot;vuex&quot;</span>;</span><br><span class="line"><span class="comment">// 安装插件</span></span><br><span class="line">Vue.use(Vuex);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例化一个仓库对象</span></span><br><span class="line"><span class="keyword">let</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">    state:&#123;&#125;,</span><br><span class="line">    getters:&#123;&#125;,</span><br><span class="line">    mutations:&#123;&#125;,</span><br><span class="line">    actions:&#123;&#125;,</span><br><span class="line">    modules:&#123;&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 暴露</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store;</span><br></pre></td></tr></table></figure></li><li><p>在main.js中引入</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&#x27;./App&#x27;</span></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">&#x27;./router&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入Store</span></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&quot;./store&quot;</span></span><br><span class="line"></span><br><span class="line">Vue.config.productionTip = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* eslint-disable no-new */</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  router,</span><br><span class="line">  store,    <span class="comment">// 挂载到vue实例上面去 </span></span><br><span class="line">  components: &#123; App &#125;,</span><br><span class="line">  template: <span class="string">&#x27;&lt;App/&gt;&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>一旦将vuex仓库实例挂载到vue实例上面，所有的组件的this里面都会出现一个$store,表示这个仓库实例对象</strong></p></li></ul><h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><h3 id="state"><a href="#state" class="headerlink" title="state"></a>state</h3><ul><li><p>作用： 类似于所有组件的data，所有组件都可以在这里读取数据，实现共享</p></li><li><p>使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">    state:&#123;</span><br><span class="line">    key:val,</span><br><span class="line">    key2:val2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>组件模板中</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; $store.state.key &#125;&#125;</span><br></pre></td></tr></table></figure></li><li><p>利用辅助函数 <strong><code>mapState</code></strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 组件中</span></span><br><span class="line"><span class="keyword">import</span> &#123; mapState &#125; <span class="keyword">from</span> <span class="string">&quot;vuex&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">   ...,</span><br><span class="line">  computed:&#123;</span><br><span class="line">     ...mapState([<span class="string">&#x27;key&#x27;</span>,<span class="string">&#x27;key2&#x27;</span>])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 组件模板中</span></span><br><span class="line">&#123;&#123;key&#125;&#125;</span><br><span class="line">&#123;&#123;key2&#125;&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="getters"><a href="#getters" class="headerlink" title="getters"></a>getters</h3><ul><li><p>作用：对仓库里面state数据进行一些加工处理。功能类似组件的computed。</p></li><li><p>实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">    state:&#123;</span><br><span class="line">    key:val,</span><br><span class="line">    key2:val2</span><br><span class="line">    &#125;,</span><br><span class="line">    getters:&#123;</span><br><span class="line">       <span class="function"><span class="title">newkey</span>(<span class="params">state</span>)</span>&#123;</span><br><span class="line">         <span class="keyword">return</span> state.key+<span class="string">&#x27;xxx处理&#x27;</span></span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>组件模板中</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;$store.getters.newkey&#125;&#125;</span><br></pre></td></tr></table></figure></li><li><p>利用辅助函数 <strong><code>mapGetters</code></strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 组件中</span></span><br><span class="line"><span class="keyword">import</span> &#123; mapGetters &#125; <span class="keyword">from</span> <span class="string">&quot;vuex&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">   ...,</span><br><span class="line">  computed:&#123;</span><br><span class="line">     ...mapGetters([<span class="string">&#x27;newkey&#x27;</span>])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 组件模板中</span></span><br><span class="line">&#123;&#123;newkey&#125;&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="mutations"><a href="#mutations" class="headerlink" title="mutations"></a>mutations</h3><ul><li><p>作用： <strong>vuex中唯一一个可以修改state里面数据的方法。切记不可以通过在组件中赋值state进行修改</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.$store.state.key = newval    <span class="comment">// 错误的写法</span></span><br></pre></td></tr></table></figure></li><li><p>使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">    state:&#123;</span><br><span class="line">    key:val,</span><br><span class="line">    key2:val2</span><br><span class="line">    &#125;,</span><br><span class="line">    mutations:&#123;</span><br><span class="line">       <span class="comment">// 形参1是state数据  形参2是调用该方法传入的实参 </span></span><br><span class="line">     <span class="function"><span class="title">FN</span>(<span class="params">state,data</span>)</span>&#123;</span><br><span class="line">          state.key = data</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>组件中实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$store.commit(&#39;FN&#39;,实参)</span><br></pre></td></tr></table></figure></li><li><p>利用辅助函数 <strong><code>mapMutations</code></strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 组件中</span></span><br><span class="line"><span class="keyword">import</span> &#123; mapMutations &#125; <span class="keyword">from</span> <span class="string">&quot;vuex&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">   ...,</span><br><span class="line">  methods:&#123;</span><br><span class="line">     ...mapMutations([<span class="string">&#x27;FN&#x27;</span>])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 组件模板中</span></span><br><span class="line">@click=<span class="string">&quot;FN(实参)&quot;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="actions"><a href="#actions" class="headerlink" title="actions"></a>actions</h3><ul><li><p>作用： 用来修改state。 但是确实间接修改， 他是通过触发mutations里面的方法去修改state 。 actions里面通常存放大量的异步逻辑请求代码。成功之后将数据给muations，然后mutations设置给state。</p></li><li><p>使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">    state:&#123;</span><br><span class="line">    key:val,</span><br><span class="line">    key2:val2</span><br><span class="line">    &#125;,</span><br><span class="line">    mutations:&#123;</span><br><span class="line">       <span class="comment">// 形参1是state数据  形参2是调用该方法传入的实参</span></span><br><span class="line">     <span class="function"><span class="title">FN</span>(<span class="params">state,data</span>)</span>&#123;</span><br><span class="line">          state.key = data</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  actions:&#123;</span><br><span class="line">      <span class="comment">// 形参1是store，就是这个仓库实例对象。 形参2是调用该方法传入的实参</span></span><br><span class="line">       <span class="function"><span class="title">fn</span>(<span class="params">store,info</span>)</span>&#123;</span><br><span class="line">          store.commit(<span class="string">&#x27;FN&#x27;</span>,info)</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>组件中实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$store.dispatch(&#39;fn&#39;,实参)</span><br></pre></td></tr></table></figure></li><li><p>利用辅助函数 <strong><code>mapActions</code></strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 组件中</span></span><br><span class="line"><span class="keyword">import</span> &#123; mapActions &#125; <span class="keyword">from</span> <span class="string">&quot;vuex&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">   ...,</span><br><span class="line">   methods:&#123;</span><br><span class="line">     ...mapActions([<span class="string">&#x27;fn&#x27;</span>])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 组件模板中</span></span><br><span class="line">@click=<span class="string">&quot;fn(实参)&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>注意：<strong>actions和mutations的区别</strong></p><ul><li>​    mutations 是唯一修改state的方法，且是同步修改</li><li>actions是间接修改state（通过触发mutations）, actions里面存放异步处理逻辑</li></ul></li></ul><h3 id="思路图"><a href="#思路图" class="headerlink" title="思路图"></a>思路图</h3><p><img src="/images/vue/gxt.png"></p><p><img src="https://vuex.vuejs.org/vuex.png"></p><h3 id="modules"><a href="#modules" class="headerlink" title="modules"></a>modules</h3><ul><li>针对于大型项目放在一个根模块，状态的维护困难。</li><li>对于不同项目不同模块的状态管理我们往往存放不同模块中，这样易于维护便于管理。</li></ul><h4 id="写法"><a href="#写法" class="headerlink" title="写法"></a>写法</h4><ul><li><p>结构</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// store/index.js文件</span></span><br><span class="line"><span class="keyword">let</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state:&#123; 根state &#125;,</span><br><span class="line">  getters:&#123; 根getters &#125;,</span><br><span class="line">  mutations:&#123; 根mutations &#125;,</span><br><span class="line">  actions:&#123;  根actions &#125;,</span><br><span class="line">  modules:&#123;</span><br><span class="line">     模块名<span class="number">1</span>:&#123;</span><br><span class="line">        namespaced:<span class="literal">false</span>/<span class="literal">true</span>,  <span class="comment">// 不写就是false</span></span><br><span class="line">        state:<span class="function">()=&gt;</span>(&#123;  模块state &#125;),   <span class="comment">// 注意模块的state是一个函数，且这个函数返回一个对象 </span></span><br><span class="line">        getters:&#123; 模块getters &#125;,</span><br><span class="line">        mutations:&#123; 模块mutations &#125;,</span><br><span class="line">        actions:&#123;  模块actions &#125;,</span><br><span class="line">        modules:&#123; 子模块 &#125;</span><br><span class="line">     &#125;,</span><br><span class="line">      模块名<span class="number">2</span>:&#123;</span><br><span class="line">          namespaced:<span class="literal">false</span>/<span class="literal">true</span>,  <span class="comment">// 不写就是false</span></span><br><span class="line">          state:<span class="function">()=&gt;</span>(&#123;  模块state &#125;),</span><br><span class="line">          getters:&#123; 模块getters &#125;,</span><br><span class="line">          mutations:&#123; 模块mutations &#125;,</span><br><span class="line">          actions:&#123;  模块actions &#125;,</span><br><span class="line">          modules:&#123; 子模块 &#125;</span><br><span class="line">       &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>真实结构：</p><ul><li><p>store目录</p><ul><li><p>index.js    仓库对象   【文件】</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入根配置</span></span><br><span class="line"><span class="keyword">import</span> state <span class="keyword">from</span>  <span class="string">&quot;./state&quot;</span></span><br><span class="line"><span class="keyword">import</span> getters <span class="keyword">from</span>  <span class="string">&quot;./getters&quot;</span></span><br><span class="line"><span class="keyword">import</span> mutations <span class="keyword">from</span>  <span class="string">&quot;./mutations&quot;</span></span><br><span class="line"><span class="keyword">import</span> actions <span class="keyword">from</span>  <span class="string">&quot;./actions&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入模块</span></span><br><span class="line"><span class="keyword">import</span> 模块<span class="number">1</span> <span class="keyword">from</span> <span class="string">&quot;./模块名1&quot;</span></span><br><span class="line"><span class="keyword">import</span> 模块<span class="number">2</span> <span class="keyword">from</span> <span class="string">&quot;./模块名2&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state:state,</span><br><span class="line">  getters:getters,</span><br><span class="line">  mutations:mutations,</span><br><span class="line">  actions:actions,</span><br><span class="line">  modules:&#123;</span><br><span class="line">     模块名<span class="number">1</span>:模块<span class="number">1</span>,</span><br><span class="line">      模块名<span class="number">2</span>:模块<span class="number">2</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>state.js   【文件】</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  根state</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">key:val</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>getters.js    【文件】</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根getters</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="function"><span class="title">newkey</span>(<span class="params">state</span>)</span>&#123;   <span class="comment">// state 根state    state.模块名1  模块1的所有state    state.模块名2    模块2的所有state </span></span><br><span class="line">       <span class="keyword">return</span> state.key</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="function"><span class="title">newkey</span>(<span class="params">state</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> state.模块名<span class="number">1.</span>key</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="title">newkey2</span>(<span class="params">state</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> state.模块名<span class="number">2.</span>key</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>mutations.js  【文件】</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根mutations</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line"><span class="comment">// 自己的state, 和调用该方法传入的实参</span></span><br><span class="line"><span class="function"><span class="title">FN</span>(<span class="params">state,data</span>)</span>&#123;</span><br><span class="line"> state.key = data;</span><br><span class="line">&#125;,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>actions.js  【文件】</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根actions</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line"><span class="comment">// store就是仓库实例对象 , 和调用该方法传入的实参</span></span><br><span class="line"><span class="function"><span class="title">fn</span>(<span class="params">store,info</span>)</span>&#123;</span><br><span class="line"> store.commit(<span class="string">&#x27;FN&#x27;</span>,info)</span><br><span class="line">&#125;,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>modules  【文件夹】</p><ul><li><p>模块名1.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">state:<span class="function">()=&gt;</span>(&#123;  模块state &#125;),</span><br><span class="line">      getters:&#123; 模块getters &#125;,</span><br><span class="line">      mutations:&#123; 模块mutations &#125;,</span><br><span class="line">      actions:&#123;  模块actions &#125;,</span><br><span class="line">      modules:&#123; 子模块 &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>模块名2.js</p></li></ul></li></ul></li></ul></li></ul><h4 id="获取数据"><a href="#获取数据" class="headerlink" title="获取数据"></a>获取数据</h4><ul><li><p>获取state</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;$store.state.key&#125;&#125;    <span class="comment">// 去根state里面的数据</span></span><br><span class="line">&#123;&#123;$store.state.模块名.key&#125;&#125;    <span class="comment">// 去某个模块state里面的数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// state结构</span></span><br><span class="line">state:&#123;</span><br><span class="line">  key:val,</span><br><span class="line">    key2:val2,</span><br><span class="line">    模块名:&#123;</span><br><span class="line">       key:val,</span><br><span class="line">       key2:val2</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>获取getters</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;$store.getters.key&#125;&#125;    <span class="comment">// 去根getters里面的数据</span></span><br><span class="line">&#123;&#123;$store.getters.key2&#125;&#125;    <span class="comment">// 去某个模块里面getter的数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有的getters 都会被挂载到根getters上面 </span></span><br></pre></td></tr></table></figure></li></ul><h4 id="namespaced-false"><a href="#namespaced-false" class="headerlink" title="namespaced:false"></a>namespaced:false</h4><ul><li><p>命名空间没有。没有命名空间的时候，所有的actions最后都是在根actions上面了。所有的mutations都到根mutations上面了。</p></li><li><p>组件中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">...mapState(&#123;</span><br><span class="line">key:<span class="string">&#x27;key&#x27;</span>,   <span class="comment">// 根的，取根state里面的key </span></span><br><span class="line">key2:<span class="function"><span class="params">state</span>=&gt;</span>state.模块名.key2     <span class="comment">// 取模块的， 去模块state里面的key2</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">...mapGetters([&#39;key1&#39;,&#39;key2&#39;])   &#x2F;&#x2F; key1是根getters里面，key2是模块getters里面key2</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$store.commit(<span class="string">&#x27;任意模块的mutations里面的方法&#x27;</span>，实参)</span><br><span class="line"></span><br><span class="line">...mapMutations([<span class="string">&#x27;FN1&#x27;</span>,<span class="string">&#x27;FN2&#x27;</span>])   <span class="comment">// FN1是根mutations里面的方法， FN2是模块里面的mutations里面的方法</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$store.dispatch(<span class="string">&#x27;任意模块的actions里面的方法&#x27;</span>，实参)</span><br><span class="line"></span><br><span class="line">...mapActions([<span class="string">&#x27;fn1&#x27;</span>,<span class="string">&#x27;fn2&#x27;</span>])   <span class="comment">// fn1是根actions里面的方法， fn2是模块里面的actions里面的方法</span></span><br></pre></td></tr></table></figure></li><li><p>模块中(actions里面方法里)调用其他模块的mutations或actions里面的方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A模块</span></span><br><span class="line">&#123;</span><br><span class="line">  ...,</span><br><span class="line">  mutations:&#123;</span><br><span class="line"><span class="function"><span class="title">FN</span>(<span class="params">state,data</span>)</span>&#123;</span><br><span class="line">        state.key = data</span><br><span class="line">      &#125;</span><br><span class="line">&#125;,</span><br><span class="line">  actions:&#123;</span><br><span class="line">     <span class="function"><span class="title">fn</span>(<span class="params">store,info</span>)</span>&#123;</span><br><span class="line">        store.commit(<span class="string">&#x27;FN&#x27;</span>,info)  <span class="comment">// 触发自己的mutations里面的方法</span></span><br><span class="line">          store.dispatch(<span class="string">&#x27;fn2&#x27;</span>)    <span class="comment">// 触发自己的actions里面的其他方法</span></span><br><span class="line">       </span><br><span class="line">       <span class="comment">// A模块触发B模块里面的方法    缺点： 无法区分调用的方法是哪个模块的 对于大型项目而言，非常的混乱 </span></span><br><span class="line">          store.commit(<span class="string">&#x27;FN3&#x27;</span>,info)</span><br><span class="line">          store.dispatch(<span class="string">&#x27;fn3&#x27;</span>,info)</span><br><span class="line">       </span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="title">fn2</span>(<span class="params">store,info</span>)</span>&#123;...&#125;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//B模块</span></span><br><span class="line">&#123;</span><br><span class="line">  ...,</span><br><span class="line">  mutations:&#123;</span><br><span class="line"><span class="function"><span class="title">FN3</span>(<span class="params">state,data</span>)</span>&#123;</span><br><span class="line">        state.key = data</span><br><span class="line">      &#125;</span><br><span class="line">&#125;,</span><br><span class="line">  actions:&#123;</span><br><span class="line">     <span class="function"><span class="title">fn3</span>(<span class="params">store,info</span>)</span>&#123;</span><br><span class="line">        store.commit(<span class="string">&#x27;FN3&#x27;</span>,info)  <span class="comment">// 触发自己的mutations里面的方法FN3</span></span><br><span class="line">          store.dispatch(<span class="string">&#x27;fn4&#x27;</span>)    <span class="comment">// 触发自己的actions里面的其他方法fn4</span></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="title">fn4</span>(<span class="params">store,info</span>)</span>&#123;...&#125;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="namespaced-true"><a href="#namespaced-true" class="headerlink" title="namespaced:true"></a>namespaced:true</h4><ul><li><p>命名空间有</p></li><li><p>组件中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">...mapState(&#123;</span><br><span class="line">key:<span class="string">&#x27;key&#x27;</span>,   <span class="comment">// 根的，取根state里面的key </span></span><br><span class="line">key2:<span class="function"><span class="params">state</span>=&gt;</span>state.模块名.key2     <span class="comment">// 取模块的， 去模块state里面的key2</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">...mapGetters(&#123;</span><br><span class="line">key1:<span class="string">&#x27;key1&#x27;</span>  <span class="comment">// key1是根getters里面</span></span><br><span class="line">key2:<span class="string">&#x27;模块名/key2&#x27;</span>   <span class="comment">// key2是模块getters里面key2</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$store.commit(<span class="string">&#x27;模块名/该模块mutations里面的方法&#x27;</span>，实参)</span><br><span class="line"></span><br><span class="line">...mapMutations(&#123;</span><br><span class="line">  FN1:<span class="string">&#x27;FN1&#x27;</span>,   <span class="comment">// FN1是根mutations里面的方法</span></span><br><span class="line">  FN2:<span class="string">&#x27;模块名/FN2&#x27;</span>  <span class="comment">//  FN2是模块里面的mutations里面的方法</span></span><br><span class="line">&#125;) </span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$store.dispatch(<span class="string">&#x27;模块名/该模块actions里面的方法&#x27;</span>，实参)</span><br><span class="line"></span><br><span class="line">...mapActions(&#123;</span><br><span class="line">  fn1:<span class="string">&#x27;fn1&#x27;</span>,   <span class="comment">// fn1是根actions里面的方法</span></span><br><span class="line">  fn2:<span class="string">&#x27;模块名/fn2&#x27;</span>  <span class="comment">//  fn2是模块里面的actions里面的方法</span></span><br><span class="line">&#125;) </span><br></pre></td></tr></table></figure></li><li><p>模块中(actions里面方法里)调用其他模块的mutations或actions里面的方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A模块</span></span><br><span class="line">&#123;</span><br><span class="line">  ...,</span><br><span class="line">  mutations:&#123;</span><br><span class="line"><span class="function"><span class="title">FN</span>(<span class="params">state,data</span>)</span>&#123;</span><br><span class="line">        state.key = data</span><br><span class="line">      &#125;</span><br><span class="line">&#125;,</span><br><span class="line">  actions:&#123;</span><br><span class="line">     <span class="function"><span class="title">fn</span>(<span class="params">store,info</span>)</span>&#123;</span><br><span class="line">        store.commit(<span class="string">&#x27;FN&#x27;</span>,info)  <span class="comment">// 触发自己的mutations里面的方法</span></span><br><span class="line">          store.dispatch(<span class="string">&#x27;fn2&#x27;</span>)    <span class="comment">// 触发自己的actions里面的其他方法</span></span><br><span class="line">       </span><br><span class="line">       <span class="comment">// A模块触发B模块里面的方法    </span></span><br><span class="line">          store.commit(<span class="string">&#x27;模块名/FN3&#x27;</span>,info,&#123;<span class="attr">root</span>:<span class="literal">true</span>&#125;)</span><br><span class="line">          store.dispatch(<span class="string">&#x27;模块名/fn3&#x27;</span>,info,&#123;<span class="attr">root</span>:<span class="literal">true</span>&#125;) </span><br><span class="line">       </span><br><span class="line">       <span class="comment">// store相关信息</span></span><br><span class="line">        <span class="comment">// store.state  当前模块的state</span></span><br><span class="line">            <span class="comment">// store.getters  当前模块的getters</span></span><br><span class="line">            <span class="comment">// store.commit   调用任意模块的muations,注意模块名，root:true</span></span><br><span class="line">            <span class="comment">// store.dispatch   调用任意模块的actions,注意模块名，root:true</span></span><br><span class="line">          <span class="comment">// store.rootState  根state</span></span><br><span class="line">            <span class="comment">// store.rootGetters  根getters</span></span><br><span class="line">       </span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="title">fn2</span>(<span class="params">store,info</span>)</span>&#123;...&#125;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//B模块</span></span><br><span class="line">&#123;</span><br><span class="line">  ...,</span><br><span class="line">  mutations:&#123;</span><br><span class="line"><span class="function"><span class="title">FN3</span>(<span class="params">state,data</span>)</span>&#123;</span><br><span class="line">        state.key = data</span><br><span class="line">      &#125;</span><br><span class="line">&#125;,</span><br><span class="line">  actions:&#123;</span><br><span class="line">     <span class="function"><span class="title">fn3</span>(<span class="params">store,info</span>)</span>&#123;</span><br><span class="line">        store.commit(<span class="string">&#x27;FN3&#x27;</span>,info)  <span class="comment">// 触发自己的mutations里面的方法FN3</span></span><br><span class="line">          store.dispatch(<span class="string">&#x27;fn4&#x27;</span>)    <span class="comment">// 触发自己的actions里面的其他方法fn4</span></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="title">fn4</span>(<span class="params">store,info</span>)</span>&#123;...&#125;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;vuex介绍&quot;&gt;&lt;a href=&quot;#vuex介绍&quot; class=&quot;headerlink&quot; title=&quot;vuex介绍&quot;&gt;&lt;/a&gt;vuex介绍&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;vuex是什么：Vuex 是一个专为 Vue.js 应用程序开发的&lt;strong&gt;状态管理模式&lt;</summary>
      
    
    
    
    <category term="Vue" scheme="https://wuyangqin.github.io/categories/Vue/"/>
    
    <category term="Vue2" scheme="https://wuyangqin.github.io/categories/Vue/Vue2/"/>
    
    
    <category term="Vue" scheme="https://wuyangqin.github.io/tags/Vue/"/>
    
    <category term="Vue2" scheme="https://wuyangqin.github.io/tags/Vue2/"/>
    
  </entry>
  
  <entry>
    <title>Vue - 路由基础</title>
    <link href="https://wuyangqin.github.io/2020/09/27/Vue-router/"/>
    <id>https://wuyangqin.github.io/2020/09/27/Vue-router/</id>
    <published>2020-09-27T10:45:12.000Z</published>
    <updated>2021-03-29T03:14:36.882Z</updated>
    
    <content type="html"><![CDATA[<h2 id="路由基础"><a href="#路由基础" class="headerlink" title="路由基础"></a>路由基础</h2><h3 id="路由含义"><a href="#路由含义" class="headerlink" title="路由含义"></a>路由含义</h3><ul><li><p>服务器端的路由： <strong>一个地址指向一个资源页面</strong></p></li><li><p>前端的路由：框架式开发都是单页面（SPA）应用</p><ul><li>single page application   单页面应用<ul><li>优点：体验感好，组件化开发</li><li>缺点：不利于seo，首页加载慢</li></ul></li><li>multiple page appliction 多页面应用<ul><li>优点：seo友好</li><li>缺点：复用不好</li></ul></li></ul></li></ul><h4 id="简单实现路由："><a href="#简单实现路由：" class="headerlink" title="简单实现路由："></a>简单实现路由：</h4><ul><li><p>hash</p><p>hash（#）是URL 的锚点，代表的是网页中的一个位置，单单改变#后的部分，浏览器只会滚动到相应位置，不会重新加载网页，也就是说hash 出现在 URL 中，但不会被包含在 http 请求中，对后端完全没有影响，因此改变 hash 不会重新加载页面；同时每一次改变#后的部分，都会在浏览器的访问历史中增加一个记录，使用”后退”按钮，就可以回到上一个位置；</p></li><li><p>Hash模式：通过锚点值的改变，根据不同的值，渲染指定DOM位置的不同数据。</p></li><li><p>监听<code>hashchange</code>变化，修改动态组件的内容</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=<span class="string">&quot;app&quot;</span>&gt;</span><br><span class="line">      &lt;component :newURL=<span class="string">&quot;cur&quot;</span>&gt;&lt;/component&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">import</span>  index <span class="keyword">from</span> <span class="string">&quot;@/pages/index&quot;</span></span><br><span class="line"><span class="keyword">import</span>  car <span class="keyword">from</span> <span class="string">&quot;@/pages/car&quot;</span></span><br><span class="line"><span class="keyword">import</span>  user <span class="keyword">from</span> <span class="string">&quot;@/pages/user&quot;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  name: <span class="string">&#x27;App&#x27;</span>,</span><br><span class="line">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">       cur:<span class="string">&quot;index&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    index,user,car</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> _this = <span class="built_in">this</span>;</span><br><span class="line">      <span class="built_in">window</span>.addEventListener(<span class="string">&quot;hashchange&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(e)</span><br><span class="line">        <span class="keyword">let</span> url = e.newURL.split(<span class="string">&quot;#&quot;</span>)[<span class="number">1</span>].slice(<span class="number">1</span>)</span><br><span class="line">          <span class="keyword">if</span>(url)&#123;</span><br><span class="line">            _this.cur = url;</span><br><span class="line">          &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            _this.cur = <span class="string">&#x27;index&#x27;</span></span><br><span class="line">          &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">*&#123;</span><br><span class="line">  margin: <span class="number">0</span>;</span><br><span class="line">  padding: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></li></ul><h3 id="vue-router"><a href="#vue-router" class="headerlink" title="vue-router"></a>vue-router</h3><ul><li><p>WebApp的链接路径管理系统， 是vue生态圈里非常重要的内容</p></li><li><p>文档地址：<a href="https://router.vuejs.org/zh/">https://router.vuejs.org/zh/</a></p></li><li><p>使用：</p><ul><li><p>安装vue-router</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i vue-router --save</span><br></pre></td></tr></table></figure></li><li><p>在src下面创建router文件夹，下面创建index.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> VueRouter <span class="keyword">from</span> <span class="string">&quot;vue-router&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Vue.use(插件名)   安装插件</span></span><br><span class="line">Vue.use(VueRouter);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入页面组件</span></span><br><span class="line"><span class="keyword">import</span> 组件A <span class="keyword">from</span> <span class="string">&quot;@/pages/组件A&quot;</span></span><br><span class="line"><span class="keyword">import</span> 组件B <span class="keyword">from</span> <span class="string">&quot;@/pages/组件B&quot;</span></span><br><span class="line"><span class="keyword">import</span> 组件C <span class="keyword">from</span> <span class="string">&quot;@/pages/组件C&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例化一个路由对象</span></span><br><span class="line"><span class="keyword">let</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">   routes:[</span><br><span class="line">     &#123; <span class="attr">path</span>:<span class="string">&quot;/a&quot;</span>,<span class="attr">component</span>:组件A &#125;,</span><br><span class="line">     &#123; <span class="attr">path</span>:<span class="string">&quot;/b&quot;</span>,<span class="attr">component</span>:组件B &#125;,</span><br><span class="line">     &#123; <span class="attr">path</span>:<span class="string">&quot;/c&quot;</span>,<span class="attr">component</span>:组件C &#125;,</span><br><span class="line">   ]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>在App.vue 模板里面写入<code>router-view</code>标签，路由地址切换之后对应的组件内容展示在这里</p></li><li><p>使用<code>router-link</code>实现a标签。 to的值就是 路由映射配置里面的path内容</p></li></ul></li><li><p><strong>在脚手架初始项目的时候就选择安装vue-router,自动设计好所有配置</strong></p></li></ul><h3 id="404配置"><a href="#404配置" class="headerlink" title="404配置"></a>404配置</h3><ul><li><p>默认情况下，访问一个没有被定义的路由地址， 页面是不会渲染任何内容。我们可以给他指定到404页面</p></li><li><p>实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">routes:[</span><br><span class="line">   &#123; <span class="attr">path</span>:<span class="string">&quot;*&quot;</span>,<span class="attr">component</span>:<span class="number">404</span>组件 &#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h3 id="激活class"><a href="#激活class" class="headerlink" title="激活class"></a>激活class</h3><ul><li><p>需要设置激活的class， 当前的路由地址和a标签一致的时候，a标签就应该激活</p></li><li><p>实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  linkActiveClass:<span class="string">&#x27;自定义class名&#x27;</span>,   <span class="comment">// 非严格模式  但是可以在某个router-link上面加上exact属性，变成严格模式</span></span><br><span class="line">  linkExactActiveClass:<span class="string">&#x27;自定义class名&#x27;</span>   <span class="comment">// 严格模式</span></span><br><span class="line">routes:[</span><br><span class="line">   &#123; <span class="attr">path</span>:<span class="string">&quot;*&quot;</span>,<span class="attr">component</span>:<span class="number">404</span>组件 &#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">routes:[</span><br><span class="line">&#123; <span class="attr">path</span>:<span class="string">&quot;/地址A&quot;</span>,<span class="attr">redirect</span>:<span class="string">&quot;/地址B&quot;</span> &#125;   <span class="comment">// 访问地址A的时候跳转到地址B</span></span><br><span class="line">]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="命名路由"><a href="#命名路由" class="headerlink" title="命名路由"></a>命名路由</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">routes:[</span><br><span class="line">     &#123; <span class="attr">path</span>:<span class="string">&quot;/地址A&quot;</span>,<span class="attr">component</span>:组件A,  <span class="attr">name</span>:<span class="string">&quot;名称A&quot;</span> &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/地址A&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-link :to&#x3D;&quot;&#123;name:&#39;名称A&#39;&#125;&quot;&gt;&lt;&#x2F;router-link&gt;</span><br></pre></td></tr></table></figure><h3 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h3><ul><li><p>使用场景：</p><ul><li>   新闻列表 到新闻详情     详情需要知道新闻id。</li><li>   新闻分类 到新闻列表    新闻列表需要知道新闻分类id</li><li>   愿望： 实现页面之间的传递参数吗</li></ul></li><li><p>使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  routes:[</span><br><span class="line">   &#123; <span class="attr">path</span>:<span class="string">&quot;/地址A/:标识符&quot;</span>,<span class="attr">component</span>:组件A &#125;,</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/地址A/数据&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 组件A里面</span></span><br><span class="line"><span class="built_in">this</span>.$route.params.标识符</span><br></pre></td></tr></table></figure><p><strong>实现了两个页面之间的传参</strong></p></li><li><p>注意：</p><p>当我们在main.js中将路由挂载到vue实例上面去之后， 所有的组件对象里面都会多两个属性，一个<code>$router</code>,<code>$route</code></p><ul><li><code>$router</code>表示这个路由实例对象</li><li><code>$route</code> 表示当前页面的路由信息<ul><li>this.$route.params   动态路由数据</li><li>this.$route.name   路由名称</li><li>this.$route.meta   元数据</li><li>this.$route.query   search参数</li><li>this.$route.matched   路径信息</li></ul></li></ul></li></ul><h4 id="如何实现页面之间传参"><a href="#如何实现页面之间传参" class="headerlink" title="如何实现页面之间传参"></a>如何实现页面之间传参</h4><ul><li><p>动态路由</p></li><li><p>query传参</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/地址B?key=val&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.$route.query.key</span><br></pre></td></tr></table></figure></li><li><p>本地存储</p><ul><li>localStorage.setItem(“key”,val)</li><li>localStorage.getItem(“key”)</li></ul></li></ul><h2 id="路由升级"><a href="#路由升级" class="headerlink" title="路由升级"></a>路由升级</h2><h3 id="编程式导航"><a href="#编程式导航" class="headerlink" title="编程式导航"></a>编程式导航</h3><ul><li><p>原生JS实现页面跳转方式：</p><ul><li>a   href</li><li>JS    编程式导航<ul><li>location.href   assign   replace</li><li>history.back   forward  go</li></ul></li></ul></li><li><p><strong>$router</strong></p><ul><li><p>push</p></li><li><p>replace</p></li><li><p>go</p></li><li><p>back</p></li><li><p>forward</p></li></ul></li></ul><h3 id="嵌套路由"><a href="#嵌套路由" class="headerlink" title="嵌套路由"></a>嵌套路由</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">routes:[</span><br><span class="line">&#123;</span><br><span class="line">  path:<span class="string">&quot;/地址A&quot;</span>,    <span class="comment">//一级路由</span></span><br><span class="line">  component:组件A,   </span><br><span class="line">  children:[   <span class="comment">// 二级路由， 二级路由的组件 (组件aa，组件bb,组件cc都展示在组件A的模板里面的router-view里面，而不是顶级的router-view)</span></span><br><span class="line">  &#123; <span class="attr">path</span>:<span class="string">&quot;/地址A/aa&quot;</span>,<span class="attr">component</span>:组件aa &#125;,</span><br><span class="line">  &#123; <span class="attr">path</span>:<span class="string">&quot;/地址A/bb&quot;</span>,<span class="attr">component</span>:组件bb &#125;,</span><br><span class="line">  &#123; <span class="attr">path</span>:<span class="string">&quot;/地址A/cc&quot;</span>,<span class="attr">component</span>:组件cc &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 组件A里面一定要有一个router-view</span></span><br><span class="line">(组件aa，组件bb,组件cc都展示在组件A的模板里面的router-view里面，而不是顶级的router-view)</span><br></pre></td></tr></table></figure><h3 id="命名视图"><a href="#命名视图" class="headerlink" title="命名视图"></a>命名视图</h3><ul><li><p>视图就是<code>router-view</code></p></li><li><p>默认情况下： 一个路由只能渲染一个组件到一个指定的位置</p></li><li><p>如果我们希望访问一个路由的时候，同时渲染多个组件到不同位置，这个时候就可以使用命名视图</p></li><li><p>实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">routes:[</span><br><span class="line">&#123;</span><br><span class="line">  path:&quot;&#x2F;地址A&quot;,    &#x2F;&#x2F;一级路由</span><br><span class="line">  components:&#123;</span><br><span class="line">  default:组件A,</span><br><span class="line">  x:组件X,</span><br><span class="line">  y:组件y</span><br><span class="line">  &#125;,   </span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-view</span> <span class="attr">name</span>=<span class="string">&#x27;default&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span>   默认视图，可以不要name属性</span><br><span class="line"><span class="tag">&lt;<span class="name">router-view</span> <span class="attr">name</span>=<span class="string">&#x27;x&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span>   组件x渲染在这</span><br><span class="line"><span class="tag">&lt;<span class="name">router-view</span> <span class="attr">name</span>=<span class="string">&#x27;y&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span>   组件y渲染在这</span><br></pre></td></tr></table></figure></li></ul><h3 id="元信息"><a href="#元信息" class="headerlink" title="元信息"></a>元信息</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">routes:[</span><br><span class="line">&#123; </span><br><span class="line">path:<span class="string">&quot;/地址&quot;</span>,</span><br><span class="line">component:<span class="string">&quot;组件&quot;</span></span><br><span class="line">meta:&#123;  <span class="attr">key</span>:val &#125;   <span class="comment">// 元信息，表示给这个路由设置一些自定义属性</span></span><br><span class="line">&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.$route.meta.key    <span class="comment">// 可以获取数据</span></span><br></pre></td></tr></table></figure><h3 id="导航守卫"><a href="#导航守卫" class="headerlink" title="导航守卫"></a>导航守卫</h3><h4 id="什么是导航守卫"><a href="#什么是导航守卫" class="headerlink" title="什么是导航守卫"></a>什么是导航守卫</h4><p>进入路由、离开路由、更新路由的时候自动执行的函数。 又称之<strong>路由钩子函数</strong></p><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><ul><li>全局守卫<ul><li><strong>前置守卫    路由进入之前会执行的函数  beforeEach</strong><ul><li>设置标题</li><li>权限判断</li></ul></li><li>后置守卫    路由离开后执行的函数   afterEach</li></ul></li><li>局部守卫<ul><li>前置守卫</li><li>更新守卫</li><li>后置守卫</li></ul></li></ul><h3 id="路由懒加载"><a href="#路由懒加载" class="headerlink" title="路由懒加载"></a>路由懒加载</h3><ul><li><p>原来的路由配置文件里面都是通过import 导入所有的组件。这样做，应用开始的时候就会导入这些所有的组件，增加了负担</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Index <span class="keyword">from</span> <span class="string">&quot;@/pages/Index&quot;</span></span><br><span class="line"><span class="keyword">import</span> About <span class="keyword">from</span> <span class="string">&quot;@/pages/About&quot;</span></span><br><span class="line"><span class="keyword">import</span> New <span class="keyword">from</span> <span class="string">&quot;@/pages/New&quot;</span></span><br><span class="line"><span class="keyword">import</span> NewInfo <span class="keyword">from</span> <span class="string">&quot;@/pages/NewInfo&quot;</span></span><br><span class="line"><span class="keyword">import</span> User <span class="keyword">from</span> <span class="string">&quot;@/pages/User&quot;</span></span><br><span class="line"><span class="keyword">import</span> UserOrder <span class="keyword">from</span> <span class="string">&quot;@/pages/UserOrder&quot;</span></span><br><span class="line"><span class="keyword">import</span> UserClass <span class="keyword">from</span> <span class="string">&quot;@/pages/UserClass&quot;</span></span><br><span class="line"><span class="keyword">import</span> UserSet <span class="keyword">from</span> <span class="string">&quot;@/pages/UserSet&quot;</span></span><br><span class="line"><span class="keyword">import</span> UserIndex <span class="keyword">from</span> <span class="string">&quot;@/pages/UserIndex&quot;</span></span><br><span class="line"><span class="keyword">import</span> NotFound <span class="keyword">from</span> <span class="string">&quot;@/pages/NotFound&quot;</span></span><br><span class="line"><span class="keyword">import</span> Adv <span class="keyword">from</span> <span class="string">&quot;@/components/Adv&quot;</span></span><br><span class="line"><span class="keyword">import</span> Login <span class="keyword">from</span> <span class="string">&quot;@/pages/Login&quot;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>希望打开哪个路由地址的时候就再去加载对应的路由组件。 这就是路由懒加载</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> 组件名 <span class="keyword">from</span> <span class="string">&quot;@/pages/组件名&quot;</span></span><br><span class="line">&#123;</span><br><span class="line">  path:<span class="string">&quot;/地址&quot;</span>,</span><br><span class="line">  component:组件名</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> path:<span class="string">&quot;/地址&quot;</span>,</span><br><span class="line"> component:<span class="function">()=&gt;</span><span class="keyword">import</span>(<span class="string">&quot;@/pages/组件名&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;路由基础&quot;&gt;&lt;a href=&quot;#路由基础&quot; class=&quot;headerlink&quot; title=&quot;路由基础&quot;&gt;&lt;/a&gt;路由基础&lt;/h2&gt;&lt;h3 id=&quot;路由含义&quot;&gt;&lt;a href=&quot;#路由含义&quot; class=&quot;headerlink&quot; title=&quot;路由含义&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="Vue" scheme="https://wuyangqin.github.io/categories/Vue/"/>
    
    <category term="Vue2" scheme="https://wuyangqin.github.io/categories/Vue/Vue2/"/>
    
    
    <category term="Vue" scheme="https://wuyangqin.github.io/tags/Vue/"/>
    
    <category term="Vue2" scheme="https://wuyangqin.github.io/tags/Vue2/"/>
    
  </entry>
  
  <entry>
    <title>Vue - 组件通信</title>
    <link href="https://wuyangqin.github.io/2020/09/27/Vue-components-communication/"/>
    <id>https://wuyangqin.github.io/2020/09/27/Vue-components-communication/</id>
    <published>2020-09-27T04:25:49.000Z</published>
    <updated>2021-03-29T02:22:11.544Z</updated>
    
    <content type="html"><![CDATA[<h2 id="父子通信"><a href="#父子通信" class="headerlink" title="父子通信"></a>父子通信</h2><h3 id="实现：-自定义属性"><a href="#实现：-自定义属性" class="headerlink" title="实现： 自定义属性"></a>实现： 自定义属性</h3><ul><li><p>使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 子组件里面</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  props:[<span class="string">&#x27;属性名1&#x27;</span>,<span class="string">&#x27;属性名2&#x27;</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子模板里面</span></span><br><span class="line">&#123;&#123;属性名<span class="number">1</span>&#125;&#125;   &#123;&#123;属性名<span class="number">2</span>&#125;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--父组件里面--&gt;</span></span><br><span class="line">&lt;子组件  属性名1=&quot;值&quot;   :属性名2=&quot;变量&quot; /&gt;</span><br></pre></td></tr></table></figure><p><img src="/images/vue-components/img1.png"></p></li></ul><p><strong>为了保证组件内部数据的统一性，我们要对组件的自定义属性，进行类型的验证！</strong></p><h3 id="props验证"><a href="#props验证" class="headerlink" title="props验证"></a>props验证</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">props:[<span class="string">&#x27;属性名&#x27;</span>]    <span class="comment">// 尽量不要使用数组模式</span></span><br><span class="line"></span><br><span class="line">props:&#123;  <span class="comment">// 对象模式</span></span><br><span class="line">  属性名:类型,</span><br><span class="line">  属性名:[类型<span class="number">1</span>,类型<span class="number">2</span>],  </span><br><span class="line">  属性名:&#123;</span><br><span class="line">     type:类型,  <span class="comment">// 单类型       // 类型校验</span></span><br><span class="line">     type:[类型<span class="number">1</span>,类型<span class="number">2</span>],  <span class="comment">// 多类型</span></span><br><span class="line">     <span class="keyword">default</span>:默认值    <span class="comment">// 默认值</span></span><br><span class="line">     <span class="function"><span class="title">default</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> 对象/数组</span><br><span class="line">     &#125;,</span><br><span class="line">     required:<span class="literal">true</span>/<span class="literal">false</span>,  <span class="comment">// 是否必须</span></span><br><span class="line">     <span class="function"><span class="title">validator</span>(<span class="params">val</span>)</span>&#123;     <span class="comment">// 自定义校验函数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>/<span class="literal">false</span></span><br><span class="line">     &#125;  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>哪些类型？</strong></p><ul><li><code>String</code></li><li><code>Number</code></li><li><code>Boolean</code></li><li><code>Array</code></li><li><code>Object</code></li><li><code>Date</code></li><li><code>Function</code></li><li><code>Symbol</code></li></ul><h4 id="单向数据流"><a href="#单向数据流" class="headerlink" title="单向数据流"></a>单向数据流</h4><p>所有的 prop 都使得其父子 prop 之间形成了一个<strong>单向下行绑定</strong>：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。这样会<strong>防止从子组件意外变更父级组件的状态，从而导致你的应用的数据流向难以理解。</strong></p><p><strong>修改props，不是真的修改</strong></p><ul><li><p><strong>props 用来传递一个初始值赋给组件的data</strong></p></li><li><p><strong>props 赋给计算属性</strong></p></li><li><p>传入一个对象的所有property</p><p>如果你想要将一个对象的所有 property 都作为 prop 传入，你可以使用不带参数的 <code>v-bind</code> (取代 <code>v-bind:prop-name</code>)。例如，对于一个给定的对象 <code>post</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">post: &#123;</span><br><span class="line">  id: <span class="number">1</span>,</span><br><span class="line">  title: <span class="string">&#x27;My Journey with Vue&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面的模板：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">blog-post</span> <span class="attr">v-bind</span>=<span class="string">&quot;post&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br></pre></td></tr></table></figure><p>等价于：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;blog-post</span><br><span class="line">  v-bind:id=&quot;post.id&quot;</span><br><span class="line">  v-bind:title=&quot;post.title&quot;</span><br><span class="line">&gt;<span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>总结：</strong></p><ul><li>props的使用</li><li>props验证</li><li>单项数据流</li></ul></li></ul><h2 id="子父通信"><a href="#子父通信" class="headerlink" title="子父通信"></a>子父通信</h2><h3 id="实现：-自定义事件"><a href="#实现：-自定义事件" class="headerlink" title="实现： 自定义事件"></a>实现： 自定义事件</h3><ul><li><p>使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父的模板里面</span></span><br><span class="line">&lt;子组件名 @自定义事件名=<span class="string">&quot;父的事件函数&quot;</span> /&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父的JS里面</span></span><br><span class="line">methods:&#123;</span><br><span class="line">父的事件函数(形参)&#123;</span><br><span class="line">     ....</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.$emit(<span class="string">&quot;自定义事件名&quot;</span>,实参)    <span class="comment">// 本质调用了，父的事件函数</span></span><br></pre></td></tr></table></figure><p><img src="/images/vue-components/img2.png"></p><p><img src="/images/vue-components/img3.png"></p></li></ul><h2 id="祖先后代通信"><a href="#祖先后代通信" class="headerlink" title="祖先后代通信"></a>祖先后代通信</h2><ul><li><p>目的： 实现祖先的数据，后代都可以使用（一般用于全局变量）</p></li><li><p>实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 祖先组件</span></span><br><span class="line">provide:&#123;</span><br><span class="line">key1:val1,</span><br><span class="line">key2:val2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 后代任意组件中</span></span><br><span class="line">inject:[key1,key2]      </span><br><span class="line">inject:&#123;</span><br><span class="line">  newkey:&#123;</span><br><span class="line">     <span class="keyword">from</span>:key1,</span><br><span class="line">     <span class="keyword">default</span>:<span class="string">&quot;默认值&quot;</span>  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;&#123;key1&#125;&#125;    &#123;&#123;key2&#125;&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="非父子通信"><a href="#非父子通信" class="headerlink" title="非父子通信"></a>非父子通信</h2><ul><li><p>实现任意两个组件之间的通信！</p></li><li><p>核心：<strong>利用vue里面的$emit 和 $on 实现 组件的监听事件和触发事件</strong></p></li><li><p>实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js中</span></span><br><span class="line"><span class="keyword">let</span> bus = <span class="keyword">new</span> Vue();</span><br><span class="line"><span class="comment">// 在Vue的原型上面添加数据，所有的组件里都可以获取到</span></span><br><span class="line">Vue.prototype.$bus = bus</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 任意组件中  事件订阅</span></span><br><span class="line"><span class="function"><span class="title">created</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="built_in">this</span>.$bus.$on(<span class="string">&#x27;自定义事件名&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">形参</span>)</span>&#123;</span><br><span class="line">       ...</span><br><span class="line">   &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 任意其他组件中  事件发布</span></span><br><span class="line"><span class="built_in">this</span>.$bus.$emit(<span class="string">&#x27;自定义事件名&#x27;</span>,实参)</span><br></pre></td></tr></table></figure></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>父子通信<ul><li>自定义属性（props）、自定义事件（$emit）</li></ul></li><li>祖先后代<ul><li>provide （祖先）</li><li>inject (后代)</li></ul></li><li>非父子<ul><li>$on  和  $emit     自定义事件</li></ul></li><li>本地存储</li><li>父子关系<ul><li>$parent</li><li>$children、$refs</li></ul></li><li>vuex</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;父子通信&quot;&gt;&lt;a href=&quot;#父子通信&quot; class=&quot;headerlink&quot; title=&quot;父子通信&quot;&gt;&lt;/a&gt;父子通信&lt;/h2&gt;&lt;h3 id=&quot;实现：-自定义属性&quot;&gt;&lt;a href=&quot;#实现：-自定义属性&quot; class=&quot;headerlink&quot; title=</summary>
      
    
    
    
    <category term="Vue" scheme="https://wuyangqin.github.io/categories/Vue/"/>
    
    <category term="Vue2" scheme="https://wuyangqin.github.io/categories/Vue/Vue2/"/>
    
    
    <category term="Vue" scheme="https://wuyangqin.github.io/tags/Vue/"/>
    
    <category term="Vue2" scheme="https://wuyangqin.github.io/tags/Vue2/"/>
    
  </entry>
  
</feed>
