<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yang&#39;s Blog</title>
  
  <subtitle>虹の先へ</subtitle>
  <link href="https://amiemie906.gitee.io/atom.xml" rel="self"/>
  
  <link href="https://amiemie906.gitee.io/"/>
  <updated>2021-03-31T10:30:02.490Z</updated>
  <id>https://amiemie906.gitee.io/</id>
  
  <author>
    <name>Yangqin Wu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>node学习记录（二）-文件模块-制作一个使用命令行操作的todo list</title>
    <link href="https://amiemie906.gitee.io/2021/03/31/node-notes-2-fs/"/>
    <id>https://amiemie906.gitee.io/2021/03/31/node-notes-2-fs/</id>
    <published>2021-03-31T15:32:01.000Z</published>
    <updated>2021-03-31T10:30:02.490Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>源码链接：<a href="https://github.com/wuyangqin/node-todo-list">https://github.com/wuyangqin/node-todo-list</a></p></blockquote><p>使用node的<code>fs</code>文件模块实现了一个简单的用命令行操作的todo list</p><h2 id="技术细节"><a href="#技术细节" class="headerlink" title="技术细节"></a>技术细节</h2><ul><li>使用node.js <code>fs</code>模块实现文件读写</li><li>使用<code>commander.js</code>编写命令行命令</li><li>使用<code>inquirer.js</code> 实现用户与命令行的交互 </li><li>使用<code>jest.js</code> 模拟fs，编写单元测试</li></ul><h2 id="效果演示"><a href="#效果演示" class="headerlink" title="效果演示"></a>效果演示</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g node-todo-xx</span><br></pre></td></tr></table></figure><p>or</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn global add node-todo-xx</span><br></pre></td></tr></table></figure><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">todo <span class="comment"># 查看所有任务列表,能够操作任务增删改查</span></span><br><span class="line">todo add 任务名 <span class="comment"># 添加一个任务</span></span><br><span class="line">todo clear <span class="comment"># 清空所有任务</span></span><br></pre></td></tr></table></figure><p><strong>todo 查看任务列表</strong></p><p><img src="/images/node-notes/fs-todo.png" alt="查看任务列表"></p><p><img src="/images/node-notes/fs-todo-onetask.png" alt="对某项任务进行操作"></p><p><strong>todo add 添加任务</strong></p><p><img src="/images/node-notes/fs-todo-add.png" alt="添加任务"></p><p><strong>todo clear 清除任务</strong></p><p><img src="/images/node-notes/fs-todo-clear.png" alt="添加任务"></p><h2 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h2><h3 id="逻辑梳理"><a href="#逻辑梳理" class="headerlink" title="逻辑梳理"></a>逻辑梳理</h3><p>该项目的实现逻辑如图所示：</p><p><img src="/images/node-notes/todo-logic.png"></p><h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">├── __mocks__</span><br><span class="line">|  └── fs.js  <span class="comment"># 模拟fs模块</span></span><br><span class="line">├── __test__  <span class="comment"># 存放测试文件</span></span><br><span class="line">|  └── db.test.js</span><br><span class="line">├── cli.js <span class="comment"># 命令行操作逻辑</span></span><br><span class="line">├── db.js <span class="comment"># 读写任务的函数</span></span><br><span class="line">└── index.js <span class="comment"># 任务的操作逻辑</span></span><br></pre></td></tr></table></figure><h3 id="读写文件"><a href="#读写文件" class="headerlink" title="读写文件"></a>读写文件</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> os = <span class="built_in">require</span>(<span class="string">&#x27;os&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> homedir = os.homedir(); <span class="comment">// 获取home目录</span></span><br><span class="line"><span class="keyword">const</span> home = process.env.HOME || homedir; <span class="comment">// 如果用户自己设置了HOME的环境变量</span></span><br><span class="line"><span class="keyword">const</span> dbPath = path.join(home,<span class="string">&#x27;.todo&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> db = &#123;</span><br><span class="line">  <span class="function"><span class="title">read</span>(<span class="params">path = dbPath</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// &#x27;a+&#x27;: Open file for reading and appending. The file is created if it does not exist.</span></span><br><span class="line">      fs.readFile(path,&#123; <span class="attr">flag</span>: <span class="string">&#x27;a+&#x27;</span>&#125;, <span class="function">(<span class="params">readError,data</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (readError) <span class="keyword">return</span> reject(readError)</span><br><span class="line">        <span class="keyword">let</span> list</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          list = <span class="built_in">JSON</span>.parse(data.toString())</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">          list = []</span><br><span class="line">        &#125;</span><br><span class="line">        resolve(list)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">write</span>(<span class="params">list, path = dbPath</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> string = <span class="built_in">JSON</span>.stringify(list)</span><br><span class="line">      fs.writeFile(path,string + <span class="string">&#x27;\n&#x27;</span>,<span class="function">(<span class="params">writeError</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(writeError) <span class="keyword">return</span> reject(writeError)</span><br><span class="line">        resolve()</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports  = db</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><h4 id="测试命令"><a href="#测试命令" class="headerlink" title="测试命令"></a>测试命令</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn <span class="built_in">test</span></span><br></pre></td></tr></table></figure><h4 id="fs-mock"><a href="#fs-mock" class="headerlink" title="fs mock"></a>fs mock</h4><p>从上面的逻辑梳理图可以看到，这个项目最主要的就是对任务文件进行操作的两个函数，因此将围绕这两个函数进行单元测试的编写。</p><p>然而编写单元测试有一条原则就是，<strong>测试代码不要与外界进行交互</strong>，比如如果我通过测试代码读取用户硬盘上的某个文件，而这个文件路径刚好在用户硬盘中存在，这就很尴尬啦。因此<code>jest</code>提供了对node模块进行<code>mock</code>的功能——相当于对node的模块进行接管，调用我们自己编写的方法。具体实现如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在项目根目录创建&#x27;__mock__&#x27;文件夹, 并创建&#x27;fs.js&#x27;文件 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fs = jest.genMockFromModule(<span class="string">&#x27;fs&#x27;</span>) <span class="comment">// 创建模拟的fs模块</span></span><br><span class="line"><span class="keyword">const</span> _fs = jest.requireActual(<span class="string">&#x27;fs&#x27;</span>) <span class="comment">// 引入实际的fs模块</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.assign(fs, _fs) <span class="comment">// 将原fs模块的属性复制给我们创建的模拟fs模块</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> readMocks = &#123;&#125;</span><br><span class="line">fs.setReadFileMock = <span class="function">(<span class="params">path, error, data</span>) =&gt;</span> &#123;</span><br><span class="line">  readMocks[path] = [error, data]</span><br><span class="line">&#125;</span><br><span class="line">fs.readFile = <span class="function">(<span class="params">path,options,callback</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (callback === <span class="literal">undefined</span>) callback = options</span><br><span class="line">  <span class="keyword">if</span> (path <span class="keyword">in</span> readMocks) &#123;</span><br><span class="line">    callback(...readMocks[path])</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    _fs.readFile(path, options, callback)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> writeMocks = &#123;&#125;</span><br><span class="line">fs.setWriteFileMock = <span class="function">(<span class="params">path, fn</span>) =&gt;</span> &#123;</span><br><span class="line">  writeMocks[path] = fn</span><br><span class="line">&#125;</span><br><span class="line">fs.writeFile  = <span class="function">(<span class="params">path, data, options, callback</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (callback === <span class="literal">undefined</span>) callback = options</span><br><span class="line">  <span class="keyword">if</span> (path <span class="keyword">in</span> writeMocks) &#123;</span><br><span class="line">    writeMocks[path](path, data, options, callback)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    _fs.writeFile(path, data, options, callback)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fs.clearMocks = <span class="function">() =&gt;</span> &#123; <span class="comment">// 清除mock</span></span><br><span class="line">  readMocks = &#123;&#125;</span><br><span class="line">  writeMocks = &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = fs</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// __test__文件夹用来存放测试文件，在&#x27;db.spec.js&#x27;中编写读写文件两个函数的测试代码</span></span><br><span class="line"><span class="keyword">const</span> db = <span class="built_in">require</span>(<span class="string">&#x27;../db.js&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line">jest.mock(<span class="string">&#x27;fs&#x27;</span>) <span class="comment">// jest将fs接管</span></span><br><span class="line"></span><br><span class="line">describe(<span class="string">&#x27;db&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  afterEach(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    fs.clearMocks()</span><br><span class="line">  &#125;)</span><br><span class="line">  </span><br><span class="line">  it (<span class="string">&#x27;can read&#x27;</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> data = [&#123;<span class="attr">title</span>: <span class="string">&#x27;hi&#x27;</span>, <span class="attr">done</span>: <span class="literal">false</span>&#125;]</span><br><span class="line">    fs.setReadFileMock(<span class="string">&#x27;/test&#x27;</span>,<span class="literal">null</span>, <span class="built_in">JSON</span>.stringify(data))</span><br><span class="line">    <span class="keyword">const</span> list = <span class="keyword">await</span> db.read(<span class="string">&#x27;/test&#x27;</span>)</span><br><span class="line">    expect(list).toStrictEqual(data)</span><br><span class="line">  &#125;)</span><br><span class="line">  </span><br><span class="line">  it (<span class="string">&#x27;can write&#x27;</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> fakeFile</span><br><span class="line">    fs.setWriteFileMock(<span class="string">&#x27;/test1&#x27;</span>, <span class="function">(<span class="params">path, data, callback</span>) =&gt;</span> &#123;</span><br><span class="line">      fakeFile = data</span><br><span class="line">      callback(<span class="literal">null</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">const</span> list = [&#123;<span class="attr">title</span>: <span class="string">&#x27;hi&#x27;</span>, <span class="attr">done</span>: <span class="literal">false</span>&#125;]</span><br><span class="line">    <span class="keyword">await</span> db.write(list,<span class="string">&#x27;/test1&#x27;</span>)</span><br><span class="line">    expect(fakeFile).toBe(<span class="built_in">JSON</span>.stringify(list) + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;源码链接：&lt;a href=&quot;https://github.com/wuyangqin/node-todo-list&quot;&gt;https://github.com/wuyangqin/node-todo-list&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;</summary>
      
    
    
    
    <category term="node" scheme="https://amiemie906.gitee.io/categories/node/"/>
    
    
    <category term="node" scheme="https://amiemie906.gitee.io/tags/node/"/>
    
  </entry>
  
  <entry>
    <title>node学习记录（一）-node初识</title>
    <link href="https://amiemie906.gitee.io/2021/03/24/node-notes-1-intro/"/>
    <id>https://amiemie906.gitee.io/2021/03/24/node-notes-1-intro/</id>
    <published>2021-03-24T12:05:01.000Z</published>
    <updated>2021-03-31T08:34:09.096Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Node-简介"><a href="#Node-简介" class="headerlink" title="Node 简介"></a>Node 简介</h2><h3 id="node-js-不是什么"><a href="#node-js-不是什么" class="headerlink" title="node.js 不是什么"></a>node.js 不是什么</h3><ul><li>不是web后端框架</li><li>不是编程语言</li></ul><h3 id="node-js是什么"><a href="#node-js是什么" class="headerlink" title="node.js是什么"></a>node.js是什么</h3><ul><li>将多种技术组合起来</li><li>让JavaScript也能调用系统接口、开发后端应用</li></ul><h3 id="用到了哪些技术"><a href="#用到了哪些技术" class="headerlink" title="用到了哪些技术"></a>用到了哪些技术</h3><ul><li>V8引擎</li><li>libuv</li><li>C/C++实现的 c-ares(实现DNS 域名的解析)，http-parser(解析http)，OpenSSL(https)，zlib(加密)等库</li></ul><h3 id="Node特点"><a href="#Node特点" class="headerlink" title="Node特点"></a>Node特点</h3><p><strong>单线程</strong></p><ul><li>进程就是一个一个的工作计划（工厂中的车间）</li><li>线程是计算机最小的运算单位（工厂中的工人），线程是干活的</li><li>传统的服务器是多线程的，每进来一个请求，就创建一个线程去处理请求</li><li>Node.js的服务器是单线程的，在后台拥有一个I/O线程池</li></ul><p><strong>非阻塞 I/O</strong></p><ul><li><p>I/O：对磁盘的读写操作( Input/ Output)</p></li><li><p>非阻塞：不会等I/O语句结束，而会执行后面的语句（异步）</p><p>异步：调用者发起一个异步调用，然后立即返回去做别的事。“被调用者”通过状态、通知、回调函数等手段来通知“调用者”。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line">fs.readFile(<span class="string">&#x27;/app.js&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err,file</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;我读完文件了！);</span></span><br><span class="line"><span class="string">&#125;)</span></span><br><span class="line"><span class="string">console.log(&#x27;</span>我不会被阻塞！<span class="string">&#x27;)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">//我不会被阻塞是在我读完文件了之前输出 =&gt;异步调用</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">//机制:进行I/O操作，给readFile绑定一个回调函数function(err,file)&#123;&#125;,并在读取textfile完成后执行回调函数。期间，后面的代码继续执行，不受I/O阻塞</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>事件驱动</strong></p><h2 id="Node-js技术架构"><a href="#Node-js技术架构" class="headerlink" title="Node.js技术架构"></a>Node.js技术架构</h2><p><img src="/images/node-notes/node-struct.png" alt="Node.js技术架构"></p><p>stream模块</p><ul><li>第一层 可以用js直接调用的api</li></ul><h4 id="bingdings-让JS和C-C-通信"><a href="#bingdings-让JS和C-C-通信" class="headerlink" title="bingdings 让JS和C/C++通信"></a>bingdings 让JS和C/C++通信</h4><p>举例：</p><ul><li>C/C++实现了一个http_parser库，但不能用JS直接调用这个库，于是需要一个中间的销量</li><li>Node.js用C++对该库进行封装，并用其提供的编译工具将该库编译为.node文件</li><li>js代码可以直接require这个.node文件</li><li>实现js调用C++库，中间的桥梁–binding</li><li>Node.js提供了很多binding – bindings</li></ul><h4 id="V8-JS引擎"><a href="#V8-JS引擎" class="headerlink" title="V8 JS引擎"></a>V8 JS引擎</h4><ul><li>功能<ul><li>将JS源代码变成本地代码并执行</li><li>维护调用栈，确保JS函数的执行顺序</li><li>内存管理，为所有对象分配内存</li><li>垃圾回收，重复利用无用的内存</li><li>实现JS的标准库</li></ul></li><li>注意<ul><li>V8不提供 DOM API</li><li>本身是多线程，如垃圾回收是单独线程，但执行JS是单线程的</li><li>可以开启两个线程分别执行JS</li><li>自带event loop，但Node.js基于liuv自己做了一个</li></ul></li></ul><h4 id="libuv"><a href="#libuv" class="headerlink" title="libuv"></a>libuv</h4><ul><li>一个跨平台的异步I/O库，会根据系统自动选择合适的方案</li><li>I/O:对磁盘的读写操作( Input/ Output)</li><li>功能：可以用于 TCP/UDP/DNS/文件 等的异步操作<ul><li>TCP：http是基于TCPIP，能操作TCP就能做服务器</li><li>UDP：一般用于网页聊天</li><li>DNS：域名</li></ul></li></ul><h3 id="Event-Loop"><a href="#Event-Loop" class="headerlink" title="Event Loop"></a>Event Loop</h3><h4 id="什么是loop"><a href="#什么是loop" class="headerlink" title="什么是loop"></a>什么是loop</h4><ul><li>loop就是循环</li><li>由于事件是分优先级的，所以处理起来也是分先后的</li><li>node.js需要按顺序轮询每种事件</li><li>这种轮询往往是循环的</li></ul><h4 id="Event-Loop-1"><a href="#Event-Loop-1" class="headerlink" title="Event Loop"></a>Event Loop</h4><ul><li>对事件处理顺序的管理</li></ul><h4 id="顺序示意图"><a href="#顺序示意图" class="headerlink" title="顺序示意图"></a>顺序示意图</h4><p><img src="/images/node-notes/node-eventloop.png" alt="Event Loop图示"></p><ul><li>重点阶段<ul><li>timers 检查计时器</li><li>poll 轮询，检查系统时间</li><li>check检查setImmediate回调</li></ul></li><li>注意<ul><li>大部分时间，Node.js都停在poll 轮询阶段</li><li>大部分事件都在poll阶段被处理，如文件、网络请求</li></ul></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>用libuv进行异步I/O操作</li><li>用event loop管理事件处理顺序</li><li>用C/C++库高效处理DNS/HTTP</li><li>用bindings让JS能和C/C++沟通</li><li>用V8运行JS</li><li>用Node.js标准库简化JS</li></ul><h4 id="Node-js工作流程"><a href="#Node-js工作流程" class="headerlink" title="Node.js工作流程"></a>Node.js工作流程</h4><p><img src="/images/node-notes/node-progress.png" alt="Node.js工作流程图示"></p><h2 id="Node-js-API"><a href="#Node-js-API" class="headerlink" title="Node.js API"></a>Node.js API</h2><h3 id="API文档"><a href="#API文档" class="headerlink" title="API文档"></a>API文档</h3><ul><li>官方文档：<a href="http://nodejs.cn/api/">http://nodejs.cn/api/</a></li><li>民间版本： <a href="https://devdocs.io/">https://devdocs.io/</a></li></ul><h3 id="API有哪些功能"><a href="#API有哪些功能" class="headerlink" title="API有哪些功能"></a>API有哪些功能</h3><ul><li>assersion 断言</li><li>testing</li><li>async hooks</li><li>*Buffer  一小段缓存</li><li>*Child Processes 子进程</li><li>*Cluster</li><li>*Events 发布订阅模式</li><li>*Debugger 调试</li><li>*File System 文件系统 对文件的增删改查</li><li>*Globals 全局变量</li><li>*HTTP</li><li>*Path 路径</li><li>*Process 当前进程的相关信息</li><li>*Query String </li><li>*Stream 流格式</li><li>*Timers</li><li>*URL</li><li>*Worker Threads   node10之后才有的</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Node-简介&quot;&gt;&lt;a href=&quot;#Node-简介&quot; class=&quot;headerlink&quot; title=&quot;Node 简介&quot;&gt;&lt;/a&gt;Node 简介&lt;/h2&gt;&lt;h3 id=&quot;node-js-不是什么&quot;&gt;&lt;a href=&quot;#node-js-不是什么&quot; class=&quot;</summary>
      
    
    
    
    <category term="node" scheme="https://amiemie906.gitee.io/categories/node/"/>
    
    
    <category term="node" scheme="https://amiemie906.gitee.io/tags/node/"/>
    
  </entry>
  
  <entry>
    <title>Vue3造轮子（三）-Dialog组件</title>
    <link href="https://amiemie906.gitee.io/2021/03/07/Vue3-3-dialog/"/>
    <id>https://amiemie906.gitee.io/2021/03/07/Vue3-3-dialog/</id>
    <published>2021-03-07T15:31:05.000Z</published>
    <updated>2021-04-01T07:34:25.921Z</updated>
    
    <content type="html"><![CDATA[<h2 id="效果预览"><a href="#效果预览" class="headerlink" title="效果预览"></a>效果预览</h2><p><img src="/images/vue3-dialog/dialog.png"></p><p><a href="https://github.com/wuyangqin/xing-ui-v3">代码链接</a></p><p><a href="https://github.com/wuyangqin/xing-ui-v3/commits/aa06d1bddb7c8c922ad912cd66722a764e4eaccb">提交历史</a></p><h2 id="API设计"><a href="#API设计" class="headerlink" title="API设计"></a>API设计</h2><h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><ul><li>点击后弹出  – v-model:visible</li><li>有遮罩层 overlay，可控制点击遮罩层是否关闭 – closeOnClickOverlay</li><li>有 close 按钮</li><li>有标题，支持自定义标题 – title / slot=”title” </li><li>有内容 ，支持自定义内容 – content / slot=”content”</li><li>有 确认 / 取消 按钮，同时支持确认 / 取消事件 – onConfirm / onCancel</li><li>支持异步关闭</li><li>支持组件式调用，也支持函数式调用 – 动态挂载组件</li><li>可以指定挂载节点 – getContainer</li></ul><h3 id="用户怎么用该组件"><a href="#用户怎么用该组件" class="headerlink" title="用户怎么用该组件"></a>用户怎么用该组件</h3><p><strong>组件调用</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">x-dialog</span> </span></span><br><span class="line"><span class="tag">  <span class="attr">visible</span></span></span><br><span class="line"><span class="tag">  <span class="attr">title</span>=<span class="string">&quot;标题&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">content</span>=<span class="string">&quot;内容太&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">:onConfirm</span>=<span class="string">&quot;fn1&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">:onCancel</span>=<span class="string">&quot;fn2&quot;</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">x-ialog</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>函数式调用</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">setup() =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> showDialog = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      openDialog(&#123;</span><br><span class="line">        title: <span class="string">&#x27;标题&#x27;</span>,</span><br><span class="line">        content: <span class="string">&#x27;嗨 小星星&#x27;</span>,</span><br><span class="line">        onConfirm:<span class="function">() =&gt;</span> &#123;&#125;,</span><br><span class="line">        onCancel:<span class="function">() =&gt;</span> &#123;&#125;,</span><br><span class="line">        closeOnClickOverlay: <span class="literal">false</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123; showDialog &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Vue3笔记"><a href="#Vue3笔记" class="headerlink" title="Vue3笔记"></a>Vue3笔记</h2><h3 id="Teleport"><a href="#Teleport" class="headerlink" title="Teleport"></a>Teleport</h3><p><a href="https://vue3js.cn/docs/zh/guide/teleport.html">参考文档</a></p><p><code>Dialog</code>组件使用<code>fixed</code>定位，如果将其嵌套在某个组件内部，很可能会产生嵌套组件定位层级问题，处理起来会比较麻烦。因此，需要将模板渲染的位置与组件逻辑剥离开来。<code>vue3</code>提供了一个非常方便的新特性——<code>teloport</code>，可以理解为传送门，允许我们控制在 DOM 中哪个父节点下呈现 HTML。</p><h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><p><code>teleport</code>接受两个属性：</p><p><strong>to - string</strong></p><p>以<code>Dialog</code>组件为例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Teleport</span> <span class="attr">to</span>=<span class="string">&quot;#app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;xx-dialog-overlay&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;onClickOverlay&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;xx-dialog-wrapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;xx-dialog&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">header</span> <span class="attr">:class</span>=<span class="string">&quot;&#123; &#x27;title&#x27;: title || $slots.title &#125;&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>=<span class="string">&quot;$slots.title&quot;</span> <span class="attr">class</span>=<span class="string">&quot;title-slot&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;title&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-else</span>&gt;</span>&#123;&#123; title &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;xx-dialog-close&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;close&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">main</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">slot</span> <span class="attr">v-if</span>=<span class="string">&quot;$slots.content&quot;</span> <span class="attr">name</span>=<span class="string">&quot;content&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else</span>&gt;</span>&#123;&#123; content &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">footer</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">x-button</span> <span class="attr">size</span>=<span class="string">&quot;small&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;onCancel&quot;</span>&gt;</span>取消<span class="tag">&lt;/<span class="name">x-button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">x-button</span> <span class="attr">size</span>=<span class="string">&quot;small&quot;</span> <span class="attr">theme</span>=<span class="string">&quot;primary&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;onConfirm&quot;</span>&gt;</span>确定<span class="tag">&lt;/<span class="name">x-button</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Teleport</span>&gt;</span></span><br></pre></td></tr></table></figure><p>效果演示：</p><p><img src="/images/vue3-dialog/teleport.png"></p><p>可以看到通过<code>to</code>属性，指定该组件挂载到了<code>&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</code>中。</p><p><strong>注意</strong>：</p><ul><li><p><code>to</code>属性传入的值必须是有效的查询选择器或 HTMLElement</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 正确 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">teleport</span> <span class="attr">to</span>=<span class="string">&quot;#some-id&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">teleport</span> <span class="attr">to</span>=<span class="string">&quot;.some-class&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">teleport</span> <span class="attr">to</span>=<span class="string">&quot;[data-teleport]&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 错误 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">teleport</span> <span class="attr">to</span>=<span class="string">&quot;h1&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">teleport</span> <span class="attr">to</span>=<span class="string">&quot;some-string&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>默认挂载到第一个选择的元素</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span>container1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span>container2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">teleport</span> <span class="attr">to</span>=<span class="string">&quot;.container&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">teleport</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><p><img src="/images/vue3-dialog/teleport1.png" alt="挂载到第一个.container"></p><p><strong>disabled-boolean</strong></p><p>此可选属性可用于禁用 <code>teleport</code> 的功能，这意味着其插槽内容将不会移动到任何位置，而是在您在周围父组件中指定了 <code>teleport</code> 的位置渲染。</p><h4 id="与-Vue-components-一起使用"><a href="#与-Vue-components-一起使用" class="headerlink" title="与 Vue components 一起使用"></a>与 Vue components 一起使用</h4><p>如果 <code>teleport</code> 包含 Vue 组件，则它仍将是 <code>teleport</code> 父组件的逻辑子组件，仍接收父组件传来的属性。</p><h3 id="h-渲染函数"><a href="#h-渲染函数" class="headerlink" title="h() 渲染函数"></a>h() 渲染函数</h3><p>如果想要实现函数式调用<code>Dialog</code>组件，则需要通过渲染函数实现该组件的动态挂载。<code>Vue2</code>中的<a href="https://vuejs.bootcss.com/guide/render-function.html">渲染函数</a>为<code>createElement()</code>，而在<code>Vue3</code>中被称为<code>h()</code>，用于创建虚拟节点（更准确地命名为<code>createVNode()</code>，出于频繁使用和简洁的目的，改为了<code>h()</code>）。</p><p><code>h()</code>同样接受三个参数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @returns &#123;VNode&#125;</span></span><br><span class="line">h(</span><br><span class="line">  <span class="comment">// &#123;String | Object | Function | null&#125; tag</span></span><br><span class="line">  <span class="comment">// 一个 HTML 标签名、一个组件、一个异步组件，或者 null。</span></span><br><span class="line">  <span class="comment">// 使用 null 将会渲染一个注释。</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// 必需的。</span></span><br><span class="line">  <span class="string">&#x27;div&#x27;</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// &#123;Object&#125; props</span></span><br><span class="line">  <span class="comment">// 与 attribute、prop 和事件相对应的对象。</span></span><br><span class="line">  <span class="comment">// 我们会在模板中使用。</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// 可选的。</span></span><br><span class="line">  &#123;&#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// &#123;String | Array | Object&#125; children</span></span><br><span class="line">  <span class="comment">// 子 VNodes, 使用 `h()` 构建,</span></span><br><span class="line">  <span class="comment">// 或使用字符串获取 &quot;文本 Vnode&quot; 或者</span></span><br><span class="line">  <span class="comment">// 有 slot 的对象。</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// 可选的。</span></span><br><span class="line">  [</span><br><span class="line">    <span class="string">&#x27;Some text comes first.&#x27;</span>,</span><br><span class="line">    h(<span class="string">&#x27;h1&#x27;</span>, <span class="string">&#x27;A headline&#x27;</span>),</span><br><span class="line">    h(MyComponent, &#123;</span><br><span class="line">      someProp: <span class="string">&#x27;foobar&#x27;</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>实际应用如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> XDialog <span class="keyword">from</span> <span class="string">&#x27;../Dialog.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; createApp, h &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> openDialog = (&#123;</span><br><span class="line">    title = <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    content = <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    onConfirm = <span class="function">() =&gt;</span> &#123;&#125;,</span><br><span class="line">    onCancel = <span class="function">() =&gt;</span> &#123;&#125;,</span><br><span class="line">    closeOnClickOverlay = <span class="literal">true</span></span><br><span class="line">&#125;) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> div =  <span class="built_in">document</span>.createElement(<span class="string">&#x27;div&#x27;</span>)</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(div)</span><br><span class="line">    <span class="keyword">const</span> close = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        app.unmount()</span><br><span class="line">        div.remove()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> app = createApp(&#123;</span><br><span class="line">        <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> h(</span><br><span class="line">                XDialog,</span><br><span class="line">                &#123;</span><br><span class="line">                    visible: <span class="literal">true</span>,</span><br><span class="line">                    title,</span><br><span class="line">                    content,</span><br><span class="line">                    onConfirm,</span><br><span class="line">                    onCancel,</span><br><span class="line">                    closeOnClickOverlay,</span><br><span class="line">                    <span class="string">&#x27;onUpdate:visible&#x27;</span>:<span class="function">(<span class="params">newVisible</span>) =&gt;</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (!newVisible) &#123;</span><br><span class="line">                            close()</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    app.mount(div)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><code>teleport</code>指定挂载节点</li><li><code>h()</code>动态挂载组件</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;效果预览&quot;&gt;&lt;a href=&quot;#效果预览&quot; class=&quot;headerlink&quot; title=&quot;效果预览&quot;&gt;&lt;/a&gt;效果预览&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/images/vue3-dialog/dialog.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;htt</summary>
      
    
    
    
    <category term="Vue" scheme="https://amiemie906.gitee.io/categories/Vue/"/>
    
    <category term="Vue3" scheme="https://amiemie906.gitee.io/categories/Vue/Vue3/"/>
    
    
    <category term="Vue" scheme="https://amiemie906.gitee.io/tags/Vue/"/>
    
    <category term="Vue3" scheme="https://amiemie906.gitee.io/tags/Vue3/"/>
    
    <category term="造轮子" scheme="https://amiemie906.gitee.io/tags/%E9%80%A0%E8%BD%AE%E5%AD%90/"/>
    
  </entry>
  
  <entry>
    <title>Vue3造轮子（二）-Button组件</title>
    <link href="https://amiemie906.gitee.io/2021/02/27/Vue3-2-button/"/>
    <id>https://amiemie906.gitee.io/2021/02/27/Vue3-2-button/</id>
    <published>2021-02-27T14:55:13.000Z</published>
    <updated>2021-04-01T02:50:50.258Z</updated>
    
    <content type="html"><![CDATA[<h2 id="效果预览"><a href="#效果预览" class="headerlink" title="效果预览"></a>效果预览</h2><p><img src="/images/vue3-button/button.png"></p><p><a href="https://github.com/wuyangqin/xing-ui-v3">代码链接</a></p><p><a href="https://github.com/wuyangqin/xing-ui-v3/commits/a3eebc79f3ca6affd7c5fc6b87d1e076fe4a82fe">提交历史</a></p><h2 id="API设计"><a href="#API设计" class="headerlink" title="API设计"></a>API设计</h2><h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><ul><li><p>支持button的基本事件 — click, focus,mouseover等 — 属性绑定</p></li><li><p>可以是基础按钮，可以是链接 — theme</p></li><li><p>可以有不同的等级 — level</p></li><li><p>可以改变大小 — size</p></li><li><p>可以禁用 — diabled</p></li><li><p>加载状态 — loading</p></li></ul><h3 id="用户怎么用该组件"><a href="#用户怎么用该组件" class="headerlink" title="用户怎么用该组件"></a>用户怎么用该组件</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">x-button</span> </span></span><br><span class="line"><span class="tag">  @<span class="attr">click</span>=<span class="string">?</span> </span></span><br><span class="line"><span class="tag">  @<span class="attr">focus</span>=<span class="string">?</span> </span></span><br><span class="line"><span class="tag">  @<span class="attr">mouseover</span>=<span class="string">?</span></span></span><br><span class="line"><span class="tag">  <span class="attr">theme</span>=<span class="string">&quot;default or primary or link&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">level</span>=<span class="string">&quot;nomal or info or warning or success or danger&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">size</span>=<span class="string">&quot;mini or small or normal or large&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">disabled</span></span></span><br><span class="line"><span class="tag">  <span class="attr">loading</span></span></span><br><span class="line"><span class="tag">&gt;</span><span class="tag">&lt;/<span class="name">x-button</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Vue3笔记"><a href="#Vue3笔记" class="headerlink" title="Vue3笔记"></a>Vue3笔记</h2><h3 id="属性绑定"><a href="#属性绑定" class="headerlink" title="属性绑定"></a>属性绑定</h3><h4 id="非Prop-属性继承"><a href="#非Prop-属性继承" class="headerlink" title="非Prop 属性继承"></a>非Prop 属性继承</h4><p><a href="https://vue3js.cn/docs/zh/guide/component-attrs.html">参考文档</a></p><ul><li>如果父组件传给子组件的属性，子组件中没有相应 <code>props</code>或 <code>emits</code>定义，则这些属性被称为<strong>非Prop属性</strong></li><li>当组件<strong>返回单个根节点</strong>时，<code>Vue3</code>会默认将所有非 prop属性绑定到子组件的根元素。</li></ul><p>基于此特性，父组件中绑定的事件可以直接传至子组件，因此可以初步实现button组件对事件的支持，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父组件</span></span><br><span class="line">&lt;template&gt; </span><br><span class="line">  &lt;x-button @click=<span class="string">&quot;clickButton&quot;</span></span><br><span class="line">      @focus=<span class="string">&quot;clickButton&quot;</span></span><br><span class="line">      @mouseover=<span class="string">&quot;clickButton&quot;</span>&gt;</span><br><span class="line">    点我</span><br><span class="line">  &lt;/x-button&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script lang=<span class="string">&quot;ts&quot;</span>&gt;</span><br><span class="line"><span class="keyword">import</span> XButton <span class="keyword">from</span> <span class="string">&quot;../lib/Button.vue&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  components: &#123; Button &#125;,</span><br><span class="line">  <span class="function"><span class="title">setup</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> clickButton = <span class="function">()=&gt;</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;clickButton&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- button 组件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;x-button-dv&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;x-button&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">slot</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="禁用属性继承"><a href="#禁用属性继承" class="headerlink" title="禁用属性继承"></a>禁用属性继承</h4><p>从上面的代码中，不难发现一个问题——button组件的事件其实应该绑定给<code>&lt;button/&gt;</code>元素而不是其根元素；而事件之外的其他属性需绑定给根元素。解决这些问题的思路如下：</p><ul><li>通过将 <code>inheritAttrs</code> 选项设置为 <code>false</code>，禁用非prop属性的继承</li><li>获取传来的属性，通过<code>v-bind</code>将事件绑定给<code>&lt;button/&gt;</code>元素</li><li>将其余属性绑定给根元素</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;x-button-dv&quot;</span> :size=<span class="string">&quot;size&quot;</span>&gt;</span><br><span class="line">    &lt;button <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;x-button&quot;</span> v-bind=<span class="string">&quot;rest&quot;</span>&gt;</span><br><span class="line">      &lt;slot&gt;&lt;/slot&gt;</span><br><span class="line">    &lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  name: <span class="string">&#x27;x-button&#x27;</span>,</span><br><span class="line">  inheritAttrs: <span class="literal">false</span>,</span><br><span class="line">  setup (props, context) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; size, ...rest &#125; = context.attrs <span class="comment">// 将事件绑定给button，其余属性绑定给外层div</span></span><br><span class="line">    <span class="keyword">return</span> &#123; size, rest &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="props-V-S-attrs"><a href="#props-V-S-attrs" class="headerlink" title="props  V.S.  attrs"></a>props  V.S.  attrs</h3><ul><li>props要先声明才能取值，attrs不用声明</li><li>当props声明了属性时，该属性不能在attrs里面取到</li><li>props不包含事件，attrs包含</li><li>当属性的数据类型为Booalen时，必须要给该属性绑定value，否则attrs中为空字符串</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 父组件</span><br><span class="line"><span class="tag">&lt;<span class="name">x-button</span> <span class="attr">size</span>=<span class="string">&quot;small&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">disabled</span></span></span><br><span class="line"><span class="tag">              <span class="attr">:multiple</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">              @<span class="attr">click</span>=<span class="string">&quot;clickButton&quot;</span></span></span><br><span class="line"><span class="tag">              @<span class="attr">mouseenter</span>=<span class="string">&quot;clickButton&quot;</span></span></span><br><span class="line"><span class="tag">              @<span class="attr">focus</span>=<span class="string">&quot;clickButton&quot;</span>&gt;</span></span><br><span class="line">      点我</span><br><span class="line"><span class="tag">&lt;/<span class="name">x-button</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 子组件</span></span><br><span class="line"> props: &#123;</span><br><span class="line">    size: &#123;</span><br><span class="line">      type: <span class="built_in">String</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  setup (props, context) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(    &#123;...props&#125;)</span><br><span class="line">    <span class="built_in">console</span>.log(    &#123;...context.attrs&#125;)</span><br><span class="line">    <span class="keyword">const</span> &#123; size, ...rest &#125; = context.attrs <span class="comment">// 将事件绑定给button，其余属性绑定给外层div</span></span><br><span class="line">    <span class="keyword">return</span> &#123; size, rest &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><img src="/images/vue3-button/props-vs-attrs.png" alt="输出结果"></p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h3 id="css影响最小原则"><a href="#css影响最小原则" class="headerlink" title="css影响最小原则"></a>css影响最小原则</h3><p><strong>CSS 绝对不能影响库使用者</strong></p><ul><li>尽量不使用 scoped<br>因为 data-v-xxx 中的 xxx 每次运行可能不同<br>必须输出稳定不变的 class 选择器，方便使用者覆盖</li><li>必须加前缀，不容易被使用者覆盖</li></ul><h3 id="css写loading动画"><a href="#css写loading动画" class="headerlink" title="css写loading动画"></a>css写loading动画</h3><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.xx-loadingIndicator</span>&#123;</span><br><span class="line"> <span class="variable">$main-theme-color</span>: <span class="number">#87dfd6</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">14px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">14px</span>;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">  <span class="attribute">margin-right</span>: <span class="number">4px</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">14px</span>;</span><br><span class="line">  <span class="attribute">border-color</span>: <span class="variable">$main-theme-color</span> <span class="variable">$main-theme-color</span> <span class="variable">$main-theme-color</span> transparent;</span><br><span class="line">  <span class="attribute">border-style</span>: solid;</span><br><span class="line">  <span class="attribute">border-width</span>: <span class="number">2px</span>;</span><br><span class="line">  <span class="attribute">animation</span>: xx-spin <span class="number">1s</span> infinite linear;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@keyframes</span> xx-spin &#123;</span><br><span class="line">  0% &#123; <span class="attribute">transform</span>: rotate(<span class="number">0deg</span>) &#125;</span><br><span class="line">  <span class="number">100%</span> &#123; transform: rotate(<span class="number">360deg</span>) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>Vue 属性继承<ul><li>默认属性传给根元素</li><li><code>inheritAttrs: false</code> 禁用属性继承</li><li><code>v-bind=&quot;$attrs&quot;</code>绑定属性， <code> context.attrs</code>获取属性</li></ul></li><li>props V.S. attrs</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;效果预览&quot;&gt;&lt;a href=&quot;#效果预览&quot; class=&quot;headerlink&quot; title=&quot;效果预览&quot;&gt;&lt;/a&gt;效果预览&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/images/vue3-button/button.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;htt</summary>
      
    
    
    
    <category term="Vue" scheme="https://amiemie906.gitee.io/categories/Vue/"/>
    
    <category term="Vue3" scheme="https://amiemie906.gitee.io/categories/Vue/Vue3/"/>
    
    
    <category term="Vue" scheme="https://amiemie906.gitee.io/tags/Vue/"/>
    
    <category term="Vue3" scheme="https://amiemie906.gitee.io/tags/Vue3/"/>
    
    <category term="造轮子" scheme="https://amiemie906.gitee.io/tags/%E9%80%A0%E8%BD%AE%E5%AD%90/"/>
    
  </entry>
  
  <entry>
    <title>Vue3造轮子（一）-Switch组件</title>
    <link href="https://amiemie906.gitee.io/2021/02/20/Vue3-1-switch/"/>
    <id>https://amiemie906.gitee.io/2021/02/20/Vue3-1-switch/</id>
    <published>2021-02-20T15:25:49.000Z</published>
    <updated>2021-04-01T02:49:57.760Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><a href="%5Bwuyangqin.github.io/xing-ui/%5D(https://wuyangqin.github.io/xing-ui/)">UI造轮子Vue2版</a>官网初步部署上线了，决定暂时告一段落，先学习Vue3的造轮子课。这个阶段的学习总结以Vue3新特性为主，以及这其中踩到的坑，节奏依然是写轮子–&gt;看文档–&gt;写总结，然后会将Vue3的学习笔记做一个整体的总结。加油~(ง •_•)ง</p><h2 id="效果预览"><a href="#效果预览" class="headerlink" title="效果预览"></a>效果预览</h2><p><img src="/images/vue3-switch/switch.gif"></p><p><a href="https://github.com/wuyangqin/xing-ui-v3">代码链接</a></p><p><a href="https://github.com/wuyangqin/xing-ui-v3/commits/d221188bd2dc987cb169aeb66fe5a060b2283a02">提交历史</a></p><h2 id="API设计"><a href="#API设计" class="headerlink" title="API设计"></a>API设计</h2><h3 id="value"><a href="#value" class="headerlink" title="value"></a>value</h3><ul><li>组件内部，用<code>value</code>控制开关的开与关 — <code>computed</code>计算属性控制开关状态的样式</li><li><code>value</code>应该是由父组件传入 — 父组件用<code>ref</code>声明变量，子组件用<code>props</code>接受值（父子通信）</li><li>当父组件调用该子组件时，应该知道当前子组件的状态 — <code>v-model</code>实现父子双向绑定</li></ul><h3 id="disable-loading"><a href="#disable-loading" class="headerlink" title="disable loading"></a>disable loading</h3><ul><li>disable 禁用属性，loading，加载状态，处在该状态下开关无法进行操作</li><li>样式类型的属性，因此也是使用<code>computed</code>计算属性控制样式</li></ul><h2 id="Vue3笔记"><a href="#Vue3笔记" class="headerlink" title="Vue3笔记"></a>Vue3笔记</h2><h3 id="组件注册"><a href="#组件注册" class="headerlink" title="组件注册"></a>组件注册</h3><h4 id="Vue2-x"><a href="#Vue2-x" class="headerlink" title="Vue2.x"></a>Vue2.x</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  render: <span class="function"><span class="params">h</span> =&gt;</span> h(App)</span><br><span class="line">&#125;).$mount(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure><h4 id="Vue3-x"><a href="#Vue3-x" class="headerlink" title="Vue3.x"></a>Vue3.x</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line"><span class="keyword">const</span> app = createApp(App)</span><br><span class="line">app.mount(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="Composition-API（组合式API）"><a href="#Composition-API（组合式API）" class="headerlink" title="Composition API（组合式API）"></a>Composition API（组合式API）</h3><h4 id="为什么"><a href="#为什么" class="headerlink" title="为什么"></a>为什么</h4><p>总结一下就是：<strong>避免逻辑关注点过于碎片化，</strong>提高代码的可读性和可维护性。</p><p>在Vue2中，我们如果要实现一个需求，那么这些逻辑会被分散在data、methods、computed等各个<code>Options API</code>，而在Vue3中，我们可以将同一个需求的各个逻辑模块整合起来，放在<code>Composition API</code>。如果用颜色来区分各个逻辑块，那么下图可以直观地展示这种区别。</p><p><img src="/images/vue3-switch/composition.png"></p><h4 id="setup"><a href="#setup" class="headerlink" title="setup"></a>setup</h4><ul><li><p>一个接受<code>props</code>和<code>context</code>的函数，从<code>setup</code>返回的内容都将暴露给组件的其余部分</p><ul><li>props: 传入组件的属性:setup 中接收的<code>props</code>是响应式的， 当传入新的 props 时，会及时被更新。由于是响应式的， 所以<strong>不可以使用 ES6 解构</strong>，解构会消除它的响应式</li><li>context：暴露<code>attrs</code>、<code>slots</code>、<code>emit</code>这三个组件的property</li></ul></li><li><p>在<strong>创建组件之前</strong>，初始化 props 之后调用执行，因此<code>setup</code>中无法访问组件实例<code>this</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="title">beforeCreate</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;beforeCreate&#x27;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">created</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;created&#x27;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;mounted&#x27;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  setup (props, context) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;setup&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// setup</span></span><br><span class="line"><span class="comment">// beforeCreate</span></span><br><span class="line"><span class="comment">// created</span></span><br><span class="line"><span class="comment">// mounted</span></span><br></pre></td></tr></table></figure></li><li><p>我刚开始使用<code>setup</code>的时候，也产生过疑惑，这样不是将所有的代码都塞到<code>setup</code>里面，让它变得非常庞大臃肿吗？官方文档给出了解决方案——将各逻辑模块分别提取到独立的<a href="https://vue3js.cn/docs/zh/guide/composition-api-introduction.html#%E7%8B%AC%E7%AB%8B%E7%9A%84-computed-%E5%B1%9E%E6%80%A7"><strong>组合式函数</strong></a></p></li></ul><h4 id="带ref-的响应式变量-响应式引用"><a href="#带ref-的响应式变量-响应式引用" class="headerlink" title="带ref 的响应式变量 (响应式引用)"></a>带ref 的响应式变量 (响应式引用)</h4><ul><li><p>在setup中直接声明的变量是非响应式的，因此需引入<code>ref</code>函数</p></li><li><p><code>ref</code>接受参数并返回一个<a href="https://juejin.cn/post/6844904041357508615">包装对象</a>，包装对象具有 <code>value</code> property ，可使用该 property 访问或更改响应式变量的值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ref &#125; form <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> visible = ref(<span class="literal">false</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(visible) <span class="comment">// &#123; value: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(visible.value) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">visible.value = <span class="literal">true</span></span><br><span class="line"><span class="built_in">console</span>.log(visible.value) <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><a href="https://juejin.cn/post/6844904042242523144#heading-4">为什么要返回一个包装对象</a>?</p><p>提供一个让我们能够在函数之间以引用的方式传递任意类型值的容器。这个容器可以在封装了逻辑的组合函数中将状态以引用的方式传回给组件。组件负责展示（追踪依赖），组合函数负责管理状态（触发更新）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">setup</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> valueA = useLogicA() <span class="comment">// valueA 可能被 useLogicA() 内部的代码修改从而触发更新</span></span><br><span class="line">  <span class="keyword">const</span> valueB = useLogicB()</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    valueA,</span><br><span class="line">    valueB</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 作者：摸鱼架构师</span></span><br><span class="line"><span class="comment">// 链接：https://juejin.cn/post/6844904042242523144</span></span><br><span class="line"><span class="comment">// 来源：掘金</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="toRefs"><a href="#toRefs" class="headerlink" title="toRefs"></a>toRefs</h4><p>解构的同时保持<code>props</code>内部变量的响应式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; toRefs &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="function"><span class="title">setup</span>(<span class="params">props</span>)</span>&#123;</span><br><span class="line"><span class="keyword">const</span> &#123; user &#125; = toRefs(props)</span><br><span class="line">    consloe.log(user.value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="computed属性"><a href="#computed属性" class="headerlink" title="computed属性"></a>computed属性</h4><ul><li><p>使用从 Vue 导入的 <code>computed</code> 函数在 Vue 组件外部创建计算属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ref, computed &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> counter = ref(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">const</span> twiceTheCounter = computed(<span class="function">() =&gt;</span> counter.value * <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">counter.value++</span><br><span class="line"><span class="built_in">console</span>.log(counter.value) <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(twiceTheCounter.value) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure></li><li><p><code>computed</code>函数返回一个<em>只读</em>的<strong>响应式引用</strong>，由一个作为 <code>computed</code> 的第一个参数传递的 getter 类回调输出。为了访问新创建的计算变量的 <strong>value</strong>，我们需要像使用 <code>ref</code> 一样使用 <code>.value</code> property。</p></li></ul><h3 id="v-model"><a href="#v-model" class="headerlink" title="v-model"></a>v-model</h3><h4 id="使用-value和-input进行父子组件双向通信"><a href="#使用-value和-input进行父子组件双向通信" class="headerlink" title="使用:value和@input进行父子组件双向通信"></a>使用:value和@input进行父子组件双向通信</h4><p>其实<code>v-model</code>就是一个语法糖，我们可以先拆解出来它具体做了什么，以switch组件为例：</p><p><img src="/images/vue3-switch/props-emit.png"></p><p>父组件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;x-<span class="keyword">switch</span> :value=<span class="string">&quot;checked&quot;</span> @input=<span class="string">&quot;visible = $event&quot;</span>&gt;&lt;/x-<span class="keyword">switch</span>&gt;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"> setup () &#123;</span><br><span class="line">   <span class="keyword">const</span> checked = ref(<span class="literal">false</span>)</span><br><span class="line">   <span class="keyword">const</span> toggle = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">     checked.value = !checked.value</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> &#123; checked, toggle &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>子组件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line">setup (props, context) &#123;</span><br><span class="line">  <span class="keyword">const</span> toggle = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    context.emit(<span class="string">&#x27;input&#x27;</span>, !props.value)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123; toggle &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Vue2的v-model"><a href="#Vue2的v-model" class="headerlink" title="Vue2的v-model"></a>Vue2的v-model</h4><ul><li><p>Vue2.x中，在组件上使用 <code>v-model</code> 相当于绑定 <code>value</code> prop 和 <code>input</code> 事件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">x-switch</span> <span class="attr">v-model</span>=<span class="string">&quot;checked&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 简写: --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">x-switch</span> <span class="attr">:value</span>=<span class="string">&quot;checked&quot;</span> @<span class="attr">input</span>=<span class="string">&quot;checked = $event&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>如果想更改绑定的属性名，或绑定多个变量，可使用<code>.sync</code></p><p>子组件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.$emit(<span class="string">&#x27;update:value&#x27;</span>, newValue)</span><br></pre></td></tr></table></figure><p>父组件：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">x-switch</span> <span class="attr">:value.sync</span>=<span class="string">&quot;checked&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="Vue3的v-model"><a href="#Vue3的v-model" class="headerlink" title="Vue3的v-model"></a>Vue3的v-model</h4><ul><li>属性名任意，假设为 x</li><li>事件名必须为 <code>&#39;update:x&#39;</code></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">x-switch</span> <span class="attr">v-model:value</span>=<span class="string">&quot;checked&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 简写: --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">x-switch</span> <span class="attr">:value</span>=<span class="string">&quot;checked&quot;</span> @<span class="attr">update:value</span>=<span class="string">&quot;checked = $event&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>使用 ref 创建内部数据</li><li>使用 :value 和 @input 让父子组件进行交流(组件通信)</li><li>使用 v-model</li><li>Vue 2 和 Vue 3 的区别<ul><li>新 <code>v-model:prop</code> 代替以前的 <code>v-model</code> 和 <code>.sync</code></li><li>新增 context.emit，与 this.$emit 作用相同</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;%5Bwuyangqin.github.io/xing-ui/%5D(https://wuyangqin.github.i</summary>
      
    
    
    
    <category term="Vue" scheme="https://amiemie906.gitee.io/categories/Vue/"/>
    
    <category term="Vue3" scheme="https://amiemie906.gitee.io/categories/Vue/Vue3/"/>
    
    
    <category term="Vue" scheme="https://amiemie906.gitee.io/tags/Vue/"/>
    
    <category term="Vue3" scheme="https://amiemie906.gitee.io/tags/Vue3/"/>
    
    <category term="造轮子" scheme="https://amiemie906.gitee.io/tags/%E9%80%A0%E8%BD%AE%E5%AD%90/"/>
    
  </entry>
  
  <entry>
    <title>iOS正则兼容，报错safari invalid regular expression</title>
    <link href="https://amiemie906.gitee.io/2020/11/30/keng-ios-reg/"/>
    <id>https://amiemie906.gitee.io/2020/11/30/keng-ios-reg/</id>
    <published>2020-11-30T13:09:49.000Z</published>
    <updated>2021-03-25T10:01:54.204Z</updated>
    
    <content type="html"><![CDATA[<h3 id="情景复现"><a href="#情景复现" class="headerlink" title="情景复现"></a>情景复现</h3><p>今天在项目中发现Android显示正常，而iOS显示一片空白，用safari打开后发现报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Invalid regular expression: invalid group specifier name</span><br></pre></td></tr></table></figure><p><img src="/images/ios-reg-error.png"></p><h3 id="排查原因及解决"><a href="#排查原因及解决" class="headerlink" title="排查原因及解决"></a>排查原因及解决</h3><p>谷歌后得到<a href="https://stackoverflow.com/questions/51568821/works-in-chrome-but-breaks-in-safari-invalid-regular-expression-invalid-group">stackoverflow</a>的答案：safari，firefox的正则表达式不支持<code>?&lt;=、?&lt;!、?!、?= </code>等表达，而我在项目中为了根据特定字符截取字符串中间部分，使用了如下正则：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> matchNameReg = <span class="regexp">/(?&lt;=name=&quot;).*?(?=&quot;)/</span></span><br></pre></td></tr></table></figure><p>因此只能采取替代方案，用<code>split</code>分割字符串。修改后报错解决。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;情景复现&quot;&gt;&lt;a href=&quot;#情景复现&quot; class=&quot;headerlink&quot; title=&quot;情景复现&quot;&gt;&lt;/a&gt;情景复现&lt;/h3&gt;&lt;p&gt;今天在项目中发现Android显示正常，而iOS显示一片空白，用safari打开后发现报错：&lt;/p&gt;
&lt;figure cla</summary>
      
    
    
    
    <category term="踩坑记" scheme="https://amiemie906.gitee.io/categories/%E8%B8%A9%E5%9D%91%E8%AE%B0/"/>
    
    <category term="移动端" scheme="https://amiemie906.gitee.io/categories/%E8%B8%A9%E5%9D%91%E8%AE%B0/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"/>
    
    
    <category term="踩坑记" scheme="https://amiemie906.gitee.io/tags/%E8%B8%A9%E5%9D%91%E8%AE%B0/"/>
    
    <category term="移动端" scheme="https://amiemie906.gitee.io/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"/>
    
    <category term="正则" scheme="https://amiemie906.gitee.io/tags/%E6%AD%A3%E5%88%99/"/>
    
  </entry>
  
  <entry>
    <title>简单实现一个ajax</title>
    <link href="https://amiemie906.gitee.io/2020/10/02/js-ajax/"/>
    <id>https://amiemie906.gitee.io/2020/10/02/js-ajax/</id>
    <published>2020-10-02T05:50:01.000Z</published>
    <updated>2021-04-02T03:32:01.658Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ajax"><a href="#ajax" class="headerlink" title="ajax"></a>ajax</h2><h2 id="什么是Ajax"><a href="#什么是Ajax" class="headerlink" title="什么是Ajax"></a>什么是Ajax</h2><p>ajax:前后端分离后，都是后台通过接口返回数据，前端需要通过接口访问数据。那么这个通过接口访问后台数据的过程就叫ajax。</p><blockquote><p>简单来说就是用 JS 向服务端发起一个请求，并获取服务器返回的内容</p></blockquote><p>参考 ：<a href="https://zhuanlan.zhihu.com/p/22564745">https://zhuanlan.zhihu.com/p/22564745</a></p><h2 id="ajax-步骤"><a href="#ajax-步骤" class="headerlink" title="ajax 步骤"></a>ajax 步骤</h2><ol><li>买手机  –&gt;  创建ajax对象</li><li>拨号  –&gt;   链接url接口地址  设置传输数据方法：get和post<ul><li>get和post的区别：一般get获取数据，而post发送数据<ul><li>get发送数据最多为2kb，post理论上没有限制，但不同浏览器有不同限制</li><li>get发送数据在url地址 post在消息内发送数据</li><li>get有缓存，相对不安全；post没有，相对安全</li><li>get方式和post方式传递的数据在服务端获取也不相同</li></ul></li></ul></li><li>说 –&gt; 发送数据参数</li><li>听  –&gt;  接收返回的数据，并渲染到html页面</li></ol><h2 id="简单实现"><a href="#简单实现" class="headerlink" title="简单实现"></a>简单实现</h2><h3 id="get"><a href="#get" class="headerlink" title="get"></a>get</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> oAjax = <span class="keyword">new</span> XMLHttpRequest();<span class="comment">//创建ajax对象</span></span><br><span class="line">oAjax.open(<span class="string">&#x27;get&#x27;</span>,<span class="string">&#x27;arr.txt&#x27;</span>);<span class="comment">//链接地址  设置请求的方法</span></span><br><span class="line">oAjax.send();<span class="comment">//发送数据参数</span></span><br><span class="line">oAjax.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="comment">//页面注册事件更新</span></span><br><span class="line">    <span class="keyword">if</span>(oAjax.readyState == <span class="number">4</span>)&#123;<span class="comment">//ajax执行状态码</span></span><br><span class="line">        <span class="keyword">if</span>(oAjax.status == <span class="number">200</span>)&#123;<span class="comment">//http状态码 200 说明一切ok</span></span><br><span class="line">            <span class="keyword">var</span> data = oAjax.responseText;</span><br><span class="line">            <span class="comment">// 异步获取数据  后续操作  都得写在这  可以封装函数传参 将data传出去</span></span><br><span class="line">            <span class="comment">// console.log(typeof data);//string</span></span><br><span class="line">            <span class="comment">// 将具有js格式的字符串 转换为js代码或数据</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="post"><a href="#post" class="headerlink" title="post"></a>post</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> oAjax = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">oAjax.open(<span class="string">&#x27;post&#x27;</span>,<span class="string">&#x27;aaa.txt&#x27;</span>);</span><br><span class="line">oAjax.setRequestHeader(<span class="string">&#x27;Content-type&#x27;</span>,<span class="string">&#x27;application/x-www-form-urlencoded&#x27;</span>);<span class="comment">//设置请求头传输数据的类型编码方式</span></span><br><span class="line"></span><br><span class="line">oAjax.send();</span><br><span class="line"></span><br><span class="line">oAjax.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="comment">//页面注册事件更新</span></span><br><span class="line">    <span class="keyword">if</span>(oAjax.readyState == <span class="number">4</span>)&#123;<span class="comment">//ajax执行状态码</span></span><br><span class="line">        <span class="keyword">if</span>(oAjax.status == <span class="number">200</span>)&#123;<span class="comment">//http状态码 200 说明一切ok</span></span><br><span class="line">            <span class="built_in">console</span>.log(oAjax.responseText);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="readyState-ajax执行状态码"><a href="#readyState-ajax执行状态码" class="headerlink" title="readyState ajax执行状态码"></a>readyState ajax执行状态码</h3><ul><li>0：初始化   还没有调用open()方法</li><li>1： 载入  已调用send()方法，正在发送请求</li><li>2： 载入完成   send()方法完成，已收到全部相应内容</li><li>3： 解析  正在解析相应内容</li><li>4： 完成   响应内容解析完成，可以在客户端使用了</li></ul><h3 id="status-http状态码"><a href="#status-http状态码" class="headerlink" title="status http状态码"></a>status http状态码</h3><ul><li>100-199 Infromationale responses 接受请求</li><li>200-299 Successful responses 成功响应</li><li>300-399 Redirects 重定向</li><li>400-499 Client errors 客户端错误</li><li>500-599 Sever errors 服务端错误</li></ul><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">//封装一个ajax请求</span></span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">ajax</span>(<span class="params">options</span>)</span>&#123;</span><br><span class="line">     <span class="comment">//创建XMLHttpRequest对象</span></span><br><span class="line">     <span class="keyword">var</span> request = <span class="built_in">window</span>.XMLHttpRequest ? <span class="keyword">new</span> XMLHttpRequest : <span class="keyword">new</span> ActiveXObject()</span><br><span class="line"></span><br><span class="line">     <span class="comment">//初始化参数的内容</span></span><br><span class="line">     options = options ||&#123;&#125;</span><br><span class="line">     options.type = (options.type ||<span class="string">&#x27;GET&#x27;</span>).toUpperCase()</span><br><span class="line">     options.dataType = options.dataType || <span class="string">&#x27;json&#x27;</span></span><br><span class="line">     <span class="keyword">var</span> params = options.data</span><br><span class="line"></span><br><span class="line">     <span class="comment">//发送请求</span></span><br><span class="line">     <span class="keyword">if</span>(options.type == <span class="string">&#x27;GET&#x27;</span>)&#123;</span><br><span class="line">       request.open(<span class="string">&#x27;GET&#x27;</span>,options.url + <span class="string">&#x27;?&#x27;</span> + params,<span class="literal">true</span>)</span><br><span class="line">       request.send(<span class="literal">null</span>)</span><br><span class="line">     &#125;<span class="keyword">else</span> <span class="keyword">if</span>(options.type == <span class="string">&#x27;POST&#x27;</span>)&#123;</span><br><span class="line">       request.open(<span class="string">&#x27;POST&#x27;</span>,options.url,<span class="literal">true</span>)</span><br><span class="line">       request.setRequestHeader(<span class="string">&#x27;Content-Type&#x27;</span>, <span class="string">&quot;application/x-www-form-urlencoded&quot;</span>)<span class="comment">//规定输出为键值对的形式</span></span><br><span class="line">       request.send(params)</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//接收请求</span></span><br><span class="line">     request.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(request.readyState == <span class="number">4</span>)&#123;</span><br><span class="line">         <span class="keyword">var</span> status = request.status</span><br><span class="line">         <span class="keyword">if</span> (status &gt;= <span class="number">200</span> &amp;&amp; status &lt; <span class="number">300</span>)&#123;</span><br><span class="line">           options.success &amp;&amp; options.success(request.responseText,request.responseXML)</span><br><span class="line">         &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">           options.fail &amp;&amp;options.fail(status)</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;  </span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line">   ajax(&#123;</span><br><span class="line">     type: <span class="string">&#x27;post&#x27;</span>,</span><br><span class="line">     dataType: <span class="string">&#x27;json&#x27;</span>,</span><br><span class="line">     data: &#123;&#125;,</span><br><span class="line">     url: <span class="string">&#x27;xxx&#x27;</span>,</span><br><span class="line">     success: <span class="function"><span class="keyword">function</span>(<span class="params">text,xml</span>)</span>&#123;<span class="comment">//请求成功后的回调函数</span></span><br><span class="line">       <span class="built_in">console</span>.log(text)</span><br><span class="line">     &#125;,</span><br><span class="line">     fail: <span class="function"><span class="keyword">function</span>(<span class="params">status</span>)</span>&#123;<span class="comment">////请求失败后的回调函数</span></span><br><span class="line">       <span class="built_in">console</span>.log(status)</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;ajax&quot;&gt;&lt;a href=&quot;#ajax&quot; class=&quot;headerlink&quot; title=&quot;ajax&quot;&gt;&lt;/a&gt;ajax&lt;/h2&gt;&lt;h2 id=&quot;什么是Ajax&quot;&gt;&lt;a href=&quot;#什么是Ajax&quot; class=&quot;headerlink&quot; title=&quot;什么是</summary>
      
    
    
    
    <category term="JavaScript" scheme="https://amiemie906.gitee.io/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="https://amiemie906.gitee.io/tags/JavaScript/"/>
    
    <category term="ajax" scheme="https://amiemie906.gitee.io/tags/ajax/"/>
    
  </entry>
  
  <entry>
    <title>函数节流与函数防抖</title>
    <link href="https://amiemie906.gitee.io/2020/10/02/js-throttle-and-debounce/"/>
    <id>https://amiemie906.gitee.io/2020/10/02/js-throttle-and-debounce/</id>
    <published>2020-10-02T03:21:34.000Z</published>
    <updated>2021-04-02T02:09:51.190Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是函数节流与函数防抖"><a href="#什么是函数节流与函数防抖" class="headerlink" title="什么是函数节流与函数防抖"></a>什么是函数节流与函数防抖</h2><ul><li>函数节流：指定时间间隔内只会执行一次任务</li><li>函数防抖:   事件被触发n秒后，任务才会执行，如果n秒内再次被触发，则重新计时。</li></ul><p>举个🌰，我的理解中，节流就相当于技能冷却时间，每隔一段时间才能释放一次技能，冷却过程中不管多想放技能都无济于事；而防抖相当于外卖员等一段时间没有新的外卖，就将手上的外卖一起派送一次，期间如果来了新的外卖，就抛弃这次送外卖的想法，重新等待。</p><p>那么为什么需要节流与防抖呢？</p><p>总得来说就是要<strong>限制函数调用的频次，优化性能</strong>。</p><p>js中的一些事件如浏览器的resize、scroll，鼠标的mousemove、mouseover，input输入框的keypress等事件在触发时，会不断地调用绑定在事件上的回调函数，极大地浪费资源，降低前端性能。为了优化体验，就需要对这类事件进行调用次数的限制。</p><h2 id="简单实现"><a href="#简单实现" class="headerlink" title="简单实现"></a>简单实现</h2><h3 id="函数节流-throttle"><a href="#函数节流-throttle" class="headerlink" title="函数节流(throttle)"></a>函数节流(throttle)</h3><p>根据节流的理念，可以先梳理其实现逻辑：</p><p><img src="/images/js/throttle.png"></p><p>代码实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn, delay</span>)</span>&#123;</span><br><span class="line">     <span class="keyword">let</span> canRun = <span class="literal">true</span></span><br><span class="line">     <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(canRun)&#123;</span><br><span class="line">             fn.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>)</span><br><span class="line">             canRun= <span class="literal">false</span></span><br><span class="line">             <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>canRun = <span class="literal">true</span>, delay)</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">const</span> throttled = throttle(<span class="function">()=&gt;</span><span class="built_in">console</span>.log(<span class="string">&#x27;hi&#x27;</span>))</span><br><span class="line"> throttled()</span><br><span class="line"> throttled()</span><br></pre></td></tr></table></figure><h3 id="函数防抖-debounce"><a href="#函数防抖-debounce" class="headerlink" title="函数防抖(debounce)"></a>函数防抖(debounce)</h3><p>防抖的逻辑梳理如下：</p><p><img src="/images/js/debounce.png"></p><p>代码实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, delay</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timerId = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> context = <span class="built_in">this</span>  <span class="comment">// 取debounce执行作用域的this</span></span><br><span class="line">        <span class="keyword">if</span>(timerId)&#123;<span class="built_in">window</span>.clearTimeout(timerId)&#125;</span><br><span class="line">        timerId = <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">            fn.apply(context, <span class="built_in">arguments</span>)</span><br><span class="line">            timerId = <span class="literal">null</span></span><br><span class="line">        &#125;,delay)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> debounced = debounce(<span class="function">()=&gt;</span><span class="built_in">console</span>.log(<span class="string">&#x27;hi&#x27;</span>))</span><br><span class="line">debounced()</span><br><span class="line">debounced()</span><br></pre></td></tr></table></figure><h2 id="区别与应用场景"><a href="#区别与应用场景" class="headerlink" title="区别与应用场景"></a>区别与应用场景</h2><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ul><li>防抖侧重于一段时间内连续触发的事件，只在最后执行一次</li><li>节流侧重于每隔固定的一段时间只执行一次</li></ul><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>节流 throttle</p><ul><li>高频点击提交，表单重复提交</li><li>监听滚动事件，加载更多或滚到底部监听</li></ul><p>防抖 debounce</p><ul><li>搜索联想，只需等用户最后一次输入完再发送请求</li><li>手机、邮箱等验证时，进行输入检测</li><li>resize事件，等用户最后一次调整完浏览器大小再执行</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>函数节流与函数防抖的原理其实非常简单，巧妙地使用 <code>setTimeout</code> 来存放待执行的函数，这样可以很方便的利用 <code>clearTimeout</code> 在合适的时机来清除待执行的函数。</p><p>使用函数节流与函数防抖的目的，就是为了限制函数调用的频次，节约计算机资源。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/6844903669389885453#heading-7">https://juejin.cn/post/6844903669389885453#heading-7</a></p><p><a href="https://juejin.cn/post/6844903926798516237">https://juejin.cn/post/6844903926798516237</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;什么是函数节流与函数防抖&quot;&gt;&lt;a href=&quot;#什么是函数节流与函数防抖&quot; class=&quot;headerlink&quot; title=&quot;什么是函数节流与函数防抖&quot;&gt;&lt;/a&gt;什么是函数节流与函数防抖&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;函数节流：指定时间间隔内只会执行一次任务&lt;/li</summary>
      
    
    
    
    <category term="JavaScript" scheme="https://amiemie906.gitee.io/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="https://amiemie906.gitee.io/tags/JavaScript/"/>
    
    <category term="性能优化" scheme="https://amiemie906.gitee.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>this的值是什么？</title>
    <link href="https://amiemie906.gitee.io/2020/09/30/js-this/"/>
    <id>https://amiemie906.gitee.io/2020/09/30/js-this/</id>
    <published>2020-09-30T14:12:57.000Z</published>
    <updated>2021-04-02T03:41:32.342Z</updated>
    
    <content type="html"><![CDATA[<h2 id="this是什么"><a href="#this是什么" class="headerlink" title="this是什么"></a>this是什么</h2><p>当声明一个函数时，函数会有一个this（指针），声明时this不指向任何对象。当函数被调用时，哪个对象调用了该函数，则该函数的this就指向该对象</p><ul><li><p>当事件驱动时，结果匿名函数的this就指向触发事件的对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">oDiv.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="comment">//this --&gt; oDiv</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>普通命名函数被调用时，函数的this指向全局对象window</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">&#125;</span><br><span class="line">fn(); <span class="comment">//window</span></span><br><span class="line"><span class="comment">// window 是js的全局对象</span></span><br></pre></td></tr></table></figure></li><li><p>对象中定义的函数的this就指向该对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj=&#123;</span><br><span class="line">name: <span class="string">&#x27;John&#x27;</span>,</span><br><span class="line">age:<span class="number">19</span>;</span><br><span class="line">eat:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.eat();<span class="comment">// object</span></span><br><span class="line"><span class="keyword">var</span> fnn = obj.eat;</span><br><span class="line">  fnn();<span class="comment">// this--&gt; window</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="this的值是什么？"><a href="#this的值是什么？" class="headerlink" title="this的值是什么？"></a>this的值是什么？</h2><p><strong>谁调用函数，函数的this就指向谁</strong></p><p><strong>就近原则</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">fn()</span><br><span class="line"><span class="built_in">this</span> =&gt; <span class="built_in">window</span>/<span class="built_in">global</span></span><br><span class="line">obj.fn()</span><br><span class="line"><span class="built_in">this</span> =&gt; obj</span><br><span class="line">fn.call(xx)</span><br><span class="line"><span class="built_in">this</span> =&gt; xx</span><br><span class="line">fn.apply(xx)</span><br><span class="line"><span class="built_in">this</span> =&gt; xx</span><br><span class="line">fn.bind(xx)</span><br><span class="line"><span class="built_in">this</span> =&gt; xx</span><br><span class="line"><span class="keyword">new</span> Fn()</span><br><span class="line"><span class="built_in">this</span> =&gt; 新的对象</span><br><span class="line">fn = <span class="function">()=&gt;</span> &#123;&#125;</span><br><span class="line"><span class="built_in">this</span> =&gt; 外面的 <span class="built_in">this</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;this是什么&quot;&gt;&lt;a href=&quot;#this是什么&quot; class=&quot;headerlink&quot; title=&quot;this是什么&quot;&gt;&lt;/a&gt;this是什么&lt;/h2&gt;&lt;p&gt;当声明一个函数时，函数会有一个this（指针），声明时this不指向任何对象。当函数被调用时，哪个对</summary>
      
    
    
    
    <category term="JavaScript" scheme="https://amiemie906.gitee.io/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="https://amiemie906.gitee.io/tags/JavaScript/"/>
    
    <category term="this" scheme="https://amiemie906.gitee.io/tags/this/"/>
    
  </entry>
  
  <entry>
    <title>Vue - 路由基础</title>
    <link href="https://amiemie906.gitee.io/2020/09/27/Vue-router/"/>
    <id>https://amiemie906.gitee.io/2020/09/27/Vue-router/</id>
    <published>2020-09-27T10:45:12.000Z</published>
    <updated>2021-03-29T03:14:36.882Z</updated>
    
    <content type="html"><![CDATA[<h2 id="路由基础"><a href="#路由基础" class="headerlink" title="路由基础"></a>路由基础</h2><h3 id="路由含义"><a href="#路由含义" class="headerlink" title="路由含义"></a>路由含义</h3><ul><li><p>服务器端的路由： <strong>一个地址指向一个资源页面</strong></p></li><li><p>前端的路由：框架式开发都是单页面（SPA）应用</p><ul><li>single page application   单页面应用<ul><li>优点：体验感好，组件化开发</li><li>缺点：不利于seo，首页加载慢</li></ul></li><li>multiple page appliction 多页面应用<ul><li>优点：seo友好</li><li>缺点：复用不好</li></ul></li></ul></li></ul><h4 id="简单实现路由："><a href="#简单实现路由：" class="headerlink" title="简单实现路由："></a>简单实现路由：</h4><ul><li><p>hash</p><p>hash（#）是URL 的锚点，代表的是网页中的一个位置，单单改变#后的部分，浏览器只会滚动到相应位置，不会重新加载网页，也就是说hash 出现在 URL 中，但不会被包含在 http 请求中，对后端完全没有影响，因此改变 hash 不会重新加载页面；同时每一次改变#后的部分，都会在浏览器的访问历史中增加一个记录，使用”后退”按钮，就可以回到上一个位置；</p></li><li><p>Hash模式：通过锚点值的改变，根据不同的值，渲染指定DOM位置的不同数据。</p></li><li><p>监听<code>hashchange</code>变化，修改动态组件的内容</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=<span class="string">&quot;app&quot;</span>&gt;</span><br><span class="line">      &lt;component :newURL=<span class="string">&quot;cur&quot;</span>&gt;&lt;/component&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">import</span>  index <span class="keyword">from</span> <span class="string">&quot;@/pages/index&quot;</span></span><br><span class="line"><span class="keyword">import</span>  car <span class="keyword">from</span> <span class="string">&quot;@/pages/car&quot;</span></span><br><span class="line"><span class="keyword">import</span>  user <span class="keyword">from</span> <span class="string">&quot;@/pages/user&quot;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  name: <span class="string">&#x27;App&#x27;</span>,</span><br><span class="line">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">       cur:<span class="string">&quot;index&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    index,user,car</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> _this = <span class="built_in">this</span>;</span><br><span class="line">      <span class="built_in">window</span>.addEventListener(<span class="string">&quot;hashchange&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(e)</span><br><span class="line">        <span class="keyword">let</span> url = e.newURL.split(<span class="string">&quot;#&quot;</span>)[<span class="number">1</span>].slice(<span class="number">1</span>)</span><br><span class="line">          <span class="keyword">if</span>(url)&#123;</span><br><span class="line">            _this.cur = url;</span><br><span class="line">          &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            _this.cur = <span class="string">&#x27;index&#x27;</span></span><br><span class="line">          &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">*&#123;</span><br><span class="line">  margin: <span class="number">0</span>;</span><br><span class="line">  padding: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></li></ul><h3 id="vue-router"><a href="#vue-router" class="headerlink" title="vue-router"></a>vue-router</h3><ul><li><p>WebApp的链接路径管理系统， 是vue生态圈里非常重要的内容</p></li><li><p>文档地址：<a href="https://router.vuejs.org/zh/">https://router.vuejs.org/zh/</a></p></li><li><p>使用：</p><ul><li><p>安装vue-router</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i vue-router --save</span><br></pre></td></tr></table></figure></li><li><p>在src下面创建router文件夹，下面创建index.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> VueRouter <span class="keyword">from</span> <span class="string">&quot;vue-router&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Vue.use(插件名)   安装插件</span></span><br><span class="line">Vue.use(VueRouter);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入页面组件</span></span><br><span class="line"><span class="keyword">import</span> 组件A <span class="keyword">from</span> <span class="string">&quot;@/pages/组件A&quot;</span></span><br><span class="line"><span class="keyword">import</span> 组件B <span class="keyword">from</span> <span class="string">&quot;@/pages/组件B&quot;</span></span><br><span class="line"><span class="keyword">import</span> 组件C <span class="keyword">from</span> <span class="string">&quot;@/pages/组件C&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例化一个路由对象</span></span><br><span class="line"><span class="keyword">let</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">   routes:[</span><br><span class="line">     &#123; <span class="attr">path</span>:<span class="string">&quot;/a&quot;</span>,<span class="attr">component</span>:组件A &#125;,</span><br><span class="line">     &#123; <span class="attr">path</span>:<span class="string">&quot;/b&quot;</span>,<span class="attr">component</span>:组件B &#125;,</span><br><span class="line">     &#123; <span class="attr">path</span>:<span class="string">&quot;/c&quot;</span>,<span class="attr">component</span>:组件C &#125;,</span><br><span class="line">   ]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>在App.vue 模板里面写入<code>router-view</code>标签，路由地址切换之后对应的组件内容展示在这里</p></li><li><p>使用<code>router-link</code>实现a标签。 to的值就是 路由映射配置里面的path内容</p></li></ul></li><li><p><strong>在脚手架初始项目的时候就选择安装vue-router,自动设计好所有配置</strong></p></li></ul><h3 id="404配置"><a href="#404配置" class="headerlink" title="404配置"></a>404配置</h3><ul><li><p>默认情况下，访问一个没有被定义的路由地址， 页面是不会渲染任何内容。我们可以给他指定到404页面</p></li><li><p>实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">routes:[</span><br><span class="line">   &#123; <span class="attr">path</span>:<span class="string">&quot;*&quot;</span>,<span class="attr">component</span>:<span class="number">404</span>组件 &#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h3 id="激活class"><a href="#激活class" class="headerlink" title="激活class"></a>激活class</h3><ul><li><p>需要设置激活的class， 当前的路由地址和a标签一致的时候，a标签就应该激活</p></li><li><p>实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  linkActiveClass:<span class="string">&#x27;自定义class名&#x27;</span>,   <span class="comment">// 非严格模式  但是可以在某个router-link上面加上exact属性，变成严格模式</span></span><br><span class="line">  linkExactActiveClass:<span class="string">&#x27;自定义class名&#x27;</span>   <span class="comment">// 严格模式</span></span><br><span class="line">routes:[</span><br><span class="line">   &#123; <span class="attr">path</span>:<span class="string">&quot;*&quot;</span>,<span class="attr">component</span>:<span class="number">404</span>组件 &#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">routes:[</span><br><span class="line">&#123; <span class="attr">path</span>:<span class="string">&quot;/地址A&quot;</span>,<span class="attr">redirect</span>:<span class="string">&quot;/地址B&quot;</span> &#125;   <span class="comment">// 访问地址A的时候跳转到地址B</span></span><br><span class="line">]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="命名路由"><a href="#命名路由" class="headerlink" title="命名路由"></a>命名路由</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">routes:[</span><br><span class="line">     &#123; <span class="attr">path</span>:<span class="string">&quot;/地址A&quot;</span>,<span class="attr">component</span>:组件A,  <span class="attr">name</span>:<span class="string">&quot;名称A&quot;</span> &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/地址A&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-link :to&#x3D;&quot;&#123;name:&#39;名称A&#39;&#125;&quot;&gt;&lt;&#x2F;router-link&gt;</span><br></pre></td></tr></table></figure><h3 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h3><ul><li><p>使用场景：</p><ul><li>   新闻列表 到新闻详情     详情需要知道新闻id。</li><li>   新闻分类 到新闻列表    新闻列表需要知道新闻分类id</li><li>   愿望： 实现页面之间的传递参数吗</li></ul></li><li><p>使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  routes:[</span><br><span class="line">   &#123; <span class="attr">path</span>:<span class="string">&quot;/地址A/:标识符&quot;</span>,<span class="attr">component</span>:组件A &#125;,</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/地址A/数据&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 组件A里面</span></span><br><span class="line"><span class="built_in">this</span>.$route.params.标识符</span><br></pre></td></tr></table></figure><p><strong>实现了两个页面之间的传参</strong></p></li><li><p>注意：</p><p>当我们在main.js中将路由挂载到vue实例上面去之后， 所有的组件对象里面都会多两个属性，一个<code>$router</code>,<code>$route</code></p><ul><li><code>$router</code>表示这个路由实例对象</li><li><code>$route</code> 表示当前页面的路由信息<ul><li>this.$route.params   动态路由数据</li><li>this.$route.name   路由名称</li><li>this.$route.meta   元数据</li><li>this.$route.query   search参数</li><li>this.$route.matched   路径信息</li></ul></li></ul></li></ul><h4 id="如何实现页面之间传参"><a href="#如何实现页面之间传参" class="headerlink" title="如何实现页面之间传参"></a>如何实现页面之间传参</h4><ul><li><p>动态路由</p></li><li><p>query传参</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/地址B?key=val&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.$route.query.key</span><br></pre></td></tr></table></figure></li><li><p>本地存储</p><ul><li>localStorage.setItem(“key”,val)</li><li>localStorage.getItem(“key”)</li></ul></li></ul><h2 id="路由升级"><a href="#路由升级" class="headerlink" title="路由升级"></a>路由升级</h2><h3 id="编程式导航"><a href="#编程式导航" class="headerlink" title="编程式导航"></a>编程式导航</h3><ul><li><p>原生JS实现页面跳转方式：</p><ul><li>a   href</li><li>JS    编程式导航<ul><li>location.href   assign   replace</li><li>history.back   forward  go</li></ul></li></ul></li><li><p><strong>$router</strong></p><ul><li><p>push</p></li><li><p>replace</p></li><li><p>go</p></li><li><p>back</p></li><li><p>forward</p></li></ul></li></ul><h3 id="嵌套路由"><a href="#嵌套路由" class="headerlink" title="嵌套路由"></a>嵌套路由</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">routes:[</span><br><span class="line">&#123;</span><br><span class="line">  path:<span class="string">&quot;/地址A&quot;</span>,    <span class="comment">//一级路由</span></span><br><span class="line">  component:组件A,   </span><br><span class="line">  children:[   <span class="comment">// 二级路由， 二级路由的组件 (组件aa，组件bb,组件cc都展示在组件A的模板里面的router-view里面，而不是顶级的router-view)</span></span><br><span class="line">  &#123; <span class="attr">path</span>:<span class="string">&quot;/地址A/aa&quot;</span>,<span class="attr">component</span>:组件aa &#125;,</span><br><span class="line">  &#123; <span class="attr">path</span>:<span class="string">&quot;/地址A/bb&quot;</span>,<span class="attr">component</span>:组件bb &#125;,</span><br><span class="line">  &#123; <span class="attr">path</span>:<span class="string">&quot;/地址A/cc&quot;</span>,<span class="attr">component</span>:组件cc &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 组件A里面一定要有一个router-view</span></span><br><span class="line">(组件aa，组件bb,组件cc都展示在组件A的模板里面的router-view里面，而不是顶级的router-view)</span><br></pre></td></tr></table></figure><h3 id="命名视图"><a href="#命名视图" class="headerlink" title="命名视图"></a>命名视图</h3><ul><li><p>视图就是<code>router-view</code></p></li><li><p>默认情况下： 一个路由只能渲染一个组件到一个指定的位置</p></li><li><p>如果我们希望访问一个路由的时候，同时渲染多个组件到不同位置，这个时候就可以使用命名视图</p></li><li><p>实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">routes:[</span><br><span class="line">&#123;</span><br><span class="line">  path:&quot;&#x2F;地址A&quot;,    &#x2F;&#x2F;一级路由</span><br><span class="line">  components:&#123;</span><br><span class="line">  default:组件A,</span><br><span class="line">  x:组件X,</span><br><span class="line">  y:组件y</span><br><span class="line">  &#125;,   </span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-view</span> <span class="attr">name</span>=<span class="string">&#x27;default&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span>   默认视图，可以不要name属性</span><br><span class="line"><span class="tag">&lt;<span class="name">router-view</span> <span class="attr">name</span>=<span class="string">&#x27;x&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span>   组件x渲染在这</span><br><span class="line"><span class="tag">&lt;<span class="name">router-view</span> <span class="attr">name</span>=<span class="string">&#x27;y&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span>   组件y渲染在这</span><br></pre></td></tr></table></figure></li></ul><h3 id="元信息"><a href="#元信息" class="headerlink" title="元信息"></a>元信息</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">routes:[</span><br><span class="line">&#123; </span><br><span class="line">path:<span class="string">&quot;/地址&quot;</span>,</span><br><span class="line">component:<span class="string">&quot;组件&quot;</span></span><br><span class="line">meta:&#123;  <span class="attr">key</span>:val &#125;   <span class="comment">// 元信息，表示给这个路由设置一些自定义属性</span></span><br><span class="line">&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.$route.meta.key    <span class="comment">// 可以获取数据</span></span><br></pre></td></tr></table></figure><h3 id="导航守卫"><a href="#导航守卫" class="headerlink" title="导航守卫"></a>导航守卫</h3><h4 id="什么是导航守卫"><a href="#什么是导航守卫" class="headerlink" title="什么是导航守卫"></a>什么是导航守卫</h4><p>进入路由、离开路由、更新路由的时候自动执行的函数。 又称之<strong>路由钩子函数</strong></p><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><ul><li>全局守卫<ul><li><strong>前置守卫    路由进入之前会执行的函数  beforeEach</strong><ul><li>设置标题</li><li>权限判断</li></ul></li><li>后置守卫    路由离开后执行的函数   afterEach</li></ul></li><li>局部守卫<ul><li>前置守卫</li><li>更新守卫</li><li>后置守卫</li></ul></li></ul><h3 id="路由懒加载"><a href="#路由懒加载" class="headerlink" title="路由懒加载"></a>路由懒加载</h3><ul><li><p>原来的路由配置文件里面都是通过import 导入所有的组件。这样做，应用开始的时候就会导入这些所有的组件，增加了负担</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Index <span class="keyword">from</span> <span class="string">&quot;@/pages/Index&quot;</span></span><br><span class="line"><span class="keyword">import</span> About <span class="keyword">from</span> <span class="string">&quot;@/pages/About&quot;</span></span><br><span class="line"><span class="keyword">import</span> New <span class="keyword">from</span> <span class="string">&quot;@/pages/New&quot;</span></span><br><span class="line"><span class="keyword">import</span> NewInfo <span class="keyword">from</span> <span class="string">&quot;@/pages/NewInfo&quot;</span></span><br><span class="line"><span class="keyword">import</span> User <span class="keyword">from</span> <span class="string">&quot;@/pages/User&quot;</span></span><br><span class="line"><span class="keyword">import</span> UserOrder <span class="keyword">from</span> <span class="string">&quot;@/pages/UserOrder&quot;</span></span><br><span class="line"><span class="keyword">import</span> UserClass <span class="keyword">from</span> <span class="string">&quot;@/pages/UserClass&quot;</span></span><br><span class="line"><span class="keyword">import</span> UserSet <span class="keyword">from</span> <span class="string">&quot;@/pages/UserSet&quot;</span></span><br><span class="line"><span class="keyword">import</span> UserIndex <span class="keyword">from</span> <span class="string">&quot;@/pages/UserIndex&quot;</span></span><br><span class="line"><span class="keyword">import</span> NotFound <span class="keyword">from</span> <span class="string">&quot;@/pages/NotFound&quot;</span></span><br><span class="line"><span class="keyword">import</span> Adv <span class="keyword">from</span> <span class="string">&quot;@/components/Adv&quot;</span></span><br><span class="line"><span class="keyword">import</span> Login <span class="keyword">from</span> <span class="string">&quot;@/pages/Login&quot;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>希望打开哪个路由地址的时候就再去加载对应的路由组件。 这就是路由懒加载</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> 组件名 <span class="keyword">from</span> <span class="string">&quot;@/pages/组件名&quot;</span></span><br><span class="line">&#123;</span><br><span class="line">  path:<span class="string">&quot;/地址&quot;</span>,</span><br><span class="line">  component:组件名</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> path:<span class="string">&quot;/地址&quot;</span>,</span><br><span class="line"> component:<span class="function">()=&gt;</span><span class="keyword">import</span>(<span class="string">&quot;@/pages/组件名&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;路由基础&quot;&gt;&lt;a href=&quot;#路由基础&quot; class=&quot;headerlink&quot; title=&quot;路由基础&quot;&gt;&lt;/a&gt;路由基础&lt;/h2&gt;&lt;h3 id=&quot;路由含义&quot;&gt;&lt;a href=&quot;#路由含义&quot; class=&quot;headerlink&quot; title=&quot;路由含义&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="Vue" scheme="https://amiemie906.gitee.io/categories/Vue/"/>
    
    <category term="Vue2" scheme="https://amiemie906.gitee.io/categories/Vue/Vue2/"/>
    
    
    <category term="Vue" scheme="https://amiemie906.gitee.io/tags/Vue/"/>
    
    <category term="Vue2" scheme="https://amiemie906.gitee.io/tags/Vue2/"/>
    
  </entry>
  
  <entry>
    <title>Vue - 组件通信</title>
    <link href="https://amiemie906.gitee.io/2020/09/27/Vue-components-communication/"/>
    <id>https://amiemie906.gitee.io/2020/09/27/Vue-components-communication/</id>
    <published>2020-09-27T04:25:49.000Z</published>
    <updated>2021-03-29T02:22:11.544Z</updated>
    
    <content type="html"><![CDATA[<h2 id="父子通信"><a href="#父子通信" class="headerlink" title="父子通信"></a>父子通信</h2><h3 id="实现：-自定义属性"><a href="#实现：-自定义属性" class="headerlink" title="实现： 自定义属性"></a>实现： 自定义属性</h3><ul><li><p>使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 子组件里面</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  props:[<span class="string">&#x27;属性名1&#x27;</span>,<span class="string">&#x27;属性名2&#x27;</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子模板里面</span></span><br><span class="line">&#123;&#123;属性名<span class="number">1</span>&#125;&#125;   &#123;&#123;属性名<span class="number">2</span>&#125;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--父组件里面--&gt;</span></span><br><span class="line">&lt;子组件  属性名1=&quot;值&quot;   :属性名2=&quot;变量&quot; /&gt;</span><br></pre></td></tr></table></figure><p><img src="/images/vue-components/img1.png"></p></li></ul><p><strong>为了保证组件内部数据的统一性，我们要对组件的自定义属性，进行类型的验证！</strong></p><h3 id="props验证"><a href="#props验证" class="headerlink" title="props验证"></a>props验证</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">props:[<span class="string">&#x27;属性名&#x27;</span>]    <span class="comment">// 尽量不要使用数组模式</span></span><br><span class="line"></span><br><span class="line">props:&#123;  <span class="comment">// 对象模式</span></span><br><span class="line">  属性名:类型,</span><br><span class="line">  属性名:[类型<span class="number">1</span>,类型<span class="number">2</span>],  </span><br><span class="line">  属性名:&#123;</span><br><span class="line">     type:类型,  <span class="comment">// 单类型       // 类型校验</span></span><br><span class="line">     type:[类型<span class="number">1</span>,类型<span class="number">2</span>],  <span class="comment">// 多类型</span></span><br><span class="line">     <span class="keyword">default</span>:默认值    <span class="comment">// 默认值</span></span><br><span class="line">     <span class="function"><span class="title">default</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> 对象/数组</span><br><span class="line">     &#125;,</span><br><span class="line">     required:<span class="literal">true</span>/<span class="literal">false</span>,  <span class="comment">// 是否必须</span></span><br><span class="line">     <span class="function"><span class="title">validator</span>(<span class="params">val</span>)</span>&#123;     <span class="comment">// 自定义校验函数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>/<span class="literal">false</span></span><br><span class="line">     &#125;  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>哪些类型？</strong></p><ul><li><code>String</code></li><li><code>Number</code></li><li><code>Boolean</code></li><li><code>Array</code></li><li><code>Object</code></li><li><code>Date</code></li><li><code>Function</code></li><li><code>Symbol</code></li></ul><h4 id="单向数据流"><a href="#单向数据流" class="headerlink" title="单向数据流"></a>单向数据流</h4><p>所有的 prop 都使得其父子 prop 之间形成了一个<strong>单向下行绑定</strong>：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。这样会<strong>防止从子组件意外变更父级组件的状态，从而导致你的应用的数据流向难以理解。</strong></p><p><strong>修改props，不是真的修改</strong></p><ul><li><p><strong>props 用来传递一个初始值赋给组件的data</strong></p></li><li><p><strong>props 赋给计算属性</strong></p></li><li><p>传入一个对象的所有property</p><p>如果你想要将一个对象的所有 property 都作为 prop 传入，你可以使用不带参数的 <code>v-bind</code> (取代 <code>v-bind:prop-name</code>)。例如，对于一个给定的对象 <code>post</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">post: &#123;</span><br><span class="line">  id: <span class="number">1</span>,</span><br><span class="line">  title: <span class="string">&#x27;My Journey with Vue&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面的模板：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">blog-post</span> <span class="attr">v-bind</span>=<span class="string">&quot;post&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br></pre></td></tr></table></figure><p>等价于：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;blog-post</span><br><span class="line">  v-bind:id=&quot;post.id&quot;</span><br><span class="line">  v-bind:title=&quot;post.title&quot;</span><br><span class="line">&gt;<span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>总结：</strong></p><ul><li>props的使用</li><li>props验证</li><li>单项数据流</li></ul></li></ul><h2 id="子父通信"><a href="#子父通信" class="headerlink" title="子父通信"></a>子父通信</h2><h3 id="实现：-自定义事件"><a href="#实现：-自定义事件" class="headerlink" title="实现： 自定义事件"></a>实现： 自定义事件</h3><ul><li><p>使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父的模板里面</span></span><br><span class="line">&lt;子组件名 @自定义事件名=<span class="string">&quot;父的事件函数&quot;</span> /&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父的JS里面</span></span><br><span class="line">methods:&#123;</span><br><span class="line">父的事件函数(形参)&#123;</span><br><span class="line">     ....</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.$emit(<span class="string">&quot;自定义事件名&quot;</span>,实参)    <span class="comment">// 本质调用了，父的事件函数</span></span><br></pre></td></tr></table></figure><p><img src="/images/vue-components/img2.png"></p><p><img src="/images/vue-components/img3.png"></p></li></ul><h2 id="祖先后代通信"><a href="#祖先后代通信" class="headerlink" title="祖先后代通信"></a>祖先后代通信</h2><ul><li><p>目的： 实现祖先的数据，后代都可以使用（一般用于全局变量）</p></li><li><p>实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 祖先组件</span></span><br><span class="line">provide:&#123;</span><br><span class="line">key1:val1,</span><br><span class="line">key2:val2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 后代任意组件中</span></span><br><span class="line">inject:[key1,key2]      </span><br><span class="line">inject:&#123;</span><br><span class="line">  newkey:&#123;</span><br><span class="line">     <span class="keyword">from</span>:key1,</span><br><span class="line">     <span class="keyword">default</span>:<span class="string">&quot;默认值&quot;</span>  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;&#123;key1&#125;&#125;    &#123;&#123;key2&#125;&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="非父子通信"><a href="#非父子通信" class="headerlink" title="非父子通信"></a>非父子通信</h2><ul><li><p>实现任意两个组件之间的通信！</p></li><li><p>核心：<strong>利用vue里面的$emit 和 $on 实现 组件的监听事件和触发事件</strong></p></li><li><p>实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js中</span></span><br><span class="line"><span class="keyword">let</span> bus = <span class="keyword">new</span> Vue();</span><br><span class="line"><span class="comment">// 在Vue的原型上面添加数据，所有的组件里都可以获取到</span></span><br><span class="line">Vue.prototype.$bus = bus</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 任意组件中  事件订阅</span></span><br><span class="line"><span class="function"><span class="title">created</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="built_in">this</span>.$bus.$on(<span class="string">&#x27;自定义事件名&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">形参</span>)</span>&#123;</span><br><span class="line">       ...</span><br><span class="line">   &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 任意其他组件中  事件发布</span></span><br><span class="line"><span class="built_in">this</span>.$bus.$emit(<span class="string">&#x27;自定义事件名&#x27;</span>,实参)</span><br></pre></td></tr></table></figure></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>父子通信<ul><li>自定义属性（props）、自定义事件（$emit）</li></ul></li><li>祖先后代<ul><li>provide （祖先）</li><li>inject (后代)</li></ul></li><li>非父子<ul><li>$on  和  $emit     自定义事件</li></ul></li><li>本地存储</li><li>父子关系<ul><li>$parent</li><li>$children、$refs</li></ul></li><li>vuex</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;父子通信&quot;&gt;&lt;a href=&quot;#父子通信&quot; class=&quot;headerlink&quot; title=&quot;父子通信&quot;&gt;&lt;/a&gt;父子通信&lt;/h2&gt;&lt;h3 id=&quot;实现：-自定义属性&quot;&gt;&lt;a href=&quot;#实现：-自定义属性&quot; class=&quot;headerlink&quot; title=</summary>
      
    
    
    
    <category term="Vue" scheme="https://amiemie906.gitee.io/categories/Vue/"/>
    
    <category term="Vue2" scheme="https://amiemie906.gitee.io/categories/Vue/Vue2/"/>
    
    
    <category term="Vue" scheme="https://amiemie906.gitee.io/tags/Vue/"/>
    
    <category term="Vue2" scheme="https://amiemie906.gitee.io/tags/Vue2/"/>
    
  </entry>
  
  <entry>
    <title>Vue - computed和watch的区别</title>
    <link href="https://amiemie906.gitee.io/2020/09/27/Vue-computed-vs-watch/"/>
    <id>https://amiemie906.gitee.io/2020/09/27/Vue-computed-vs-watch/</id>
    <published>2020-09-27T02:25:49.000Z</published>
    <updated>2021-03-29T01:49:43.021Z</updated>
    
    <content type="html"><![CDATA[<h2 id="computed-计算属性"><a href="#computed-计算属性" class="headerlink" title="computed 计算属性"></a>computed 计算属性</h2><blockquote><p>计算属性 ，用来计算出一个值，这个值在调用的时候会根据依赖的数据显示新的计算结果并自动缓存。 如果依赖不变，computed中的值就不会重新计算。</p></blockquote><h3 id="什么是计算属性，为什么要使用"><a href="#什么是计算属性，为什么要使用" class="headerlink" title="什么是计算属性，为什么要使用"></a>什么是计算属性，为什么要使用</h3><ul><li>计算属性含义： <strong>本质还是属性，用来在模板中展示</strong> </li><li>计算属性其实和data的地位相同，都是vue实例的属性，都可以在模板中使用</li><li>出现的原因：一般在模板语法内使用表达式非常方便，模板也只是用于简单的运算，当表达式过于复杂时，在模板中放入太多逻辑会让模板过重且难以维护。为此，Vue提供了计算属性computed。</li></ul><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">computed:&#123;</span><br><span class="line">  属性名:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"> <span class="keyword">return</span> 值</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;&#123;属性名&#125;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; msg.split(<span class="string">&quot;&quot;</span>).reverse().join(<span class="string">&quot;&quot;</span>) &#125;&#125;     <span class="comment">// 模板过重且难以维护</span></span><br><span class="line"></span><br><span class="line">&#123;&#123; haha &#125;&#125;</span><br><span class="line"></span><br><span class="line">computed:&#123;</span><br><span class="line">  haha:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;      </span><br><span class="line">     <span class="keyword">return</span> <span class="built_in">this</span>.msg.split(<span class="string">&quot;&quot;</span>).reverse().join(<span class="string">&quot;&quot;</span>)</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="修改计算属性"><a href="#修改计算属性" class="headerlink" title="修改计算属性"></a>修改计算属性</h3><ul><li>计算属性默认只有 <code>getter</code>，不可修改</li><li>如果需要修改，可以提供一个 <code>setter</code></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">computed:&#123;</span><br><span class="line">    fullName: &#123;</span><br><span class="line">    <span class="comment">// getter</span></span><br><span class="line">    get: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.firstName + <span class="string">&#x27; &#x27;</span> + <span class="built_in">this</span>.lastName</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// setter</span></span><br><span class="line">    set: <span class="function"><span class="keyword">function</span> (<span class="params">newValue</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> names = newValue.split(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">      <span class="built_in">this</span>.firstName = names[<span class="number">0</span>]</span><br><span class="line">      <span class="built_in">this</span>.lastName = names[names.length - <span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再运行 <code>vm.fullName = &#39;John Doe&#39;</code> 时，setter 会被调用，<code>vm.firstName</code> 和 <code>vm.lastName</code> 也会相应地被更新。</p><h2 id="watch-侦听器"><a href="#watch-侦听器" class="headerlink" title="watch 侦听器"></a>watch 侦听器</h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>对data里面的数据进行监听处理。</p><h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><p>一个对象，键是需要观察的表达式（<strong>data内的数据</strong>），值是对应回调函数。值也可以是方法名，或者包含选项的对象。</p><p>当数据发生改变时，会执行一个回调，它有两个参数， newVal 和 oldVal</p><p>watch 有两个属性：</p><ul><li><code>immediate</code> 是否在第一次渲染时执行这个函数，会在监听开始之后就立即本调用。</li><li><code>deep</code> 是否要看这个对象里面的属性变化。</li></ul><h4 id="浅监听"><a href="#浅监听" class="headerlink" title="浅监听"></a>浅监听</h4><p> 监听基础数据类型</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">watch:&#123;</span><br><span class="line">变量名(newval,oldval)&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="深监听"><a href="#深监听" class="headerlink" title="深监听"></a>深监听</h4><p>监听引用数据类型</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">watch:&#123;</span><br><span class="line">  变量名:&#123;</span><br><span class="line">    deep:<span class="literal">true</span>,</span><br><span class="line">    handler:<span class="function"><span class="keyword">function</span>(<span class="params">newval</span>)</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="computed-和-methods-的区别"><a href="#computed-和-methods-的区别" class="headerlink" title="computed 和 methods 的区别"></a>computed 和 methods 的区别</h2><ul><li>计算属性是基于他们的响应式依赖进行缓存的，只在相关响应式依赖发生改变时，才会重新求值（也就是说，计算属性会把数据进行缓存）</li><li>而方法不会把数据进行缓存， 每次都会执行，所以用计算属性效率会更高点</li></ul><p><strong>所以，对于任何复杂逻辑，都应该使用计算属性</strong></p><p>在某些情况，我们可能需要对数据进行一些转化后再显示，或者需要将多个数据结合起来进行显示</p><ul><li><p>比如我们有firstName和lastName两个变量，我们需要显示完整的名称。</p></li><li><p>但是如果多个地方都需要显示完整的名称，我们就需要写多个</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;firstName + &#x27; &#x27; + lastName&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;firstName&#125;&#125; &#123;&#123;lastName&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;getFullName()&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;fullName&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../js/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line"><span class="javascript">      firstName: <span class="string">&#x27;Lron&#x27;</span>,</span></span><br><span class="line"><span class="javascript">      lastName: <span class="string">&#x27;Man&#x27;</span></span></span><br><span class="line">    &#125;,</span><br><span class="line"><span class="javascript">    <span class="comment">// 推荐使用计算属性来操作，因为它会将这些数据进行缓存， 无论打印多少次，它只会调用一次</span></span></span><br><span class="line">    computed: &#123;</span><br><span class="line"><span class="javascript">    <span class="comment">//  计算属性   注意 : 计算的是 属性, </span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 所以这里面的属性 看成一个 对象(用名词形式来表达), 调用时候不用加小括号</span></span></span><br><span class="line"><span class="javascript">      fullName: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> <span class="built_in">this</span>.firstName + <span class="string">&#x27; &#x27;</span> + <span class="built_in">this</span>.lastName</span></span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line"><span class="javascript">      <span class="comment">//  不会缓存， 所以有多少次就调用多少次，  没有 computed 划算</span></span></span><br><span class="line"><span class="javascript">      getFullName: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> <span class="built_in">this</span>.firstName + <span class="string">&#x27; &#x27;</span> + <span class="built_in">this</span>.lastName</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="computed-和-watch-的区别"><a href="#computed-和-watch-的区别" class="headerlink" title="computed 和 watch 的区别"></a>computed 和 watch 的区别</h2><ul><li><p><code>computed</code> 是为了简化模板里面的操作，对数据处理后进行展示：由data中的已知值，得到的一个新值；</p><p><code>watch</code>目的是监听data中已知值的变化，执行响应的逻辑处理。</p></li><li><p><code>computed</code>擅长处理的场景：一个数据受多个数据影响；</p><p><code>watch</code>擅长处理的场景：一个数据影响多个数据</p></li></ul><p>如果有一些数据需要随着其它数据变动而变动时， <code>watch</code>就会显得非常冗余，官方文档给出了如下的示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#demo&#x27;</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    firstName: <span class="string">&#x27;Foo&#x27;</span>,</span><br><span class="line">    lastName: <span class="string">&#x27;Bar&#x27;</span>,</span><br><span class="line">    fullName: <span class="string">&#x27;Foo Bar&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  watch: &#123;</span><br><span class="line">    firstName: <span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.fullName = val + <span class="string">&#x27; &#x27;</span> + <span class="built_in">this</span>.lastName</span><br><span class="line">    &#125;,</span><br><span class="line">    lastName: <span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.fullName = <span class="built_in">this</span>.firstName + <span class="string">&#x27; &#x27;</span> + val</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#demo&#x27;</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    firstName: <span class="string">&#x27;Foo&#x27;</span>,</span><br><span class="line">    lastName: <span class="string">&#x27;Bar&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    fullName: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.firstName + <span class="string">&#x27; &#x27;</span> + <span class="built_in">this</span>.lastName</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><p>如果一个数据需要经过复杂计算就用 <code>computed</code></p></li><li><p>如果一个数据需要在发生变化时做一些逻辑就用 <code>watch</code></p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;computed-计算属性&quot;&gt;&lt;a href=&quot;#computed-计算属性&quot; class=&quot;headerlink&quot; title=&quot;computed 计算属性&quot;&gt;&lt;/a&gt;computed 计算属性&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;计算属性 ，用来计算出一个</summary>
      
    
    
    
    <category term="Vue" scheme="https://amiemie906.gitee.io/categories/Vue/"/>
    
    <category term="Vue2" scheme="https://amiemie906.gitee.io/categories/Vue/Vue2/"/>
    
    
    <category term="Vue" scheme="https://amiemie906.gitee.io/tags/Vue/"/>
    
    <category term="Vue2" scheme="https://amiemie906.gitee.io/tags/Vue2/"/>
    
  </entry>
  
  <entry>
    <title>ES6知识点总结</title>
    <link href="https://amiemie906.gitee.io/2020/09/26/es6-notes/"/>
    <id>https://amiemie906.gitee.io/2020/09/26/es6-notes/</id>
    <published>2020-09-26T07:32:01.000Z</published>
    <updated>2021-04-02T02:16:08.740Z</updated>
    
    <content type="html"><![CDATA[<h2 id="let、const和var的作用和区别"><a href="#let、const和var的作用和区别" class="headerlink" title="let、const和var的作用和区别"></a>let、const和var的作用和区别</h2><h3 id="var"><a href="#var" class="headerlink" title="var"></a>var</h3><ul><li>声明变量 ，声明的变量可以重复声明，同一作用域下，后声明的会覆盖前声明的，</li><li>有变量提升的特点</li></ul><h3 id="let"><a href="#let" class="headerlink" title="let"></a>let</h3><ul><li><p>没有变量提升，必须先声明再使用，</p></li><li><p>同一作用域下不能重复声明同一个变量名，会报错。可以重新赋值。</p></li><li><p>let声明的变量产生一个块级作用域。</p><ul><li>块级作用域：在js中成每个花括号之间的叫代码块 –{   代码块   }，{}的区域叫块级作用域，在每一个{}内let声明出来的变量只能在这个{}中访问到。</li></ul></li><li><p><strong>暂时性死区</strong></p><ul><li>简而言之：在代码块内，使用<code>let</code>命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”</li><li>当程序的控制流程在新的作用域进行实例化时，在此作用域中用let/const声明的变量会先在作用域中被创建出来。但因这时还未进行词法绑定，所以是不能访问的，如果访问就会报错。因此，在这运行流程进入作用域创建变量，到变量可以被访问之间的这一段时间，就称之为暂时性死区</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a) <span class="comment">//会报错，因为该代码块内有一个let，所以使该块区形成了一个封闭的作用域，a在使用let声明前不能被调用</span></span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">30</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><ul><li>没有变量提升，必须声明在使用</li><li>用于声明常量，初始化时一定要赋值，声明之后不能再重复声明也不能再赋值。<ul><li>注意用const声明引用类型时（对象、数组）：对象和数组内部的项可以修改。也不能直接给对象、数组的变量名重新赋值  –不能 obj= 10</li></ul></li><li>会产生块级作用域，暂时性死区。</li></ul><h3 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h3><ul><li><p>局部作用域又叫（函数作用域），全局作用域和局部作用域都是相对函数内外而定义的。</p></li><li><p>console.time()   ……… console.timeEnd()可以控制台打印中间代码执行的时间。</p></li><li><p>循环变量时循环内部的处理函数，拿到的都是循环结束之后的最终变量值</p><ul><li>解决：<ul><li> 闭包：可以将闭包内部变量不会直接垃圾回收，而会存储在内存中，这样使用的时候就是上次存的变量值，而不是循环结束之后最终的变量值。</li><li> let：而let本身就  有块级作用域的特点，所以相当于闭包，在块级作用域使用的时候也会把值存到内存中。  </li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//let的应用场景</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i) <span class="comment">//打印5个5</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i) <span class="comment">// 0-4</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//注：若用var声明循环变量，还可用匿名函数自执行的方式解决</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">    ;(<span class="function"><span class="keyword">function</span>(<span class="params">i</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(i) <span class="comment">// 0-4</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)(i)<span class="comment">//将i值传到匿名函数中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="变量的解构赋值"><a href="#变量的解构赋值" class="headerlink" title="变量的解构赋值"></a>变量的解构赋值</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul><li>ES6 允许按照<strong>一定模式</strong>，从<strong>数组</strong>和<strong>对象</strong>中提取值，对变量进行赋值，这被称为解构—–要求*<strong>模式匹配</strong></li></ul><h3 id="数组解构赋值"><a href="#数组解构赋值" class="headerlink" title="数组解构赋值"></a>数组解构赋值</h3><p>有序— 按位置对应</p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li><p>完全解构：值与变量对应</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a,b,c] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br></pre></td></tr></table></figure></li><li><p>不完全解构：值比变量多</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a]=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]  --- a = <span class="number">1</span></span><br><span class="line"><span class="comment">//缺省</span></span><br><span class="line"><span class="keyword">let</span> [,,a]= [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] --- a=<span class="number">3</span></span><br></pre></td></tr></table></figure></li><li><p>解构失败：变量比值多</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a,b,c] = [<span class="number">1</span>] </span><br><span class="line">返回值：a=<span class="number">1</span>,b=undefind,c=undefind</span><br></pre></td></tr></table></figure></li><li><p><strong>拓展默认值</strong></p><ul><li>—解构失败的情况下，变量如果有默认值的情况下就显示默认值，有值的时候显示值</li><li>赋值为undefined时默认值生效，赋值为null时默认值不生效</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a=<span class="number">1</span>,b=<span class="number">2</span>,c=<span class="number">3</span>] = [<span class="number">10</span>]<span class="comment">// 返回 a=10,b=2,c=3；</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [a=<span class="number">1</span>,b=<span class="number">2</span>,c=<span class="number">3</span>] = [<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>] <span class="comment">//返回a=10,b=20,c=30；</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [a=<span class="number">1</span>,b=<span class="number">2</span>,c=<span class="number">3</span>]=[<span class="number">10</span>,<span class="literal">undefined</span>,<span class="literal">undefined</span>] <span class="comment">//返回a=10,b=2,c=3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [a=<span class="number">1</span>,b=<span class="number">2</span>,c=<span class="number">3</span>]=[<span class="number">10</span>,<span class="literal">null</span>,<span class="literal">null</span>] <span class="comment">//返回a=10,b=null,c=null</span></span><br></pre></td></tr></table></figure><ul><li>默认值可以引用解构赋值的其他变量，但该变量必须已经声明</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [x = <span class="number">1</span>, y = x] = []; <span class="comment">// x=1;y=1</span></span><br><span class="line"><span class="keyword">let</span> [x = <span class="number">1</span>, y = x] = [<span class="number">2</span>]; <span class="comment">//x=2;y=2</span></span><br><span class="line"><span class="keyword">let</span> [x = <span class="number">1</span>, y = x] = [<span class="number">1</span>,<span class="number">2</span>]; <span class="comment">//x=1;y=2</span></span><br><span class="line"><span class="keyword">let</span> [x = y, y = <span class="number">1</span>] = [];<span class="comment">//ReferenceError: y is not defined </span></span><br><span class="line"><span class="comment">//最后一个表达式之所以会报错，是因为x用y做默认值时，y还没有声明</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h4><ul><li><p>数组的解构赋值，可以做数据交换</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">10</span> ;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">20</span> ;</span><br><span class="line">[a,b] = [b ,a]</span><br></pre></td></tr></table></figure></li></ul><h3 id="对象解构赋值"><a href="#对象解构赋值" class="headerlink" title="对象解构赋值"></a>对象解构赋值</h3><p><strong>无序 – 匹配属性名</strong></p><h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><ul><li>无序集合，必须按照属性 名匹配 ，所以解构中也没有缺省的情况。</li><li>完全解构，不完全解构、默认值和数组一样</li></ul><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><ul><li><p><strong>对象解构的作用</strong>：适用于取值，和函数的参数适用 </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">let</span> data = &#123;</span><br><span class="line">    username: <span class="string">&quot;xiaoming&quot;</span>,</span><br><span class="line">    age: <span class="number">18</span>,</span><br><span class="line">    address: <span class="string">&quot;长沙&quot;</span>,</span><br><span class="line">    sex: <span class="string">&quot;man&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> &#123;</span><br><span class="line">    username,</span><br><span class="line">    age</span><br><span class="line">&#125; = data;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(username, age)  <span class="comment">//xiaoming 18</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h4 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h4><ul><li><p>如果要将一个已经声明的变量用于解构赋值，必须非常小心</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误的写法</span></span><br><span class="line"><span class="keyword">let</span> x;</span><br><span class="line">&#123;x&#125; = &#123;<span class="attr">x</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="comment">// SyntaxError: syntax error</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>报错的原因：JavaScript引擎会将{x}理解成一个代码块，从而发生语法错误。只有不将大括号写在行首，避免JS将其解释为代码块，才能解决这个问题</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x;</span><br><span class="line">(&#123;x&#125; = &#123;<span class="attr">x</span>: <span class="number">1</span>&#125;)</span><br></pre></td></tr></table></figure></li></ul><h3 id="拓展-函数参数的解构赋值"><a href="#拓展-函数参数的解构赋值" class="headerlink" title="拓展 函数参数的解构赋值"></a>拓展 函数参数的解构赋值</h3><ul><li><p>函数的参数也可以适用解构赋值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">[x,y]</span>)</span>&#123;<span class="comment">//</span></span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line">add([<span class="number">1</span>,<span class="number">2</span>]);<span class="comment">//传入参数的那一刻，数组参数就被解构成x和y。对于函数内部的代码来说，参数就是x和y</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h2><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><p>``两个反 引号，变量用${  变量  }包裹  ，</p><h4 id="优点"><a href="#优点" class="headerlink" title="优点:"></a>优点:</h4><ul><li>换行不需要使用换行符，可以直接写html结构，</li><li>不需要考虑单双引号嵌套问题</li><li>${}里面也可以自己写js语句；</li><li>方便简洁不容易出错</li></ul><h2 id="对象的扩展"><a href="#对象的扩展" class="headerlink" title="对象的扩展"></a>对象的扩展</h2><h3 id="对象的简写"><a href="#对象的简写" class="headerlink" title="对象的简写"></a>对象的简写</h3><h4 id="对象属性的简写"><a href="#对象属性的简写" class="headerlink" title="对象属性的简写"></a>对象属性的简写</h4><ul><li><p>属性名和属性值的变量名相同的情况下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> username = <span class="string">&quot;xiaoming&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> age = <span class="number">18</span>;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    username,</span><br><span class="line">    age</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(obj)</span><br></pre></td></tr></table></figure></li></ul><h4 id="对象方法的简写"><a href="#对象方法的简写" class="headerlink" title="对象方法的简写"></a>对象方法的简写</h4><ul><li><p>省略冒号和function</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="function"><span class="title">eat</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;红烧肉&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.eat()</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h4 id="对象表达式"><a href="#对象表达式" class="headerlink" title="对象表达式"></a>对象表达式</h4><ul><li><p>一般情况下：[]使用的是变量，表达式，属性为数字时也使用[]</p></li><li><p>obj[]—[]里面放的是变量不是属性名，如果使用[]要获取属性名，[]里就要加字符串，也就是变量需要加引号，  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> username = <span class="string">&quot;hello&quot;</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    username: <span class="string">&quot;a&quot;</span>,</span><br><span class="line">    [username]: <span class="string">&quot;b&quot;</span>,</span><br><span class="line">    <span class="number">10</span>: <span class="string">&quot;world&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(obj) <span class="comment">// &#123;10: &quot;world&quot;, username: &quot;a&quot;, hello: &quot;b&quot;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.username)  <span class="comment">//a</span></span><br><span class="line"><span class="built_in">console</span>.log(obj[<span class="string">&#x27;username&#x27;</span>]) <span class="comment">//a</span></span><br><span class="line"><span class="built_in">console</span>.log(obj[username]) <span class="comment">//b</span></span><br><span class="line">obj[<span class="string">&quot;a&quot;</span> + <span class="string">&quot;b&quot;</span>] = <span class="string">&quot;ab&quot;</span>; <span class="comment">//添加了一个属性名为ab的属性</span></span><br><span class="line"><span class="built_in">console</span>.log(obj)  <span class="comment">// &#123;10: &quot;world&quot;, username: &quot;a&quot;, hello: &quot;b&quot;, ab: &quot;ab&quot;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj[<span class="number">10</span>])  <span class="comment">//world</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h3 id="对象的方法"><a href="#对象的方法" class="headerlink" title="对象的方法"></a>对象的方法</h3><ul><li><p>数组的拼接：cancat()</p></li><li><p>对象拼接Object.assign(): 可以实现对象的浅拷贝</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一个参数是目标对象,从第二个参数开始就要拼接的对象</span></span><br><span class="line"><span class="keyword">let</span> o1 = &#123;</span><br><span class="line">    a: <span class="number">10</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> o2 = &#123;</span><br><span class="line">    b: <span class="number">20</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Object</span>.assign(o1, o2, &#123;</span><br><span class="line">    c: <span class="number">30</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(o1)<span class="comment">//&#123;a: 10, b: 20, c: 30&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>Object.keys() 返回的是一个数组,数组里面是对象所有的属性名</p></li><li><p>Object.values() 返回的是一个数组,数组里面是对象所有的值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> o = &#123;</span><br><span class="line">    a: <span class="number">10</span>,</span><br><span class="line">    b: <span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.keys(o)) <span class="comment">//[&quot;a&quot;, &quot;b&quot;]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.values(o))  <span class="comment">//[10, 20]</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="对象属性的设置"><a href="#对象属性的设置" class="headerlink" title="对象属性的设置"></a>对象属性的设置</h3><ul><li><p>获取对象中某个属性的描述对象；</p></li><li><p>设置对象中的某一个属性的特性：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数据劫持 vue</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    a: <span class="number">10</span>,</span><br><span class="line">    b: <span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取对象中的某个属性的设置</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, <span class="string">&quot;a&quot;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">&quot;a&quot;</span>, &#123;</span><br><span class="line">    writable: <span class="literal">false</span>, <span class="comment">// 值是否可以重写</span></span><br><span class="line">    enumerable: <span class="literal">false</span>, <span class="comment">// 是否可以循环遍历</span></span><br><span class="line">    value: <span class="string">&quot;world&quot;</span>,</span><br><span class="line">    configurable: <span class="literal">false</span> <span class="comment">// 是否可以重新修改属性的设置</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">obj.a = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="函数拓展"><a href="#函数拓展" class="headerlink" title="函数拓展"></a>函数拓展</h2><h3 id="函数默认值"><a href="#函数默认值" class="headerlink" title="函数默认值"></a>函数默认值</h3><ul><li><p>直接在形参上进行赋值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">x = <span class="string">&quot;hello&quot;</span></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn(<span class="number">10</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>特点</p><ul><li>不传实参，默认值生效</li><li>传递undefined，默认值生效</li><li>传递null，默认值不生效</li></ul></li><li><p>注意参数的位置</p><p>在参数传递过程中，要注意位置问题；</p><p>如果是最后一个参数的话，可以忽略不传递实参；</p><p>但是其他位置的话，要用undefined；</p><ul><li>解决方法1：有默认值的参数放到最后</li><li>解决方法2：形参和实参都以对象的形式（对象解构赋值）</li></ul></li></ul><h3 id="rest剩余参数"><a href="#rest剩余参数" class="headerlink" title="rest剩余参数"></a>rest剩余参数</h3><ul><li><p>语法：…变量名</p><ul><li>返回的是一个数组，接收的是没有形参接收的值</li><li>剩余参数必须写在形参的最后。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">x, y, ...rest</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(rest)  <span class="comment">//[3,4,5]</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">Array</span>.isArray(rest))  <span class="comment">//true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure></li></ul><h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数*"></a>箭头函数*</h3><h4 id="语法："><a href="#语法：" class="headerlink" title="语法："></a>语法：</h4><ul><li><p>箭头左边（参数）</p><ul><li>一个参数的情况（）括号可以省略</li></ul></li><li><p>箭头右边（函数的执行代码）</p><ul><li>执行代码只有一句话的时候{}和return可以省略，但是对象要注意，加上（）避免代码歧义。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="params">v</span> =&gt;</span> v;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> (<span class="params">v</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> v;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f = <span class="function">() =&gt;</span> <span class="number">5</span>;<span class="comment">//不需要参数或需要多个参数，就使用一个圆括号代表参数部分。</span></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="number">5</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sum = <span class="function">(<span class="params">num1, num2</span>) =&gt;</span> num1 + num2;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">var</span> sum = <span class="function"><span class="keyword">function</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号，否则会报错。</span></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">let</span> getTempItem = <span class="function"><span class="params">id</span> =&gt;</span> &#123; <span class="attr">id</span>: id, <span class="attr">name</span>: <span class="string">&quot;Temp&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不报错</span></span><br><span class="line"><span class="keyword">let</span> getTempItem = <span class="function"><span class="params">id</span> =&gt;</span> (&#123; <span class="attr">id</span>: id, <span class="attr">name</span>: <span class="string">&quot;Temp&quot;</span> &#125;);</span><br></pre></td></tr></table></figure></li></ul><h4 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h4><ul><li><p>this指向的是定义<strong>this</strong>所在的对象，并且call、apply、bind是无法改变this的指向，</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="function"><span class="title">fn</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    f1: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>) <span class="comment">// window</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.fn() <span class="comment">//this</span></span><br><span class="line">obj.f1() <span class="comment">// window</span></span><br></pre></td></tr></table></figure><ul><li>this是固定的=&gt;有利于封装回调函数；</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将DOM事件的回调函数封装在一个对象里</span></span><br><span class="line"><span class="keyword">var</span> handler = &#123;</span><br><span class="line">  id: <span class="string">&#x27;123456&#x27;</span>,</span><br><span class="line"></span><br><span class="line">  init: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">document</span>.addEventListener(<span class="string">&#x27;click&#x27;</span>,</span><br><span class="line">      event =&gt; <span class="built_in">this</span>.doSomething(event.type), <span class="literal">false</span>);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  doSomething: <span class="function"><span class="keyword">function</span>(<span class="params">type</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Handling &#x27;</span> + type  + <span class="string">&#x27; for &#x27;</span> + <span class="built_in">this</span>.id);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//使用了箭头函数，导致这个箭头函数里面的this，总是指向handler对象。否则，回调函数运行时，this.doSomething这一行会报错，因为此时this指向document对象</span></span><br></pre></td></tr></table></figure></li><li><p>箭头函数不能当做构造函数使用，不能使用<strong>new</strong>命令</p></li><li><p>箭头函数没有<strong>prototype</strong>显示原型；</p></li><li><p>箭头函数不能使用<strong>arguments</strong>，在遇到不定参的情况使用剩余参数代替（…变量名）；</p></li></ul><h4 id="不适用场景"><a href="#不适用场景" class="headerlink" title="不适用场景"></a>不适用场景</h4><ul><li><p>对象中方法的简写不要使用箭头函数</p></li><li><p>事件绑定函数，要谨慎使用箭头函数</p></li></ul><h3 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h3><ul><li><p>关键字   use strict ;    必须放在第一行</p></li><li><p>规则</p><ul><li> 变量先声明再使用</li><li> 不允许指向全局对象，返回的是undefined</li><li>对arguments的限制：<ul><li>不允许重新赋值</li><li>不再追踪参数的变化</li><li>arguments.callee返回的是函数的本身，但是在严格模式下，不允许使用；</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// arguments=10;</span></span><br><span class="line">    num++;</span><br><span class="line">    <span class="built_in">console</span>.log(num)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>对于只读属性重新赋值是会报错的</p></li></ul><h2 id="数组拓展"><a href="#数组拓展" class="headerlink" title="数组拓展"></a>数组拓展</h2><h3 id="拓展运算符…"><a href="#拓展运算符…" class="headerlink" title="拓展运算符…"></a>拓展运算符…</h3><h4 id="…"><a href="#…" class="headerlink" title="…"></a>…</h4><ul><li><p>拓展运算符是三个点(…)</p></li><li><p>剩余参数的逆运用，将数组转换为参数序列</p></li></ul><h4 id="数组运用"><a href="#数组运用" class="headerlink" title="数组运用"></a>数组运用</h4><ul><li><p>数组去重</p></li><li><p>拉平多维数组(推荐使用flat())</p></li><li><p>实现浅拷贝</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数组去重</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>];</span><br><span class="line"><span class="built_in">console</span>.log([...new <span class="built_in">Set</span>(arr)])</span><br><span class="line"></span><br><span class="line"><span class="comment">//拉平多维数组</span></span><br><span class="line"><span class="keyword">let</span> arr = [</span><br><span class="line">    [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">    [<span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">];</span><br><span class="line"><span class="keyword">let</span> newArr = []</span><br><span class="line">arr.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">    newArr.push(...item)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(newArr)</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现浅拷贝</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> arr2 = [...arr];</span><br><span class="line">arr[<span class="number">0</span>] = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(arr, arr2)</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h4 id="对象运用"><a href="#对象运用" class="headerlink" title="对象运用"></a>对象运用</h4><ul><li><p>对象浅拷贝</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">let</span> obj = &#123;</span><br><span class="line">    a: <span class="number">10</span>,</span><br><span class="line">    b: <span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj2 = &#123;...obj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>模拟vuex</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> mapState = &#123;</span><br><span class="line">userInfo: &#123;</span><br><span class="line">    username: <span class="string">&quot;xiaoming&quot;</span>,</span><br><span class="line">    age: <span class="number">18</span></span><br><span class="line">&#125;,</span><br><span class="line">admin: &#123;</span><br><span class="line">    username: <span class="string">&quot;guanliyuan&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> mapMutations = &#123;</span><br><span class="line"><span class="function"><span class="title">run</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;xiaoming 正在跑&quot;</span>)</span><br><span class="line">&#125;,</span><br><span class="line"><span class="function"><span class="title">eat</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;排骨&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> vm = &#123;</span><br><span class="line">data: &#123;</span><br><span class="line">    ...mapState <span class="comment">//浅拷贝mapState，这样在mapState中可以随需求添加数据</span></span><br><span class="line">&#125;,</span><br><span class="line">methods: &#123;</span><br><span class="line">    ...mapMutations</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(vm)</span><br></pre></td></tr></table></figure></li></ul><h3 id="数组方法的扩展"><a href="#数组方法的扩展" class="headerlink" title="数组方法的扩展"></a>数组方法的扩展</h3><ul><li><p>Array.of()  将参数内的数据转为数组，弥补new Array()的不足</p></li><li><p>find()和findIndex()</p><ul><li>find  返回符合条件的第一个成员</li><li>findIndex  返回符合条件的第一个成员的下标索引</li></ul></li><li><p>Includes()   判断是否含有某一个成员（在字符串中也可以使用）；返回的是一个布尔值；</p></li><li><p>Array.from()    伪数组转真数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">5</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr)  <span class="comment">//(5) [empty × 5]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr2 = <span class="built_in">Array</span>.of(<span class="number">5</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr2)  <span class="comment">//[5]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr3 = <span class="built_in">Array</span>.of(<span class="literal">true</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr3)  <span class="comment">//[true]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr4 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> index = arr4.findIndex(<span class="function">(<span class="params">item, index, obj</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> item &gt; <span class="number">3</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(index)  <span class="comment">//3  (第一个满足条件的下标是3)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> x = arr4.find(<span class="function">(<span class="params">item, index, obj</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> item &gt; <span class="number">3</span> </span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(x) <span class="comment">//4  (第一个满足条件的是4)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr5 = [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr5.includes(<span class="string">&quot;hello&quot;</span>))   <span class="comment">//false</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="Symbol（）"><a href="#Symbol（）" class="headerlink" title="Symbol（）"></a>Symbol（）</h2><h3 id="概念和作用"><a href="#概念和作用" class="headerlink" title="概念和作用"></a>概念和作用</h3><ul><li><p>ES6新增了Symbol数据类型(是基础数据类型)，它用来<strong>生成一个独一无二的值</strong></p></li><li><p>Symbol数据常用来<strong>给对象属性赋值</strong>，让对象属性具备唯一性，不容易被覆盖。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">obj&#123;</span><br><span class="line">    a: <span class="number">10</span>,</span><br><span class="line">    a: <span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(obj)</span><br><span class="line"><span class="comment">//因为obj中属性名a冲突了，所以打印出来的结果会是</span></span><br><span class="line"><span class="comment">//  obj&#123; a: 20&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//因此，为了避免这种情况，可以用symbol当作属性名</span></span><br><span class="line"></span><br><span class="line">obj&#123;</span><br><span class="line">    [<span class="built_in">Symbol</span>()]:<span class="number">10</span>,</span><br><span class="line">    [<span class="built_in">Symbol</span>()]:<span class="number">20</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>注：括号内可以加字符串，但只是对该Symbol进行解释说明（字符串相同时，两个symbol也不相等）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>(<span class="string">&#x27;s1&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">Symbol</span>(<span class="string">&#x27;s2&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(s1, s2)  <span class="comment">//Symbol(s1) Symbol(s2)</span></span><br><span class="line"><span class="built_in">console</span>.log(s1.description)  <span class="comment">//s1</span></span><br><span class="line"><span class="built_in">console</span>.log(s1 === s2)   <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> s3 = <span class="built_in">Symbol</span>(<span class="string">&quot;s3&quot;</span>)</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    [<span class="built_in">Symbol</span>()]: <span class="number">10</span>,</span><br><span class="line">    [<span class="built_in">Symbol</span>()]: <span class="number">20</span>,</span><br><span class="line">    [s3]: <span class="number">30</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(obj)<span class="comment">//&#123;Symbol(): 10, Symbol(): 20, Symbol(s3): 30&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>以 Symbol 值作为键名，不会被常规方法遍历得到（见7.3拓展）。我们可以利用这个特性，为对象定义一些非私有的、但又希望只用于内部的方法。</p></li></ul><h4 id="实例-消除魔术字符串"><a href="#实例-消除魔术字符串" class="headerlink" title="实例: 消除魔术字符串"></a>实例: 消除魔术字符串</h4><ul><li><p>魔术字符串  在代码之中多次出现、与代码形成强耦合的某一个具体的字符串或数值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getArea</span>(<span class="params">shape, options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> area = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (shape) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;Triangle&#x27;</span>: <span class="comment">// 魔术字符串</span></span><br><span class="line">      area = <span class="number">.5</span> * options.width * options.height;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">/* ... more code ... */</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> area;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getArea(<span class="string">&#x27;Triangle&#x27;</span>, &#123; <span class="attr">width</span>: <span class="number">100</span>, <span class="attr">height</span>: <span class="number">100</span> &#125;); <span class="comment">// 魔术字符串</span></span><br></pre></td></tr></table></figure><p>上面代码中，字符串<code>Triangle</code>就是一个魔术字符串。它多次出现，与代码形成“强耦合”，不利于将来的修改和维护。</p></li><li><p>用Symbol值解决</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> shapeType = &#123;</span><br><span class="line">  triangle: <span class="built_in">Symbol</span>()</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getArea</span>(<span class="params">shape, options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> area = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">switch</span> (shape) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="built_in">Symbol</span>():</span><br><span class="line">      area = <span class="number">.5</span> * options.width * options.height;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> area;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getArea(<span class="built_in">Symbol</span>(), &#123; <span class="attr">width</span>: <span class="number">100</span>, <span class="attr">height</span>: <span class="number">100</span> &#125;);</span><br></pre></td></tr></table></figure></li></ul><h3 id="Symbol的方法"><a href="#Symbol的方法" class="headerlink" title="Symbol的方法"></a>Symbol的方法</h3><h4 id="s-description"><a href="#s-description" class="headerlink" title="s.description"></a>s.description</h4><p>获取Symbol()字符串的值</p><h4 id="Symbol-for"><a href="#Symbol-for" class="headerlink" title="Symbol.for()"></a>Symbol.for()</h4><ul><li><p>Symbol.for(‘’)  搜索是否有以该参数为名称的Symbol值</p><ul><li>有则返回这个Symbol值，否则新建一个以该字符串为名称的Symbol值，并将其注册到全局</li><li>如果里面的字符串的内容相同，Symbol也是相同</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>.for(<span class="string">&quot;s1&quot;</span>)</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">Symbol</span>.for(<span class="string">&quot;s1&quot;</span>)</span><br><span class="line"><span class="keyword">let</span> s3 = <span class="built_in">Symbol</span>.for(<span class="string">&#x27;s4&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(s1)  <span class="comment">//Symbol(s1)</span></span><br><span class="line"><span class="built_in">console</span>.log(s2)  <span class="comment">//Symbol(s1)</span></span><br><span class="line"><span class="built_in">console</span>.log(s3)  <span class="comment">//Symbol(s4)</span></span><br><span class="line"><span class="built_in">console</span>.log(s1 === s2)    <span class="comment">//true</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p><code>Symbol.for()</code>与<code>Symbol()</code>这两种写法，都会生成新的 Symbol。它们的区别是，</p><ul><li>前者会被登记在全局环境中供搜索，后者不会</li><li><code>Symbol.for()</code>不会每次调用就返回一个新的 Symbol 类型的值，而是会先检查给定的<code>key</code>是否已经存在，如果不存在才会新建一个值</li><li>比如，如果你调用<code>Symbol.for(&quot;cat&quot;)</code>30 次，每次都会返回同一个 Symbol 值，但是调用<code>Symbol(&quot;cat&quot;)</code>30 次，会返回 30 个不同的 Symbol 值。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Symbol</span>.for(<span class="string">&quot;bar&quot;</span>) === <span class="built_in">Symbol</span>.for(<span class="string">&quot;bar&quot;</span>)</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Symbol</span>(<span class="string">&quot;bar&quot;</span>) === <span class="built_in">Symbol</span>(<span class="string">&quot;bar&quot;</span>)</span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Symbol()写法没有登记机制，所以每次调用都会返回一个不同的值</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="Symbol-keyFor"><a href="#Symbol-keyFor" class="headerlink" title="Symbol.keyFor()"></a>Symbol.keyFor()</h4><ul><li><p>返回一个已登记的 Symbol 类型值的key</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>.for(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line"><span class="built_in">Symbol</span>.keyFor(s1) <span class="comment">// &quot;foo&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">Symbol</span>(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line"><span class="built_in">Symbol</span>.keyFor(s2) <span class="comment">// undefined</span></span><br><span class="line"><span class="comment">//s2属于未登记的Symbol值</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="拓展-属性名的遍历"><a href="#拓展-属性名的遍历" class="headerlink" title="拓展 属性名的遍历"></a>拓展 属性名的遍历</h3><ul><li><p>Symbol 作为属性名，遍历对象的时候，该属性不会出现在<code>for...in</code>、<code>for...of</code>循环中，也不会被<code>Object.keys()</code>、<code>Object.getOwnPropertyNames()</code>、<code>JSON.stringify()</code>返回。</p></li><li><p><code>Object.getOwnPropertySymbols()</code>方法，可以获取指定对象的所有 Symbol 属性名。该方法返回一个数组，成员是当前对象的所有用作属性名的 Symbol 值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> obj1 = &#123;<span class="string">&#x27;a&#x27;</span>:<span class="number">10</span>, <span class="string">&#x27;b&#x27;</span>:<span class="number">20</span>&#125;</span><br><span class="line"><span class="keyword">let</span> a = <span class="built_in">Symbol</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> b = <span class="built_in">Symbol</span>(<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line"></span><br><span class="line">obj[a] = <span class="string">&#x27;Hello&#x27;</span>;</span><br><span class="line">obj[b] = <span class="string">&#x27;World&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> obj)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key)  <span class="comment">//无输出</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> obj1)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key)  <span class="comment">//a  b</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> objectSymbols = <span class="built_in">Object</span>.getOwnPropertySymbols(obj);</span><br><span class="line"><span class="built_in">console</span>.log(objectSymbols)<span class="comment">// [Symbol(a), Symbol(b)]</span></span><br><span class="line"><span class="keyword">const</span> objNames = <span class="built_in">Object</span>.getOwnPropertyNames(obj);</span><br><span class="line"><span class="built_in">console</span>.log(objNames)  <span class="comment">//[]</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="set和map"><a href="#set和map" class="headerlink" title="set和map"></a>set和map</h2><h4 id="set"><a href="#set" class="headerlink" title="set"></a>set</h4><ul><li><p>Set()本身是一个构造函数，用来实例化Set数据类型（类似于数组的数据结构，特点：不允许有重复项。</p></li><li><p>set实例的操作方法—用来操作数据</p><p>let s = new Set（）；</p><ul><li><p>s.size : 返回长度</p></li><li><p>s.add()  : 添加某个值，返回set结构本身</p></li><li><p>s.delete() : 删除值，删除成功返回true，否则返回false</p></li><li><p>s.has() ： 判断是否是set的成员，返回布尔值</p></li><li><p>s.clear() : 清除所有的成员，没有返回值。</p></li></ul></li><li><p>set实例的遍历方法—-遍历成员</p></li></ul><h4 id="map"><a href="#map" class="headerlink" title="map"></a>map</h4><ul><li><p>Map对象保存键值对。是类似对象的数据解构。任何值(对象或者原始值) 都可以作为一个键或一个值</p></li><li><p>常用方法：</p><ul><li>m.size 成员的个数</li><li>m.set([1, 2, 3], “content3”)  添加一个内容</li><li>m.get(属性) 获取对应的值</li><li>m.has(属性) 判断属性是否存在</li><li>m.delete(属性) 删除属性</li><li>m.clear()  删除所有的属性</li></ul></li><li><p>Map和Object的区别</p><ul><li>一个Object 的键只能是字符串或者 Symbols，但一个Map 的键可以是任意值。</li><li>Map中的键值是有序的（FIFO 原则），而添加到对象中的键则不是。</li><li>Map的键值对个数可以从 size 属性获取，而 Object 的键值对个数只能手动计算。</li><li>Object 都有自己的原型，原型链上的键名有可能和你自己在对象上的设置的键名产生冲突。</li></ul></li></ul><h2 id="promise"><a href="#promise" class="headerlink" title="promise"></a>promise</h2><h3 id="promise概念，then、catch方法"><a href="#promise概念，then、catch方法" class="headerlink" title="promise概念，then、catch方法"></a>promise概念，then、catch方法</h3><ul><li><p>概念和理解：</p><ul><li>是ES6<strong>解决异步回调问题</strong>的一种解决方案</li></ul><p>由于js是单线程，很多异步操作都是依靠回调方法实现的，这种做法在逻辑比较复杂的回调嵌套中会相当复杂，也叫做回调地狱；</p><ul><li>Promise对象可以理解为一次执行的异步操作，使用Promise对象之后，使用一种链式调用的方式来组织代码，让程序更具备可读性，可维护性</li></ul><p>=&gt;可以<strong>将异步操作以同步的操作的流程表达出来</strong>，避免了层层嵌套的回调函数</p><ul><li>promise和回调函数一样，都是要<strong>解决数据的传递和消息发送问题</strong>，promise中的then一般对应成功后的数据处理，catch一般对应失败后的数据处理。</li></ul></li><li><p>语法：</p><p>promise是一个构造函数，使用时一般都需要new 一个实例对象。</p><p>接受一个函数作为参数，函数中也有两个参数（resolve，reject），resolve将异步操作成功状态下的结果返回。reject将异步操作失败状态写的结果返回。</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">           <span class="keyword">if</span>(ture)&#123;</span><br><span class="line">               resolve(<span class="string">&#x27;成功&#x27;</span>)</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               reject(<span class="string">&#x27;失败&#x27;</span>)</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);<span class="comment">//p就是实例化的promise对象</span></span><br></pre></td></tr></table></figure><ul><li>then方法：接受两个回调函数作为参数，第一个回调函数是promise状态为resolve状态下调用，第二个时reject状态下调用。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">p.then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;<span class="comment">//第一个回调函数res是个参数,接收resolve括号里返回的结果</span></span><br><span class="line">    <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;,<span class="function"><span class="params">err</span>=&gt;</span>&#123;<span class="comment">//第二个回调函数，res是个参数,接收resolve括号里返回的结果</span></span><br><span class="line">    <span class="built_in">console</span>.log(err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>catch方法：promise失败状态调用。 同时也可以捕获到一些编写错误的代码，让错误以字符串的形式体现，不报错影响后续代码执行。 </li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p.catch(<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="Promise特点"><a href="#Promise特点" class="headerlink" title="Promise特点"></a>Promise特点</h3><ul><li><p>对象的状态不受外界影响</p><ul><li><p>三 个状态：进行中pending，已成功fulfilled，已失败rejected</p><p>pending表示程序正在执行但未得到结果，即异步操作没有执行完毕，fulfilled表示程序执行完毕，且执行成功，rejected表示执行完毕但失败；</p><p>这里的成功和失败都是逻辑意义上的；并非是要报错</p></li><li><p>只有异步操作的结果可以决定当前是哪一种状态，任何其他操作都无法改变这个状态</p></li><li><p>一旦创建就会立即执行 ，处于进行中，内部直接执行的为同步，</p></li><li><p>resolve，reject—进行中转为了成功或失败，再使用then方法调用的是属于异步。   </p></li><li><p>没有调用resolve，reject时处理进行中状态，进行中下没有状态返回。</p></li></ul></li><li><p>一旦状态改变，就不会再变，任何时候都可以得到这个结果</p><ul><li>Promise状态改变只有两种可能:  pending =&gt;fulfilled    pending=&gt;rejected</li><li>一旦这两种情况发生，状态就凝固了，会一直保持这个结果，如果改变已经发生，再对Promise对象添加回调函数，也会立即得到这个结果</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;&#125;);</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    resolve(p1)</span><br><span class="line">&#125;)</span><br><span class="line">p2.then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res)<span class="comment">//此时没有结果，因为p1没有resolve或者reject调用此时是进行中的状态，没有返回值，所有p2返会p1时也没有东西。</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li><p>Promise里面同步和异步的判定</p><ul><li>里面是一个同步任务(状态为pending)</li><li>调用resolve/reject方法，状态就会发生改变</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;promise&quot;</span>) <span class="comment">//同步任务  =&gt; 进行中</span></span><br><span class="line">    resolve(<span class="string">&quot;成功&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line">p.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">123</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(res) <span class="comment">// 异步任务 （微任务）</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line"><span class="comment">//输出顺序  1   promise  2  123  成功</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h3 id="promise的链式操作"><a href="#promise的链式操作" class="headerlink" title="promise的链式操作"></a>promise的链式操作</h3><ul><li>必须在前一个then有return返回值，如果return是一个Promise对象，then 就接收的是promise对象中成功状态下的值。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;  </span><br><span class="line">         <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">             resolve(n)</span><br><span class="line">         &#125;, <span class="number">1000</span>)</span><br><span class="line">     &#125;)</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> fn(<span class="number">5</span>).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">     <span class="built_in">console</span>.log(res)</span><br><span class="line">     <span class="keyword">return</span> fn(++res)</span><br><span class="line"> &#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">     <span class="built_in">console</span>.log(res)</span><br><span class="line">     <span class="keyword">return</span> fn(++res)</span><br><span class="line"> &#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">     <span class="built_in">console</span>.log(res)</span><br><span class="line"> &#125;)</span><br></pre></td></tr></table></figure><h3 id="Promise-all-和Promise-race"><a href="#Promise-all-和Promise-race" class="headerlink" title="Promise.all()和Promise.race()"></a>Promise.all()和Promise.race()</h3><ul><li> Promise.all()  处理并发 ，所有值就一起返回</li><li> Promise.race()  返回请求完成最快的—–(一般用于设置请求超时提示）</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个请求如果超过500ms，返回请求超时提示信息</span></span><br><span class="line">        <span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                resolve(<span class="string">&quot;我是正确的请求&quot;</span>)</span><br><span class="line">            &#125;, <span class="number">300</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                resolve(<span class="string">&quot;请求超时&quot;</span>)</span><br><span class="line">            &#125;, <span class="number">500</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="built_in">Promise</span>.race([p1, p2]).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(res)</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure><ul><li>错误信息的处理<ul><li>直接在promise.all().catch(),只能返回错误信息，其他正确的信息无法返回。</li><li>谁报错谁自己处理，其他信息可以正确返回。</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                resolve(<span class="string">&quot;p1&quot;</span>)</span><br><span class="line">            &#125;, <span class="number">500</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                resolve(<span class="string">&quot;p2&quot;</span>)</span><br><span class="line">            &#125;, <span class="number">3500</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">let</span> p3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                reject(<span class="string">&quot;p3&quot;</span>)</span><br><span class="line">            &#125;, <span class="number">1000</span>)</span><br><span class="line">        &#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(err)</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 要求所有的值是一起返回的</span></span><br><span class="line">        <span class="built_in">Promise</span>.all([p1, p2, p3]).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(res)</span><br><span class="line">            &#125;)</span><br><span class="line">            .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(err)</span><br></pre></td></tr></table></figure><h2 id="iterator和for…of循环"><a href="#iterator和for…of循环" class="headerlink" title="iterator和for…of循环"></a>iterator和for…of循环</h2><h3 id="概念和作用-1"><a href="#概念和作用-1" class="headerlink" title="概念和作用"></a>概念和作用</h3><ul><li>概念：</li></ul><p>在集合的数据结构中，数组，对象，set，map 需要统一接口，来进行处理。Iterator就是这个机制，为不同的数据结构提供统一的接口，任何的数据结构，只要部署了iterator就可以进行循环遍历。</p><ul><li><strong>作用</strong><ul><li>1.为各种数据结构提供统一的、简便的访问接口，</li><li>2.使数据结构的成员能够按某种次序排列，</li><li>3.为for…of…提供消费</li></ul></li><li>Iterator的原理<ul><li>（1）创建一个指针对象，指向当前数据结构的起始位置。也就是说，遍历器对象本质上，就是一个指针对象。</li><li>（2）第一次调用指针对象的next方法，可以将指针指向数据结构的第一个成员。</li><li>（3）第二次调用指针对象的next方法，指针就指向数据结构的第二个成员。</li><li>（4）不断调用指针对象的next方法，直到它指向数据结构的结束位置。</li></ul></li></ul><p>每一次调用next方法，都会返回数据结构的当前成员的信息。具体来说，就是返回一个包含value和done两个属性的对象。其中，value属性是当前成员的值，done属性是一个布尔值，表示遍历是否结束，值为true的时候表示遍历结束</p><ul><li><p>模拟Iterator</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myIterator</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="function"><span class="title">next</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> index &lt; arr.length?&#123;</span><br><span class="line">                value:arr[index++],<span class="comment">//因为闭包了，所以index++会储存在这个函数的作用域中</span></span><br><span class="line">                done:<span class="literal">false</span></span><br><span class="line">            &#125;:&#123;</span><br><span class="line">                value:<span class="literal">undefined</span>,</span><br><span class="line">                done:<span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> arr_iter = myIterator(arr);</span><br><span class="line"><span class="built_in">console</span>.log(arr_iter.next())   <span class="comment">//&#123;value: 1, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(arr_iter.next())   <span class="comment">//&#123;value: 2, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(arr_iter.next())   <span class="comment">//review.html:28 &#123;value: 3, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(arr_iter.next())   <span class="comment">//review.html:29 &#123;value: undefined, done: true&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h3 id="部署Iterator接口"><a href="#部署Iterator接口" class="headerlink" title="部署Iterator接口"></a>部署Iterator接口</h3><ul><li><p><strong>Symbol.iterator属性(默认Iterator接口)</strong></p><p>在数据结构上部署iterator接口表现形式为，<strong>给对象或数组等集合增加</strong>Symbol.iterator<strong>属性</strong>，属性的内容是一个根据iterator接口规范自行实现的方法</p><p>=&gt; 一个数据结构只要有了Symbol.iterator属性，即是“可遍历的”</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> arr_iterator = arr[<span class="built_in">Symbol</span>.iterator]();</span><br><span class="line"><span class="built_in">console</span>.log(arr_iter.next())   <span class="comment">//&#123;value: 1, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(arr_iter.next())   <span class="comment">//&#123;value: 2, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(arr_iter.next())   <span class="comment">//review.html:28 &#123;value: 3, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(arr_iter.next())   <span class="comment">//review.html:29 &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>原生具备Iterator接口的数据结构</p><p>Array<br>Map<br>Set<br>String<br>TypedArray<br>函数的 arguments 对象<br>NodeList 对象</p><p>调用这个属性，就能得到遍历器对象</p></li><li><p>对象部署Iterator</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">obj[<span class="built_in">Symbol</span>.iterator] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        next: <span class="function">() =&gt;</span>&#123; <span class="comment">//如果是用function()则this输出的是next方法</span></span><br><span class="line">            <span class="comment">// console.log(this); //对象本身</span></span><br><span class="line">            <span class="comment">// console.log(Object.keys(this)) //对象的所有属性 =&gt; 数组</span></span><br><span class="line">            <span class="comment">// console.log(Object.keys(this)[index]) // 获取数组中对应索引下标的值</span></span><br><span class="line">            <span class="comment">// console.log(obj[Object.keys(this)[index]]) //获取对应的属性名的值 </span></span><br><span class="line">            <span class="keyword">if</span>(index &lt; <span class="built_in">Object</span>.keys(<span class="built_in">this</span>).length)&#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> &#123;<span class="attr">value</span>: obj[<span class="built_in">Object</span>.keys(<span class="built_in">this</span>)[index++]],</span><br><span class="line">                done: <span class="literal">false</span>&#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;<span class="attr">value</span>: <span class="literal">undefined</span>,</span><br><span class="line">                done: <span class="literal">true</span>&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> y = obj[<span class="built_in">Symbol</span>.iterator]()</span><br><span class="line"><span class="built_in">console</span>.log(y.next())</span><br><span class="line"><span class="built_in">console</span>.log(y.next())</span><br><span class="line"><span class="built_in">console</span>.log(y.next())</span><br></pre></td></tr></table></figure></li></ul><h3 id="for…in-和-for…of循环"><a href="#for…in-和-for…of循环" class="headerlink" title="for…in 和 for…of循环"></a>for…in 和 for…of循环</h3><h4 id="for…of"><a href="#for…of" class="headerlink" title="for…of"></a>for…of</h4><ul><li><p>一个数据结构只要部署了Symbol.iterator属性，就被视为具有 iterator 接口，就可以用for…of循环遍历它的成员。</p></li><li><p>也就是说，for…of循环内部调用的是数据结构的Symbol.iterator方法。</p></li></ul><h4 id="for…of-和-for…in的区别"><a href="#for…of-和-for…in的区别" class="headerlink" title="for…of  和  for…in的区别"></a>for…of  和  for…in的区别</h4><ul><li><p>for…in</p><ul><li>返回的是<strong>索引值</strong>，是以字符串的形式</li><li>不一定是按照一定的顺序返回的</li><li>不仅可以遍历本身的方法和属性，还可以遍历原型上的方法和属性</li></ul></li><li><p>for…of</p><ul><li>返回的是<strong>值</strong></li><li>是按照一定的顺序进行遍历</li><li>只能遍历本身的属性和方法</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123;<span class="attr">name</span>:<span class="string">&#x27;zhangsan&#x27;</span>,<span class="attr">age</span>:<span class="number">100</span>&#125;;</span><br><span class="line"><span class="built_in">Object</span>.prototype.sayHello = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Hello&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.prototype.str = <span class="string">&#x27;World&#x27;</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> myObject)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key)  <span class="comment">//name age sayHello str</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>];</span><br><span class="line">arr.foo = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> arr) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i); <span class="comment">// &quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;foo&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> arr) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i); <span class="comment">//  &quot;3&quot;, &quot;5&quot;, &quot;7&quot; </span></span><br><span class="line">  <span class="comment">//for...of方法不会返回arr的foo属性</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="generator"><a href="#generator" class="headerlink" title="generator"></a>generator</h2><h3 id="概念和语法"><a href="#概念和语法" class="headerlink" title="概念和语法"></a>概念和语法</h3><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><ul><li>语法上，首先可以把它理解成，Generator 函数是一个<strong>状态机</strong>，封装了多个内部状态。</li><li>执行Generator函数会<strong>返回一个遍历器对象</strong> =&gt; 是个遍历器对象生成函数。<br>返回的遍历器对象，可以依次遍历Generator函数内部的每一个状态</li><li>形式上：Generator是一个普通函数</li></ul><h4 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h4><ul><li><p>function关键字与函数名之间有一个星号；</p></li><li><p>函数体内部使用yield表达式，定义不同的内部状态（yield在英语里的意思就是“产出”）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">helloWorldGenerator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;world&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;ending&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> hw = helloWorldGenerator();</span><br></pre></td></tr></table></figure></li><li><p>调用该函数返回的是一个遍历器对象(指针指向内部对象)，必须调用遍历器对象的next的方法，指针才能移向下一个对象；<br>每调用一次next方法，内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个yield表达式(或return语句）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">        <span class="keyword">yield</span> <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">        <span class="keyword">yield</span> <span class="string">&#x27;world&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;ending&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> f_i = fn();</span><br><span class="line">    <span class="built_in">console</span>.log((f_i).next())  <span class="comment">// a  b   &#123;value:&quot;hello&quot;,done:false&#125;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="Yield表达式"><a href="#Yield表达式" class="headerlink" title="Yield表达式"></a>Yield表达式</h3><ul><li><p><strong>暂停执行函数的关键字</strong></p><p>由于 Generator 函数返回的遍历器对象，只有调用next方法才会遍历下一个内部状态，所以其实提供了一种可以暂停执行的函数。</p><p>yield表达式就是暂停标志。</p></li><li><p>运行逻辑（案例详见11.3的拓展题）</p><ul><li>（1）遇到<code>yield</code>表达式，就暂停执行后面的操作，并将紧跟在<code>yield</code>后面的那个表达式的值，作为返回的对象的value属性值。</li><li>（2）下一次调用<code>next</code>方法时，再继续往下执行，直到遇到下一个<code>yield</code>表达式。</li><li>（3）如果没有再遇到新的<code>yield</code>表达式，就一直运行到函数结束，直到return语句为止，并将<code>return</code>语句后面的表达式的值，作为返回的对象的value属性值。</li><li>（4）如果该函数没有<code>return</code>语句，则返回的对象的value属性值为undefined。</li></ul><p>不用yield表达式时，就变成了一个单纯的暂缓执行函数(调用next方法才能执行)</p></li></ul><h3 id="next方法的参数"><a href="#next方法的参数" class="headerlink" title="next方法的参数"></a>next方法的参数</h3><ul><li><p>yield表达式本身没有返回值，或者说总是返回undefined</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>*<span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">yield</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> fn_i = fn();</span><br><span class="line"><span class="built_in">console</span>.log(fn_i.next());  <span class="comment">//&#123;value: undefined, done: false&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>next方法可以带一个参数，该参数就会被当作<strong>上一个yield表达式的返回值</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="keyword">yield</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> f_i = fn();</span><br><span class="line"><span class="built_in">console</span>.log(f_i.next())  <span class="comment">//&#123;value: &quot;hello&quot;, done: false&#125;</span></span><br><span class="line">f_i.next(<span class="number">10</span>)   <span class="comment">//10</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>拓展题</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">function</span>* <span class="title">fn1</span>(<span class="params">x</span>) </span>&#123;<span class="comment">//行1</span></span><br><span class="line">    <span class="keyword">let</span> y = <span class="number">20</span> / (<span class="keyword">yield</span> x + <span class="number">100</span>)<span class="comment">//行2</span></span><br><span class="line">        <span class="built_in">console</span>.log(y)  <span class="comment">//5//行3</span></span><br><span class="line">    <span class="keyword">let</span> z = <span class="keyword">yield</span> y / <span class="number">2</span><span class="comment">//行4</span></span><br><span class="line">        <span class="built_in">console</span>.log(z)  <span class="comment">//6//行5</span></span><br><span class="line">    <span class="keyword">return</span> x + y + z<span class="comment">//行6</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> f_i = fn1(<span class="number">5</span>)</span><br><span class="line"><span class="built_in">console</span>.log(f_i.next());  <span class="comment">//&#123;value: 105, done: false&#125;  </span></span><br><span class="line"><span class="comment">//第一次调用next，返回第一个yield（行2）后面的表达式结果(一个遍历器对象)  &#123;value: 5+100, done: false&#125;  </span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(f_i.next(<span class="number">4</span>));  <span class="comment">//&#123;value: 2.5, done: false&#125; </span></span><br><span class="line"><span class="comment">//第二次调用next，继续执行行3，此时由于next的参数4传给了上一个yield表达式(行2)的返回值，因此 y = 20 / 4 = 5。而console.log(f_i.next(4))打印的是行4中yield的返回值  &#123;value: 5/2, done: false&#125; </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(f_i.next(<span class="number">6</span>)); <span class="comment">//&#123;value: 16, done: true&#125;  </span></span><br><span class="line"><span class="comment">//第三次调用next，同理继续执行 行5，此时由于next的参数是6，传给了行4中yield后的返回值，因此 z = 6；而console.log(f_i.next(6))打印的是最后return的遍历器对象 value = x+y+z = 5+5+6 = 16</span></span><br></pre></td></tr></table></figure></li><li><p>作用：可以在 Generator 函数运行的不同阶段，从外部向内部注入不同的值，从而调整函数行为。</p></li></ul><h2 id="async函数-async…await"><a href="#async函数-async…await" class="headerlink" title="async函数  async…await"></a>async函数  async…await</h2><h3 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h3><ul><li>async函数是 Generator 函数的语法糖</li><li>将generator函数的*换成了<code> async</code>，将<code>yield</code> 替换成  <code>await</code></li><li>async函数返回的是一个Promise对象,可以 使用promise对象的方法。可以看作多个异步操作，包装成的一个 Promise 对象</li></ul><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><ul><li><p>async函数返回的是一个Promise对象,可以 使用promise对象的方法</p><ul><li>使用then方法添加回调函数获取return后面的值</li><li>使用catch 来捕获错误信息</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(fn());  <span class="comment">//Promise &#123;&lt;resolved&gt;: &quot;hello&quot;&#125;  //返回的是一个Promise对象</span></span><br><span class="line">fn().then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res) <span class="comment">//&quot;hellp&quot;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//捕获错误信息</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line">    obj.run()</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn().then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err)<span class="comment">//TypeError: obj.run is not a function</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><h4 id="await-方法：一般情况下是结合promise对象使用。"><a href="#await-方法：一般情况下是结合promise对象使用。" class="headerlink" title="await()方法：一般情况下是结合promise对象使用。"></a>await()方法：一般情况下是结合promise对象使用。</h4><ul><li><p>只能在async函数中使用；</p></li><li><p>函数外面访问不到await及后面的表达式，如果需要在函数外部获取就需要在await前面加return。</p></li><li><p>await后面如果接的是promise对象，它拿到的是promise成功状态下的值(不需要再使用then），如果接的是其他类型就直接返回。 </p><ul><li><p><code>await</code>命令就是内部<code>then</code>命令的语法糖。</p></li><li><p>必须等待内部所有<code>await</code>命令后面的Promise对象执行完，才会发生状态改变，才会执行<code>then</code>方法指定的回调函数</p></li><li><p>任何一个<code>await</code>语句后面的 Promise 对象变为<code>reject</code>状态，那么整个<code>async</code>函数都会中断执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="built_in">Promise</span>.reject(<span class="string">&#x27;出错了&#x27;</span>);</span><br><span class="line">  <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="string">&#x27;hello world&#x27;</span>); <span class="comment">// 不会执行</span></span><br><span class="line">&#125;</span><br><span class="line">f().then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;<span class="built_in">console</span>.log(res)&#125;).catch(<span class="function"><span class="params">err</span>=&gt;</span>&#123;<span class="built_in">console</span>.log(err);&#125;)  <span class="comment">//出错了</span></span><br></pre></td></tr></table></figure></li><li><p>如果希望即使前一个异步操作失败，也不要中断后面的异步操作。这时可以将第一个<code>await</code>放在<code>try...catch</code>结构里面，这样不管这个异步操作是否成功，第二个<code>await</code>都会执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="built_in">Promise</span>.reject(<span class="string">&#x27;出错了&#x27;</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span>(er) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="string">&#x27;hello world&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f().then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res))</span><br><span class="line"><span class="comment">// hello world</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>async函数内部代码时同步执行的，执行时如果碰到await，就会先返回；等待await后面的表达式出结果之后再继续执行函数体内后面的语句，但是await不会阻塞async函数外的代码，await等待过程中函数外的代码正常向下同步执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        resolve(<span class="string">&quot;promise&quot;</span>)</span><br><span class="line">    &#125;, <span class="number">2000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;async 开始&quot;</span>)</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">let</span> a = <span class="keyword">await</span> p;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn().next(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;async 结束&quot;</span>)</span><br><span class="line"><span class="comment">//async 开始</span></span><br><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="comment">//async 结束</span></span><br><span class="line"><span class="comment">//（两秒后）promise</span></span><br><span class="line"><span class="comment">//2</span></span><br><span class="line"><span class="comment">//3 </span></span><br></pre></td></tr></table></figure></li></ul><h3 id="实例-解决回调地狱-按顺序完成异步操作"><a href="#实例-解决回调地狱-按顺序完成异步操作" class="headerlink" title="实例: 解决回调地狱(按顺序完成异步操作)"></a>实例: 解决回调地狱(按顺序完成异步操作)</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">http</span>(<span class="params">&#123;</span></span></span><br><span class="line"><span class="function"><span class="params">    type = <span class="string">&quot;get&quot;</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    url,</span></span></span><br><span class="line"><span class="function"><span class="params">    data = &#123;&#125;</span></span></span><br><span class="line"><span class="function"><span class="params">&#125;</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        $.ajax(&#123;</span><br><span class="line">            type,</span><br><span class="line">            url,</span><br><span class="line">            data,</span><br><span class="line">            success: <span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">                resolve(response)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">demo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res1 = <span class="keyword">await</span> http(&#123;</span><br><span class="line">        url: <span class="string">&quot;http://106.13.114.114:5000/api/firstCategory&quot;</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">let</span> firstId = res1.list[<span class="number">0</span>][<span class="number">2</span>].firstId;</span><br><span class="line">    <span class="keyword">let</span> res2 = <span class="keyword">await</span> http(&#123;</span><br><span class="line">        url: <span class="string">&quot;http://106.13.114.114:5000/api/secondCategory&quot;</span>,</span><br><span class="line">        data: &#123;</span><br><span class="line">            firstId</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="built_in">console</span>.log(res2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">demo()</span><br></pre></td></tr></table></figure><h2 id="class类"><a href="#class类" class="headerlink" title="class类"></a>class类</h2><h3 id="概念和语法-1"><a href="#概念和语法-1" class="headerlink" title="概念和语法"></a>概念和语法</h3><h4 id="概念-3"><a href="#概念-3" class="headerlink" title="概念"></a>概念</h4><ul><li><p>类和对象：</p><p>类：对象的类型模板，确定对象中共有的属性和行为</p><p>对象：类创建的实例，具体的某一个事物，一切皆为对象</p></li><li><p>ES6引入了Class(类)这个概念，通过<code>class</code>关键字，可以定义类</p></li><li><p>一个语法糖，让对象原型的写法更加清晰、更像面向对象编程的语法</p></li></ul><h4 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h4><ul><li><p>class关键字</p><ul><li>构造函数本身方法或者是属性要写在constructor方法里面</li><li>原型上的方法或者是属性直接写在class里面即可</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Class Person&#123;<span class="comment">//定义类的构造函数</span></span><br><span class="line">    <span class="function"><span class="title">construtor</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//定义一般的方法</span></span><br><span class="line">    <span class="function"><span class="title">eat</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;吃饭饭&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> P = <span class="keyword">new</span> Person(<span class="string">&#x27;xx&#x27;</span>,<span class="string">&#x27;18&#x27;</span>);</span><br><span class="line">p.eat()</span><br></pre></td></tr></table></figure></li><li><p>constructor方法</p><ul><li>是类的默认方法，通过new命令生成对象实例时，自动调用该方法</li><li>一个类必须有constructor方法，如果没有显式定义，一个空的constructor方法会被默认添加</li><li>默认返回实例对象(即this)</li></ul></li><li><p>事实上，类的所有方法都定义在类的prototype属性上面。</p></li><li><p>取值函数（getter）和存值函数（setter）（了解）</p><p>与 ES5 一样，在“类”的内部可以使用<code>get</code>和<code>set</code>关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">prop</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;getter&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">set</span> <span class="title">prop</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;setter: &#x27;</span>+value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> inst = <span class="keyword">new</span> MyClass();</span><br><span class="line"></span><br><span class="line">inst.prop = <span class="number">123</span>;</span><br><span class="line"><span class="comment">// setter: 123</span></span><br><span class="line"></span><br><span class="line">inst.prop</span><br><span class="line"><span class="comment">// &#x27;getter&#x27;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><ul><li><p>实例化方法和属性：（成员）</p><p>类相当于实例的原型(实例化对象的__proto__指向类的prototype原型)，所有在类中定义的方法，都会被实例继承</p><pre><code>    必须**通过实例化对象进行调用**</code></pre></li><li><p>静态方法和静态属性：</p><p>在方法和属性前面加关键字static，表示该方法不会被实例继承，直接<strong>通过类进行调用</strong></p><p>对于一些通用性的属性或方法，可以考虑设置为静态</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">classMethod</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo.classMethod() <span class="comment">// &#x27;hello&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = <span class="keyword">new</span> Foo();</span><br><span class="line">foo.classMethod()</span><br><span class="line"><span class="comment">// TypeError: foo.classMethod is not a function</span></span><br></pre></td></tr></table></figure></li><li><p><strong>注意</strong>：如果静态方法包含<code>this</code>关键字，这个<code>this</code>指的是类，而不是实例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">bar</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.baz();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">baz</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">baz</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;world&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo.bar() <span class="comment">// hello</span></span><br><span class="line"><span class="comment">//静态方法bar调用了this.baz,  这里的this指的是Foo类，而不是Foo的实例；等同于调用Foo.baz</span></span><br><span class="line"><span class="comment">//静态方法可以与非静态方法重名</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><h4 id="语法-3"><a href="#语法-3" class="headerlink" title="语法"></a>语法</h4><ul><li><p><code>extends</code> 关键字</p></li><li><p>子类里，如果不写constructor是可以，默认可以添加，但是如果写入constructor函数就必须要加入super();super调用父类的constructor；super必须写constructor的第一行；</p></li><li><p>不但可以继承实例化的方法和属性，静态的方法和属性也是可以继承；</p></li><li><p><code>super</code></p><p>一种是方法，一种是对象;</p><ul><li>作为方法是调用父类的constructor；</li><li>作为对象来说，就是在子类的方法里面调用父类的方法；</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name,age</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Me</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name,age,sex</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name,age) <span class="comment">// 调用父类的constructor</span></span><br><span class="line">        <span class="built_in">this</span>.sex = sex</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> Parent(<span class="string">&quot;rose&quot;</span>,<span class="number">40</span>)</span><br><span class="line"><span class="keyword">let</span> m = <span class="keyword">new</span> Me(<span class="string">&quot;joth&quot;</span>,<span class="number">18</span>,<span class="string">&#x27;male&#x27;</span>);</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">Parent</span> </span>&#123;            </span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span>  &#123;                </span><br><span class="line">        <span class="built_in">this</span>.x  = <span class="number">1</span>;            </span><br><span class="line">    &#125;            </span><br><span class="line">    <span class="function"><span class="title">print</span>(<span class="params"></span>)</span>  &#123;                </span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.x);            </span><br><span class="line">    &#125;        </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">Me</span>  <span class="keyword">extends</span>  <span class="title">Parent</span>  </span>&#123;            </span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span>  &#123;                </span><br><span class="line">        <span class="built_in">super</span>();                </span><br><span class="line">        <span class="built_in">this</span>.x  = <span class="number">2</span>;            </span><br><span class="line">    &#125;            </span><br><span class="line">    <span class="function"><span class="title">m</span>(<span class="params"></span>)</span>  &#123;   </span><br><span class="line">        <span class="built_in">super</span>.print();<span class="comment">//在子类的方法里调用父类的方法            </span></span><br><span class="line">    &#125;        </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span>  b  =  <span class="keyword">new</span>  Me();        </span><br><span class="line">b.m()  <span class="comment">//2</span></span><br></pre></td></tr></table></figure></li><li><p>父类的静态方法，可以被子类继承</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">classMethod</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> <span class="keyword">extends</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Bar.classMethod() <span class="comment">// &#x27;hello&#x27;</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="拓展-类的prototype属性和-proto-属性"><a href="#拓展-类的prototype属性和-proto-属性" class="headerlink" title="拓展:类的prototype属性和__proto__属性"></a>拓展:类的prototype属性和<code>__proto__</code>属性</h4><ul><li><p>大多数浏览器的 ES5 实现之中，每一个对象都有<code>__proto__</code>属性，指向对应的构造函数的<code>prototype</code>属性。Class 作为构造函数的语法糖，同时有<code>prototype</code>属性和<code>__proto__</code>属性，因此同时存在两条继承链。</p><ul><li>子类的<code>__proto__</code>属性，表示构造函数的继承，总是指向父类。</li><li>子类<code>prototype</code>属性的<code>__proto__</code>属性，表示方法的继承，总是指向父类的<code>prototype</code>属性。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">B.__proto__ === A <span class="comment">// true  //作为一个对象，子类(B)的原型(__proto__属性)是父类(A)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(B.prototype) <span class="comment">//A &#123;constructor: ƒ&#125;</span></span><br><span class="line">B.prototype.__proto__ === A.prototype <span class="comment">// true  //作为一个构造函数，子类（B）的原型对象（prototype属性）是父类的原型对象（prototype属性）的实例。</span></span><br></pre></td></tr></table></figure></li><li><p>实例的<code>__proto__</code>属性</p><p>子类实例的<code>__proto__</code>属性的<code>__proto__</code>属性，指向父类实例的<code>__proto__</code>属性。也就是说，子类的原型的原型，是父类的原型。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name,age</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Me</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name,age,sex</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name,age) <span class="comment">// 调用父类的constructor</span></span><br><span class="line">        <span class="built_in">this</span>.sex = sex</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> Parent(<span class="string">&quot;rose&quot;</span>,<span class="number">40</span>)</span><br><span class="line"><span class="keyword">let</span> m = <span class="keyword">new</span> Me(<span class="string">&quot;joth&quot;</span>,<span class="number">18</span>,<span class="string">&#x27;male&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(m.__proto__);<span class="comment">//Parent &#123;constructor: ƒ&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(m.__proto__ === Me.prototype); <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(m.__proto__.__proto__ === p.__proto__); <span class="comment">//true</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;let、const和var的作用和区别&quot;&gt;&lt;a href=&quot;#let、const和var的作用和区别&quot; class=&quot;headerlink&quot; title=&quot;let、const和var的作用和区别&quot;&gt;&lt;/a&gt;let、const和var的作用和区别&lt;/h2&gt;&lt;h3 i</summary>
      
    
    
    
    <category term="ES6" scheme="https://amiemie906.gitee.io/categories/ES6/"/>
    
    
    <category term="ES6" scheme="https://amiemie906.gitee.io/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>Promise的认识和使用</title>
    <link href="https://amiemie906.gitee.io/2020/09/24/es6-promise-base/"/>
    <id>https://amiemie906.gitee.io/2020/09/24/es6-promise-base/</id>
    <published>2020-09-24T13:09:49.000Z</published>
    <updated>2021-03-29T08:45:18.832Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Promise概念，then、catch方法"><a href="#Promise概念，then、catch方法" class="headerlink" title="Promise概念，then、catch方法"></a>Promise概念，then、catch方法</h2><ul><li><p>概念和理解：</p><ul><li><p><strong>一个异步操作返回的对象，用来传递异步操作的消息</strong></p></li><li><p>是ES6<strong>解决异步回调问题</strong>的一种解决方案</p></li></ul><p>由于js是单线程，很多异步操作都是依靠回调方法实现的，这种做法在逻辑比较复杂的回调嵌套中会相当复杂，也叫做回调地狱；</p><ul><li>Promise对象可以理解为一次执行的异步操作，使用Promise对象之后，使用一种链式调用的方式来组织代码，让程序更具备可读性，可维护性</li></ul><p>=&gt;可以<strong>将异步操作以同步的操作的流程表达出来</strong>，避免了层层嵌套的回调函数</p><ul><li>promise和回调函数一样，都是要<strong>解决数据的传递和消息发送问题</strong>，promise中的then一般对应成功后的数据处理，catch一般对应失败后的数据处理。</li></ul></li><li><p>语法：</p><p>promise是一个构造函数，使用时一般都需要new 一个实例对象。</p><p>接受一个函数作为参数，函数中也有两个参数（resolve，reject），resolve将异步操作成功状态下的结果返回。reject将异步操作失败状态写的结果返回。</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">           <span class="keyword">if</span>(ture)&#123;</span><br><span class="line">               resolve(<span class="string">&#x27;成功&#x27;</span>)</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               reject(<span class="string">&#x27;失败&#x27;</span>)</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);<span class="comment">//p就是实例化的promise对象</span></span><br></pre></td></tr></table></figure><ul><li>then方法：接受两个回调函数作为参数，第一个回调函数是promise状态为resolve状态下调用，第二个时reject状态下调用。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">p.then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;<span class="comment">//第一个回调函数res是个参数,接收resolve括号里返回的结果</span></span><br><span class="line">    <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;,<span class="function"><span class="params">err</span>=&gt;</span>&#123;<span class="comment">//第二个回调函数，res是个参数,接收resolve括号里返回的结果</span></span><br><span class="line">    <span class="built_in">console</span>.log(err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>catch方法：promise失败状态调用。 同时也可以捕获到一些编写错误的代码，让错误以字符串的形式体现，不报错影响后续代码执行。 </li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p.catch(<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="Promise特点"><a href="#Promise特点" class="headerlink" title="Promise特点"></a>Promise特点</h2><ul><li><p>对象的状态不受外界影响</p><ul><li><p>三 个状态：进行中pending，已成功fulfilled，已失败rejected</p><p>pending表示程序正在执行但未得到结果，即异步操作没有执行完毕，fulfilled表示程序执行完毕，且执行成功，rejected表示执行完毕但失败；</p><p>这里的成功和失败都是逻辑意义上的；并非是要报错</p></li><li><p>只有异步操作的结果可以决定当前是哪一种状态，任何其他操作都无法改变这个状态</p></li><li><p>一旦创建就会立即执行 ，处于进行中，内部直接执行的为同步，</p></li><li><p>resolve，reject—进行中转为了成功或失败，再使用then方法调用的是属于异步。   </p></li><li><p>没有调用resolve，reject时处理进行中状态，进行中下没有状态返回。</p></li></ul></li><li><p>一旦状态改变，就不会再变，任何时候都可以得到这个结果</p><ul><li>Promise状态改变只有两种可能:  pending =&gt;fulfilled    pending=&gt;rejected</li><li>一旦这两种情况发生，状态就凝固了，会一直保持这个结果，如果改变已经发生，再对Promise对象添加回调函数，也会立即得到这个结果</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;&#125;);</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    resolve(p1)</span><br><span class="line">&#125;)</span><br><span class="line">p2.then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res)<span class="comment">//此时没有结果，因为p1没有resolve或者reject调用此时是进行中的状态，没有返回值，所有p2返会p1时也没有东西。</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li><p>Promise里面同步和异步的判定</p><ul><li>里面是一个同步任务(状态为pending)</li><li>调用resolve/reject方法，状态就会发生改变</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;promise&quot;</span>) <span class="comment">//同步任务  =&gt; 进行中</span></span><br><span class="line">    resolve(<span class="string">&quot;成功&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line">p.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">123</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(res) <span class="comment">// 异步任务 （微任务）</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line"><span class="comment">//输出顺序  1   promise  2  123  成功</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h2 id="promise的链式操作"><a href="#promise的链式操作" class="headerlink" title="promise的链式操作"></a>promise的链式操作</h2><ul><li>必须在前一个then有return返回值，如果return是一个Promise对象，then 就接收的是promise对象中成功状态下的值。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;  </span><br><span class="line">         <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">             resolve(n)</span><br><span class="line">         &#125;, <span class="number">1000</span>)</span><br><span class="line">     &#125;)</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> fn(<span class="number">5</span>).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">     <span class="built_in">console</span>.log(res)</span><br><span class="line">     <span class="keyword">return</span> fn(++res)</span><br><span class="line"> &#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">     <span class="built_in">console</span>.log(res)</span><br><span class="line">     <span class="keyword">return</span> fn(++res)</span><br><span class="line"> &#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">     <span class="built_in">console</span>.log(res)</span><br><span class="line"> &#125;)</span><br></pre></td></tr></table></figure><h2 id="Promise-all-和Promise-race"><a href="#Promise-all-和Promise-race" class="headerlink" title="Promise.all()和Promise.race()"></a>Promise.all()和Promise.race()</h2><ul><li> Promise.all()  处理并发 ，所有值就一起返回</li><li> Promise.race()  返回请求完成最快的—–(一般用于设置请求超时提示）</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个请求如果超过500ms，返回请求超时提示信息</span></span><br><span class="line">        <span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                resolve(<span class="string">&quot;我是正确的请求&quot;</span>)</span><br><span class="line">            &#125;, <span class="number">300</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                resolve(<span class="string">&quot;请求超时&quot;</span>)</span><br><span class="line">            &#125;, <span class="number">500</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="built_in">Promise</span>.race([p1, p2]).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(res)</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure><ul><li>错误信息的处理<ul><li>直接在promise.all().catch(),只能返回错误信息，其他正确的信息无法返回。</li><li>谁报错谁自己处理，其他信息可以正确返回。</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                resolve(<span class="string">&quot;p1&quot;</span>)</span><br><span class="line">            &#125;, <span class="number">500</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                resolve(<span class="string">&quot;p2&quot;</span>)</span><br><span class="line">            &#125;, <span class="number">3500</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">let</span> p3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                reject(<span class="string">&quot;p3&quot;</span>)</span><br><span class="line">            &#125;, <span class="number">1000</span>)</span><br><span class="line">        &#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(err)</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 要求所有的值是一起返回的</span></span><br><span class="line">        <span class="built_in">Promise</span>.all([p1, p2, p3]).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(res)</span><br><span class="line">            &#125;)</span><br><span class="line">            .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(err)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Promise概念，then、catch方法&quot;&gt;&lt;a href=&quot;#Promise概念，then、catch方法&quot; class=&quot;headerlink&quot; title=&quot;Promise概念，then、catch方法&quot;&gt;&lt;/a&gt;Promise概念，then、catch</summary>
      
    
    
    
    <category term="ES6" scheme="https://amiemie906.gitee.io/categories/ES6/"/>
    
    
    <category term="ES6" scheme="https://amiemie906.gitee.io/tags/ES6/"/>
    
    <category term="Promise" scheme="https://amiemie906.gitee.io/tags/Promise/"/>
    
  </entry>
  
  <entry>
    <title>Git总结</title>
    <link href="https://amiemie906.gitee.io/2020/09/22/git-notes/"/>
    <id>https://amiemie906.gitee.io/2020/09/22/git-notes/</id>
    <published>2020-09-22T14:32:01.000Z</published>
    <updated>2021-03-29T02:15:25.095Z</updated>
    
    <content type="html"><![CDATA[<h2 id="git的架构"><a href="#git的架构" class="headerlink" title="git的架构"></a>git的架构</h2><ul><li>版本库：项目中，git init之后会有一个.git的目录，这个目录不属于工作区，而是git的版本库，管理git的所有内容</li><li>暂存区：版本库中的一个临时存储的区域，保存提交的文件</li><li>分支：版本库中包括若干个分支，从暂存区提交出去的文件会在分支中形成 一个版本(提交点)</li></ul><h2 id="仓库（版本库）"><a href="#仓库（版本库）" class="headerlink" title="仓库（版本库）"></a>仓库（版本库）</h2><p>仓库就是一个目录，这个目录内的文件被git所管理起来</p><h3 id="新建一个仓库"><a href="#新建一个仓库" class="headerlink" title="新建一个仓库"></a>新建一个仓库</h3><p>在一个目录下，运行</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init </span><br></pre></td></tr></table></figure><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><ol><li><p>查看仓库状态</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure></li><li><p>将有修改的文件提交到暂存区</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br></pre></td></tr></table></figure></li><li><p>将暂存区的文件提交到分支，形成一个版本(提交点)</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m <span class="string">&quot;这一次提交的信息&quot;</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h2><p>刚才我们所说的仓库其实是本地仓库，在多人开发中，每个人都会有一个自己的本地仓库，同时，更重要的，为了让多人可以共享代码，应该有一个远程仓库</p><h3 id="“远程仓库”的选择"><a href="#“远程仓库”的选择" class="headerlink" title="“远程仓库”的选择"></a>“远程仓库”的选择</h3><ul><li>github</li><li>码云</li><li>公司内部构建的远程仓库</li></ul><h3 id="远程仓库的操作"><a href="#远程仓库的操作" class="headerlink" title="远程仓库的操作"></a>远程仓库的操作</h3><ol><li><p>注册github账号</p></li><li><p>创建一个空的仓库</p></li><li><p>将需要提交到远程仓库的目录进行如下操作</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 初始化目录</span></span><br><span class="line">git init</span><br><span class="line"><span class="comment"># 查看当前状态</span></span><br><span class="line">git status</span><br><span class="line"><span class="comment"># 提交到暂存区</span></span><br><span class="line">git add .</span><br><span class="line"><span class="comment"># 提交成一个版本</span></span><br><span class="line">git commit -m <span class="string">&#x27;first commit&#x27;</span></span><br><span class="line"><span class="comment"># 在远程创建一个地址</span></span><br><span class="line">git remote add origin github仓库地址</span><br><span class="line"><span class="comment"># 将当前版本提交到远程地址的master分支</span></span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure></li></ol><h4 id="远程仓库的共享和克隆"><a href="#远程仓库的共享和克隆" class="headerlink" title="远程仓库的共享和克隆"></a>远程仓库的共享和克隆</h4><p>此时我们已经有了一个自己的远程仓库，同时仓库内的master分支上已经有我们刚才提交的文件。此时如果有其他人员需要下载这个项目，需要进行克隆操作</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> 仓库地址</span><br></pre></td></tr></table></figure><h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><h3 id="撤回提交-git-reset"><a href="#撤回提交-git-reset" class="headerlink" title="撤回提交 git reset"></a>撤回提交 git reset</h3><p><a href="https://blog.csdn.net/w958796636/article/details/53611133">参考来源</a></p><h4 id="–soft"><a href="#–soft" class="headerlink" title="–soft"></a>–soft</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 撤回上一次提交</span></span><br><span class="line">git reset --soft HEAD^</span><br><span class="line">git reset --soft HEAD~1</span><br><span class="line"><span class="comment"># 撤回2次提交</span></span><br><span class="line">git reset --soft HEAD~2</span><br><span class="line"><span class="comment"># 按提交记录撤回</span></span><br><span class="line">git <span class="built_in">log</span> <span class="comment"># 查看提交记录</span></span><br><span class="line">git reset --soft 某次记录编号 <span class="comment"># 撤回某次记录</span></span><br></pre></td></tr></table></figure><h4 id="–mixed"><a href="#–mixed" class="headerlink" title="–mixed"></a>–mixed</h4><p>意思是：不删除工作空间改动代码，撤销commit，并且撤销git add . 操作<br>这个为默认参数,<code>git reset --mixed HEAD^ </code>和 <code>git reset HEAD^</code> 效果是一样的。</p><h4 id="–soft-1"><a href="#–soft-1" class="headerlink" title="–soft"></a>–soft</h4><p>不删除工作空间改动代码，撤销commit，不撤销git add . </p><h4 id="–hard"><a href="#–hard" class="headerlink" title="–hard"></a>–hard</h4><p>删除工作空间改动代码，撤销commit，撤销git add . </p><p>注意完成这个操作后，就恢复到了上一次的commit状态。</p><h4 id="修改提交注释"><a href="#修改提交注释" class="headerlink" title="修改提交注释"></a>修改提交注释</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit --amend</span><br></pre></td></tr></table></figure><h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><p>一个远程仓库中可以有多个分支（master, dev, test），而一个分支上就存储了我们之前提交的版本，随着提交次数的增多，在分支上会形成一条时间线，每一次的git commit 操作都会在分支上形成一个版本</p><h3 id="基本操作-1"><a href="#基本操作-1" class="headerlink" title="基本操作"></a>基本操作</h3><ol><li><p>查看分支</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></table></figure></li><li><p>创建新的分支,同时复制当前分支</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch 分支名</span><br></pre></td></tr></table></figure></li><li><p>切换分支</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout 分支名</span><br></pre></td></tr></table></figure></li><li><p>将新分支提交</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin HEAD -u</span><br></pre></td></tr></table></figure></li></ol><h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><p>每一个分支都有一个指针，指针默认都会指向分支上最新的一个版本</p><p>分支提交日志查询</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> --oneline</span><br></pre></td></tr></table></figure><h3 id="分支合并"><a href="#分支合并" class="headerlink" title="分支合并"></a>分支合并</h3><p>将一个分支合并到另一个分支上</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge 分支a    <span class="comment">#把分支a合并到当前分支上</span></span><br></pre></td></tr></table></figure><h2 id="git命令总结"><a href="#git命令总结" class="headerlink" title="git命令总结"></a>git命令总结</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">git init      <span class="comment">#初始化本地仓库</span></span><br><span class="line">git add &lt;file&gt; 文件名<span class="comment">#添加文件</span></span><br><span class="line">git status   <span class="comment">#查看状态</span></span><br><span class="line">git commit   <span class="comment">#提交</span></span><br><span class="line">git push     <span class="comment">#推送到仓库</span></span><br><span class="line">git pull     <span class="comment">#从远程仓库拉取数据</span></span><br><span class="line">git <span class="built_in">clone</span>    <span class="comment">#从远程仓库拷贝数据</span></span><br><span class="line"></span><br><span class="line">git config --global user.name <span class="string">&#x27;xxx&#x27;</span> <span class="comment"># 添加用户名</span></span><br><span class="line">git config --global user.name <span class="string">&#x27;xxx&#x27;</span> <span class="comment"># 添加邮箱</span></span><br><span class="line"></span><br><span class="line">git rm --cached  index.html     <span class="comment">#删除指定的某个文件</span></span><br><span class="line">git add *.html      <span class="comment"># 添加某一类型的 文件</span></span><br><span class="line">git add .      <span class="comment">#添加全部文件 </span></span><br><span class="line">git commit -m <span class="string">&#x27;changed index.js&#x27;</span>     <span class="comment">#提交并修改备注</span></span><br><span class="line"></span><br><span class="line">.gitignore      <span class="comment"># 在该文件里面 可以添加一些不需要上传的文件</span></span><br><span class="line"></span><br><span class="line">git branch <span class="string">&#x27;...随便起一个分支名&#x27;</span>     <span class="comment"># 创建分支</span></span><br><span class="line">git checkout  <span class="string">&#x27;分支名&#x27;</span>             <span class="comment"># 切换到对应的分支</span></span><br><span class="line">git checkout  <span class="string">&#x27;master&#x27;</span>            <span class="comment"># 切换到主分支</span></span><br><span class="line">git merge       <span class="comment"># 合并分支</span></span><br><span class="line"></span><br><span class="line">git <span class="built_in">log</span>     <span class="comment"># 查看提交历史</span></span><br><span class="line">git reset --soft HEAD^     <span class="comment"># 撤回上一次提交</span></span><br><span class="line">git reset --soft HEAD~2     <span class="comment"># 撤回2次提交</span></span><br><span class="line">git reset --soft 某次记录编号     <span class="comment"># 撤回某次记录</span></span><br></pre></td></tr></table></figure><p>上传到远程仓库</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment"># 连接到远程仓库</span></span><br><span class="line">git remote add origin https://github.com/liuhaha2001/liu.git</span><br><span class="line"><span class="comment"># 查看是否连接上了</span></span><br><span class="line">git branch -M master</span><br><span class="line"><span class="comment"># 上传到master分支</span></span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;git的架构&quot;&gt;&lt;a href=&quot;#git的架构&quot; class=&quot;headerlink&quot; title=&quot;git的架构&quot;&gt;&lt;/a&gt;git的架构&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;版本库：项目中，git init之后会有一个.git的目录，这个目录不属于工作区，而是git的版</summary>
      
    
    
    
    <category term="git" scheme="https://amiemie906.gitee.io/categories/git/"/>
    
    
    <category term="git" scheme="https://amiemie906.gitee.io/tags/git/"/>
    
  </entry>
  
</feed>
