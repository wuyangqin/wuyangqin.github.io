<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Vue3造轮子（四）-Tabs组件"><meta name="keywords" content="Vue,造轮子,Vue3"><meta name="author" content="Yangqin Wu"><meta name="copyright" content="Yangqin Wu"><title>Vue3造轮子（四）-Tabs组件 | Yang's Blog</title><link rel="shortcut icon" href="/yang-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  hexoVersion: '5.4.0'
} </script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="Yang's Blog" type="application/atom+xml">
</head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%88%E6%9E%9C%E9%A2%84%E8%A7%88"><span class="toc-number">1.</span> <span class="toc-text">效果预览</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#API%E8%AE%BE%E8%AE%A1"><span class="toc-number">2.</span> <span class="toc-text">API设计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9C%80%E6%B1%82"><span class="toc-number">2.1.</span> <span class="toc-text">需求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E6%80%8E%E4%B9%88%E7%94%A8%E8%AF%A5%E7%BB%84%E4%BB%B6"><span class="toc-number">2.2.</span> <span class="toc-text">用户怎么用该组件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E8%BF%87%E7%A8%8B"><span class="toc-number">3.</span> <span class="toc-text">实现过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%A1%AE%E8%AE%A4%E5%AD%90%E7%BB%84%E4%BB%B6%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.1.</span> <span class="toc-text">如何确认子组件的类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%8A%A8%E6%80%81%E6%B8%B2%E6%9F%93%E5%B5%8C%E5%A5%97%E7%9A%84%E7%BB%84%E4%BB%B6"><span class="toc-number">3.2.</span> <span class="toc-text">如何动态渲染嵌套的组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%88%B6%E4%BD%9C%E7%A7%BB%E5%8A%A8%E7%9A%84%E5%AF%BC%E8%88%AA%E6%9D%A1"><span class="toc-number">3.3.</span> <span class="toc-text">如何制作移动的导航条</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A1%AE%E5%AE%9A%E6%A0%87%E7%AD%BE%E5%AF%BC%E8%88%AA%E7%9A%84html%E7%BB%93%E6%9E%84"><span class="toc-number">3.3.1.</span> <span class="toc-text">确定标签导航的html结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96DOM%E5%85%83%E7%B4%A0"><span class="toc-number">3.3.2.</span> <span class="toc-text">如何获取DOM元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%AE%BD%E5%BA%A6%E5%8A%A8%E6%80%81%E5%8F%98%E5%8C%96"><span class="toc-number">3.3.3.</span> <span class="toc-text">如何实现宽度动态变化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96"><span class="toc-number">3.3.4.</span> <span class="toc-text">如何优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E4%BD%BF%E7%94%A8watchEffect%E7%9A%84bug"><span class="toc-number">3.3.5.</span> <span class="toc-text">解决使用watchEffect的bug</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue3%E7%AC%94%E8%AE%B0"><span class="toc-number">4.</span> <span class="toc-text">Vue3笔记</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ref"><span class="toc-number">4.1.</span> <span class="toc-text">ref</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#watch"><span class="toc-number">4.2.</span> <span class="toc-text">watch</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%A6%E5%90%AC%E5%8D%95%E4%B8%AA%E6%95%B0%E6%8D%AE%E6%BA%90"><span class="toc-number">4.2.1.</span> <span class="toc-text">侦听单个数据源</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%A6%E5%90%AC%E5%A4%9A%E4%B8%AA%E6%95%B0%E6%8D%AE%E6%BA%90"><span class="toc-number">4.2.2.</span> <span class="toc-text">侦听多个数据源</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#watchEffect"><span class="toc-number">4.3.</span> <span class="toc-text">watchEffect</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%89%AF%E4%BD%9C%E7%94%A8%E5%88%B7%E6%96%B0%E6%97%B6%E6%9C%BA"><span class="toc-number">4.3.1.</span> <span class="toc-text">副作用刷新时机</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%81%9C%E6%AD%A2%E4%BE%A6%E5%90%AC"><span class="toc-number">4.3.2.</span> <span class="toc-text">停止侦听</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B8%85%E9%99%A4%E5%89%AF%E4%BD%9C%E7%94%A8"><span class="toc-number">4.3.3.</span> <span class="toc-text">清除副作用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#watchEffect%E5%92%8Cwatch%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">4.4.</span> <span class="toc-text">watchEffect和watch的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">5.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-number">6.</span> <span class="toc-text">参考</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://sf6-ttcdn-tos.pstatp.com/img/user-avatar/1899b33a1e9aced3316fd923f851a136~300x300.image"></div><div class="author-info__name text-center">Yangqin Wu</div><div class="author-info__description text-center"></div><div class="follow-button"><a target="_blank" rel="noopener" href="https://github.com/wuyangqin">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">34</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">22</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">12</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://wallroom.io/img/2560x1440/bg-c0174bb.png)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Yang's Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">Vue3造轮子（四）-Tabs组件</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-03-16</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Vue/">Vue</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Vue/Vue3/">Vue3</a><div class="post-meta-wordcount"><span>Word count: </span><span class="word-count">2.9k</span><span class="post-meta__separator">|</span><span>Reading time: 10 min</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="效果预览"><a href="#效果预览" class="headerlink" title="效果预览"></a>效果预览</h2><p><img src="/images/vue3-tabs/tabs.gif"></p>
<p><a target="_blank" rel="noopener" href="https://github.com/wuyangqin/xing-ui-v3">代码链接</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/wuyangqin/xing-ui-v3/commits/07da8167bb0401938f1db86c57c54be01b7ae83c">提交历史</a></p>
<h2 id="API设计"><a href="#API设计" class="headerlink" title="API设计"></a>API设计</h2><h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><ul>
<li><p>tabs的子组件只能是tab组件</p>
</li>
<li><p>点击标签切换，动态渲染内容 – v-model:selected，动态组件</p>
</li>
<li><p>tab标签下横线移动，且长度根据标签宽度变化</p>
</li>
</ul>
<h3 id="用户怎么用该组件"><a href="#用户怎么用该组件" class="headerlink" title="用户怎么用该组件"></a>用户怎么用该组件</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">x-tabs</span> <span class="attr">v-model:selected</span>=<span class="string">&quot;selectTab&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">x-tab</span> <span class="attr">label</span>=<span class="string">&quot;星星&quot;</span> <span class="attr">name</span>=<span class="string">&quot;star&quot;</span>&gt;</span>一颗小星星<span class="tag">&lt;/<span class="name">x-tab</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">x-tab</span> <span class="attr">label</span>=<span class="string">&quot;羊&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sheep&quot;</span>&gt;</span>羊羊羊<span class="tag">&lt;/<span class="name">x-tab</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">x-tab</span> <span class="attr">label</span>=<span class="string">&quot;咩咩&quot;</span> <span class="attr">name</span>=<span class="string">&quot;mie&quot;</span>&gt;</span>咩咩是全世界最可爱的猫咪<span class="tag">&lt;/<span class="name">x-tab</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">x-tabs</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h2><p>从需求出发，将每个需求分别拆分成几个小问题一一解决</p>
<h3 id="如何确认子组件的类型"><a href="#如何确认子组件的类型" class="headerlink" title="如何确认子组件的类型"></a>如何确认子组件的类型</h3><p>要解决这个问题，首先得知道如何拿到子组件。由于<code>Tab</code>组件都是通过默认插槽的形式和<code>Tabs</code>组件一起使用，因此只要拿到<code>Tabs</code>组件的插槽就可以了。</p>
<p>在<code>Vue2</code>中，是使用<code>$slots</code>来获取插槽。而在<code>Vue3</code>中，通过文档可知，<code>setup</code>函数接受的第二个参数<code>context</code>中，暴露了<code>slots</code>这个属性，因此可通过<code>context.slots</code>后获取插槽，再通过组件的name判断组件类型</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> defaults = context.slots.default()</span><br><span class="line">defaults.forEach(<span class="function"><span class="params">pane</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (pane.type.name !== <span class="string">&#x27;xx-tab&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;Tabs 子标签必须是 Tab 组件&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="如何动态渲染嵌套的组件"><a href="#如何动态渲染嵌套的组件" class="headerlink" title="如何动态渲染嵌套的组件"></a>如何动态渲染嵌套的组件</h3><p>拿到了默认插槽(<code>tab</code>组件)后，首先想到的是通过循环渲染，然后比较子组件的<code>name</code>属性和<code>selected</code>的值过滤未选中的组件内容。</p>
<p>然而这样会遇到一个问题：将<code>v-for</code>和<code>v-if</code>一起使用了。官方文档并<a target="_blank" rel="noopener" href="https://vue3js.cn/docs/zh/style-guide/#%E9%81%BF%E5%85%8D-v-if-%E5%92%8C-v-for-%E4%B8%80%E8%B5%B7%E4%BD%BF%E7%94%A8%E5%BF%85%E8%A6%81">不推荐这样做</a>。</p>
<p>因此，先通过计算属性拿到当前选中的组件，再通过动态组件渲染</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">&quot;currentTab&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;selected&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>



<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">setup</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> currentTab = computed(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> defaults.filter(<span class="function"><span class="params">pane</span> =&gt;</span> pane.props.name === props.selected)[<span class="number">0</span>]</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> &#123; currentTab &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注</strong>：如果<component/>渲染的内容改变，必须要将<code>key</code>标识也改变，否则将无法动态变化</p>
<h3 id="如何制作移动的导航条"><a href="#如何制作移动的导航条" class="headerlink" title="如何制作移动的导航条"></a>如何制作移动的导航条</h3><h4 id="确定标签导航的html结构"><a href="#确定标签导航的html结构" class="headerlink" title="确定标签导航的html结构"></a>确定标签导航的html结构</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;xx-tabs-nav&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 标签 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;xx-tabs-nav-item&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">v-for</span>=<span class="string">&quot;(pane,index) in tabPanes&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">:class</span>=<span class="string">&quot;&#123; selected: pane.name === selected &#125;&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">:key</span>=<span class="string">&quot;index&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;changeTab(pane.name)&quot;</span>&gt;</span></span><br><span class="line">    &#123;&#123; pane.label &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 导航条 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;xx-tabs-nav-indicator&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>根据需求，导航条的宽度应为当前选中标签的宽度，而导航条的位置应该是选中标签的left - 导航容器的left。那么问题就变成了：如何获取导航容器，导航条，选中标签这三个DOM元素呢？</p>
<h4 id="如何获取DOM元素"><a href="#如何获取DOM元素" class="headerlink" title="如何获取DOM元素"></a>如何获取DOM元素</h4><p>在<code>Vue2</code>中，可以使用<code>ref</code>和<code>$refs</code>来获取DOM元素，而在<code>Vue3</code>中有了新变化。如果在<code>v-for</code>中使用<code>ref</code>，需要将 <code>ref</code> 绑定到一个更灵活的函数上。</p>
<p>基于此，可以使用如下方式创建设置导航条属性的方法：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;xx-tabs-nav&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;navContainer&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;xx-tabs-nav-item&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">v-for</span>=<span class="string">&quot;(pane,index) in tabPanes&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">:class</span>=<span class="string">&quot;&#123; selected: pane.name === selected &#125;&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">:ref</span>=<span class="string">&quot;el =&gt; &#123; if (pane.name === selected) selectedItem = el &#125;&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">:key</span>=<span class="string">&quot;index&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;changeTab(pane.name)&quot;</span>&gt;</span></span><br><span class="line">    &#123;&#123; pane.label &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;xx-tabs-nav-indicator&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;indicator&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">setup</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> selectedItem = ref&lt;HTMLDivElement&gt;(<span class="literal">null</span>)</span><br><span class="line">    <span class="keyword">const</span> indicator = ref&lt;HTMLDivElement&gt;(<span class="literal">null</span>)</span><br><span class="line">    <span class="keyword">const</span> navContainer = ref&lt;HTMLDivElement&gt;(<span class="literal">null</span>)</span><br><span class="line">    <span class="keyword">const</span> getIndicatorAttr = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; width &#125; = selectedItem.value.getBoundingClientRect()</span><br><span class="line">      <span class="keyword">const</span> &#123; <span class="attr">left</span>: containerLeft &#125; = navContainer.value.getBoundingClientRect()</span><br><span class="line">      <span class="keyword">const</span> &#123; <span class="attr">left</span>: selectedItemLeft &#125; = selectedItem.value.getBoundingClientRect()</span><br><span class="line">      <span class="keyword">const</span> left = selectedItemLeft - containerLeft</span><br><span class="line">      indicator.value.style.left = left + <span class="string">&#x27;px&#x27;</span></span><br><span class="line">      indicator.value.style.width = width + <span class="string">&#x27;px&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> count = ref(<span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="如何实现宽度动态变化"><a href="#如何实现宽度动态变化" class="headerlink" title="如何实现宽度动态变化"></a>如何实现宽度动态变化</h4><p>很容易想到，当控制标签选中的变量<code>selected</code>发生变化后，生命周期函数<code>updated</code>即会执行，因此我们可以在组件挂载完成及更新完成时分别调用<code>getIndicatorAttr</code>方法实现宽度的动态变化。</p>
<p>在Vue 3中，可以使用直接导入的 <code>onX</code> 函数注册生命周期钩子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; onMounted, onUpdated &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">setup</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    onMounted(getIndicatorAttr)</span><br><span class="line">    onUpdated(getIndicatorAttr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="如何优化"><a href="#如何优化" class="headerlink" title="如何优化"></a>如何优化</h4><p>虽然需求已经实现，但问题又来了：这段代码还有没有优化空间呢？</p>
<p>于是想到，能不能通过<strong>监听<code>selected</code>的变化</strong>来实现<code>getIndicatorAttr</code>方法的调用呢？</p>
<p>查阅文档发现，Vue3还提供了一个新特性——<code>watchEffect</code>响应式追踪其依赖的变化。于是根据文档进行了尝试：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> count = ref(<span class="number">0</span>)</span><br><span class="line">onMounted(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;onMounted&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line">watchEffect(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(count.value))</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  count.value++</span><br><span class="line">&#125;, <span class="number">100</span>)</span><br><span class="line"><span class="comment">// -&gt; 0</span></span><br><span class="line"><span class="comment">// -&gt; onMounted</span></span><br><span class="line"><span class="comment">// -&gt; 1</span></span><br></pre></td></tr></table></figure>

<p>可以看到<code>watchEffect</code>会在<strong>onMounted执行前</strong>调用一次，并在所传入函数中的依赖发生变化时再次被调用。</p>
<p>但DOM元素在组件挂载完成后才能获取到，因此采取了这样的调用方式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">onMounted(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">  watchEffect(getIndicatorAttr())</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>然而，当我欣喜地期待着功能完美实现的时候，马上就打脸了：</p>
<p><img src="/images/vue3-tabs/tabs-bug.gif" alt="怎么不按剧本来呢"></p>
<h4 id="解决使用watchEffect的bug"><a href="#解决使用watchEffect的bug" class="headerlink" title="解决使用watchEffect的bug"></a>解决使用<code>watchEffect</code>的bug</h4><p>这是什么情况？马上打console看了看：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">onMounted(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;onMounted&#x27;</span>);</span><br><span class="line">  watchEffect(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(selectedItem.value);</span><br><span class="line">    getIndicatorAttr()</span><br><span class="line">  &#125;, &#123; <span class="attr">flush</span>:<span class="string">&#x27;pre&#x27;</span> &#125;) <span class="comment">// Vue3正式版默认flush为pre（即在渲染前执行watchEffect）</span></span><br><span class="line">&#125;)</span><br><span class="line">onUpdated(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;onUpdated&#x27;</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><img src="/images/vue3-tabs/tabs-console.gif"></p>
<p>重新梳理逻辑：</p>
<p><img src="/images/vue3-tabs/why.png"></p>
<p>原本是期望<code>selected</code>变化导致<code>selectedItem</code>变化，之后<code>watchEffect</code>执行，改变<code>indicator</code>位置。实际上却是：<code>watchEffect</code>在<code>selectedItem</code>变化前就执行了，发现其还未变化，因此传入的函数并未立即调用。</p>
<p>查阅文档发现确实如此：</p>
<blockquote>
<p>Vue 的响应性系统会缓存副作用函数，并异步地刷新它们，这样可以避免同一个“tick” 中多个状态改变导致的不必要的重复调用。在核心的具体实现中，组件的 <code>update</code> 函数也是一个被侦听的副作用。当一个用户定义的副作用函数进入队列时，默认情况下，会在所有的组件 <code>update</code> <strong>前</strong>执行</p>
</blockquote>
<p>文档也给出了相应的解决方案：</p>
<blockquote>
<p>如果需要在组件更新<strong>后</strong>重新运行侦听器副作用，可以传递带有 <code>flush</code> 选项的附加 <code>options</code> 对象 (默认为 <code>&#39;pre&#39;</code>)：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fire before component updates</span></span><br><span class="line">watchEffect(</span><br><span class="line">  () =&gt; &#123;</span><br><span class="line">    getIndicatorAttr()</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    flush: <span class="string">&#x27;post&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p><img src="/images/vue3-tabs/success.gif" alt="问题解决~"></p>
<h2 id="Vue3笔记"><a href="#Vue3笔记" class="headerlink" title="Vue3笔记"></a>Vue3笔记</h2><h3 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h3><p>在 Vue 2 中，在 <code>v-for</code> 里使用的 <code>ref</code>  会用 ref 数组填充相应的 <code>$refs</code> property。当存在嵌套的 <code>v-for</code> 时，这种行为会变得不明确且效率低下。</p>
<p>在 Vue 3 中，这样的用法将不再在 <code>$ref</code> 中自动创建数组。如果要从单个绑定获取多个 ref，需将 <code>ref</code> 绑定到一个更灵活的函数上</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">&quot;item in list&quot;</span> <span class="attr">:ref</span>=<span class="string">&quot;setItemRef&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ref, onBeforeUpdate, onUpdated &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="function"><span class="title">setup</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> itemRefs = []</span><br><span class="line">    <span class="keyword">const</span> setItemRef = <span class="function"><span class="params">el</span> =&gt;</span> &#123;</span><br><span class="line">      itemRefs.push(el) <span class="comment">// 这里的el即为循环的DOM元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      itemRefs,</span><br><span class="line">      setItemRef</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h3><p><code>watch</code> 需要侦听特定的数据源，并在回调函数中执行副作用。默认情况下，它也是惰性的，即只有当被侦听的源发生变化时才执行回调</p>
<h4 id="侦听单个数据源"><a href="#侦听单个数据源" class="headerlink" title="侦听单个数据源"></a>侦听单个数据源</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 侦听一个 getter</span></span><br><span class="line"><span class="keyword">const</span> state = reactive(&#123; <span class="attr">count</span>: <span class="number">0</span> &#125;)</span><br><span class="line">watch(</span><br><span class="line">  () =&gt; state.count,</span><br><span class="line">  (count, prevCount) =&gt; &#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接侦听ref</span></span><br><span class="line"><span class="keyword">const</span> count = ref(<span class="number">0</span>)</span><br><span class="line">watch(count, <span class="function">(<span class="params">count, prevCount</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="侦听多个数据源"><a href="#侦听多个数据源" class="headerlink" title="侦听多个数据源"></a>侦听多个数据源</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">watch([fooRef, barRef], <span class="function">(<span class="params">[foo, bar], [prevFoo, prevBar]</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<h3 id="watchEffect"><a href="#watchEffect" class="headerlink" title="watchEffect"></a>watchEffect</h3><p><code>watchEffect</code>方法接收的第一个参数：<code>effect</code>函数，用于定义副作用。他会立即执行传入的<code>effect</code>函数，同时响应式追踪其依赖，并在其依赖变更时重新运行该函数。</p>
<p>目的：为了根据响应式状态<em>自动应用</em>和<em>重新应用</em>副作用</p>
<blockquote>
<p>注：函数副作用是指当调用函数时，除了返回函数值之外，还对主调用函数产生附加的影响。副作用的函数不仅仅只是返回了一个值，而且还做了其他的事情</p>
</blockquote>
<p>如下代码中，副作用函数的作用是：当 <code>count</code> 被访问时，旋即在控制台打出日志。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> count = ref(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">watchEffect(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(count.value))</span><br><span class="line"><span class="comment">// -&gt; logs 0</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  count.value++</span><br><span class="line">  <span class="comment">// -&gt; logs 1</span></span><br><span class="line">&#125;, <span class="number">100</span>)</span><br></pre></td></tr></table></figure>

<h4 id="副作用刷新时机"><a href="#副作用刷新时机" class="headerlink" title="副作用刷新时机"></a>副作用刷新时机</h4><p>默认情况下，会在所有的组件 <code>update</code> <strong>前</strong>执行，如果需要在组件更新<strong>后</strong>重新运行侦听器副作用，可以传递带有 <code>flush</code> 选项的附加 <code>options</code> 对象 (默认为 <code>&#39;pre&#39;</code>)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fire before component updates</span></span><br><span class="line">watchEffect(</span><br><span class="line">  () =&gt; &#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    flush: <span class="string">&#x27;post&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h4 id="停止侦听"><a href="#停止侦听" class="headerlink" title="停止侦听"></a>停止侦听</h4><p><code>watchEffect</code>会返回一个用于停止这个监听的函数。</p>
<ul>
<li><p>这个函数可以在组件被卸载时隐式调用：当 <code>watchEffect</code> 在组件的 setup() 函数或生命周期钩子被调用时，侦听器会被链接到该组件的生命周期，并在组件卸载时自动停止</p>
</li>
<li><p>也可以在<code>setup</code>函数里被显式调用，以停止侦听</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> stop = watchEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// later</span></span><br><span class="line">stop()</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="清除副作用"><a href="#清除副作用" class="headerlink" title="清除副作用"></a>清除副作用</h4><p>有时副作用函数会执行一些异步的副作用，比如当数据变化时发送一次异步请求，如果请求过程中数据发生多次变化，那么就得多次发送请求。这样不仅浪费资源，还会因无法判断异步请求的执行顺序增加不确定性。</p>
<p>为了解决这个问题，<code>watchEffect</code>副作用传入的函数接收一个<code>onInvalidate</code>函数作为入参，用来注册清理失效时的回调。</p>
<p><code>onInvalidate</code>只作用于异步函数，并且只有在如下两种情况下才会被调用：</p>
<ul>
<li>副作用即将重新执行时</li>
<li>侦听器被停止 (如果在 <code>setup()</code> 或生命周期钩子函数中使用了 <code>watchEffect</code>，则在组件卸载时)</li>
</ul>
<p>我的理解中对异步副作用的清除就相当于<strong>函数防抖</strong>，执行这一次的副作用时，清理上一次的异步副作用，使得之前挂起的异步操作无效。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">watchEffect(<span class="function"><span class="params">onInvalidate</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 异步api调用，返回一个操作对象</span></span><br><span class="line">  <span class="keyword">const</span> token = performAsyncOperation(id.value)</span><br><span class="line">  onInvalidate(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 取消异步api的调用。</span></span><br><span class="line">    token.cancel()</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<p>Vue3 之所以是通过传入一个函数去注册失效回调，而不是从回调返回它，是因为返回值对于异步错误处理很重要。</p>
<p>在执行数据请求时，副作用函数往往是一个异步函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> data = ref(<span class="literal">null</span>)</span><br><span class="line">watchEffect(<span class="keyword">async</span> onInvalidate =&gt; &#123;</span><br><span class="line">  onInvalidate(<span class="function">() =&gt;</span> &#123;...&#125;) <span class="comment">// 在Promise解析之前注册清除函数</span></span><br><span class="line">  data.value = <span class="keyword">await</span> fetchData(props.id)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<h3 id="watchEffect和watch的区别"><a href="#watchEffect和watch的区别" class="headerlink" title="watchEffect和watch的区别"></a>watchEffect和watch的区别</h3><ul>
<li> <code>watchEffect</code> 不需要指定监听的属性，他会自动的收集依赖， 只要我们回调中引用到了 响应式的属性， 那么当这些属性变更的时候，这个回调都会执行，而 <code>watch</code> 只能监听指定的属性而做出变更(v3开始可以同时指定多个)。</li>
<li><code>watch</code> 访问侦听状态变化前后的值。</li>
<li><code>watch</code>可以懒执行回调：<code> watchEffect</code> 如果存在，组件初始化的时候就会执行一次用以收集依赖（与<code>computed</code>同理），而后收集到的依赖发生变化，这个回调才会再次执行，而 watch 不需要，因为他一开始就指定了依赖。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>生命周期钩子：onMounted / onUpdated </li>
<li><code>v-for</code>中绑定<code>ref</code></li>
<li>watchEffect的使用（注意其副作用的刷新时机）</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>官方文档：<a target="_blank" rel="noopener" href="https://vue3js.cn/docs/zh/guide/reactivity-computed-watchers.html#watcheffect">https://vue3js.cn/docs/zh/guide/reactivity-computed-watchers.html#watcheffect</a></p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/a8fdf52d0bcf">https://www.jianshu.com/p/a8fdf52d0bcf</a></p>
<p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000023669309">https://segmentfault.com/a/1190000023669309</a></p>
</div></article><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Vue/">Vue</a><a class="post-meta__tags" href="/tags/%E9%80%A0%E8%BD%AE%E5%AD%90/">造轮子</a><a class="post-meta__tags" href="/tags/Vue3/">Vue3</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2021/03/19/Vue3-ui-notes/"><i class="fa fa-chevron-left">  </i><span>Vue3造轮子总结 - 基于Vite + Vue3 + TypeScript实现的简单UI框架</span></a></div><div class="next-post pull-right"><a href="/2021/03/07/Vue3-3-dialog/"><span>Vue3造轮子（三）-Dialog组件</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(https://wallroom.io/img/2560x1440/bg-c0174bb.png)"><div class="layout" id="footer"><div class="copyright">&copy;2020 - 2021 By Yangqin Wu</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">キレイとは傷跡がないことじゃない 傷さえ愛しいというキセキだ</div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","model":{"jsonPath":"/live2dw/assets/koharu.model.json"},"display":{"superSample":2,"width":105,"height":210,"position":"right","hOffset":0,"vOffset":-20},"log":false,"tagMode":false});</script></body></html>